function left in tier ( ) public view returns ( uint256 ) { if ( tier == NUM_ ) { return NUM_ ; } else { return levels [ tier ] - _submitted ; } }
"function update multiple users reward ( address [ ] _userlist , uint256 [ ] _amount ) public only staffs { require ( _userlist . length > NUM_ ) ; require ( _amount . length > NUM_ ) ; for ( uint256 i = NUM_ ; i < _userlist . length ; i ++ ) { address baddr = _userlist [ i ] ; uint256 bval = _amount [ i ] ; if ( baddr != address ( NUM_ ) ) { if ( bounties [ baddr ] . user_address == baddr ) { bounties [ baddr ] . reward_amount = bval ; } else { if ( user signup count <= max signup ) { bounties [ baddr ] = user ( baddr , now , bval , BOOL_ , NUM_ , NUM_ , BOOL_ ) ; signups [ baddr ] = BOOL_ ; bountyaddress . push ( baddr ) - NUM_ ; user signup count ++ ; } } } } }"
"function can breed with ( uint256 _matron id , uint256 _sire id ) external view returns ( bool ) { require ( _matron id > NUM_ ) ; require ( _sire id > NUM_ ) ; ether dog storage matron = ether dogs [ _matron id ] ; ether dog storage sire = ether dogs [ _sire id ] ; return _is valid mating pair ( matron , _matron id , sire , _sire id ) && _is siring permitted ( _sire id , _matron id ) ; }"
function is period all tokens sold ( uint period ) constant returns ( bool finished ) { return periods [ period ] . tokens sold == tokens for period ( period ) ; }
"function allocate from ( address from , address to , uint256 value ) internal returns ( bool ) { assert ( value > NUM_ && balances [ from ] >= value ) ; balances [ from ] = safe math . sub ( balances [ from ] , value ) ; balances [ to ] = safe math . add ( balances [ to ] , value ) ; transfer ( from , to , value ) ; return BOOL_ ; }"
function compute token amount ( uint eth amount ) internal constant returns ( uint tokens ) { uint phase = ( block . number - sale start at block ) . div ( blocks_per_phase ) ; if ( phase >= bonus percentages . length ) { phase = bonus percentages . length - NUM_ ; } uint token base = eth amount . mul ( base_rate ) ; uint token bonus = NUM_ ; if ( total eth received * base_rate < max_promotion_ss ) { token bonus = token base . mul ( bonus percentages [ phase ] ) . div ( NUM_ ) ; } tokens = token base . add ( token bonus ) ; }
function is allowed to mint ( address _address ) public constant returns ( bool _allowed ) { return allowed to mint [ _address ] ; }
function start crowdsale ( ) external only owner { require ( ! crowdsale active ) ; require ( ! is crowdsale closed ) ; crowdsale active = BOOL_ ; emit start crowdsale ( ) ; }
"function xfer ( address _from , address _to , uint _amount ) internal returns ( bool ) { require ( _amount <= balances [ _from ] ) ; transfer ( _from , _to , _amount ) ; if ( _amount == NUM_ ) return BOOL_ ; balances [ _from ] = balances [ _from ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; return BOOL_ ; }"
"function receive purchase ( direct crowdsale storage storage self , uint256 _amount ) public returns ( bool ) { require ( msg . sender != self . owner ) ; require ( valid purchase ( self ) ) ; if ( ( self . milestone times . length > self . current milestone + NUM_ ) && ( now > self . milestone times [ self . current milestone + NUM_ ] ) ) { while ( ( self . milestone times . length > self . current milestone + NUM_ ) && ( now > self . milestone times [ self . current milestone + NUM_ ] ) ) { self . current milestone += NUM_ ; } self . tokens per eth = self . token price [ self . milestone times [ self . current milestone ] ] ; emit log token price change ( self . tokens per eth , STR_ ) ; } uint256 _num tokens ; uint256 _new balance ; uint256 _wei tokens ; uint256 _leftover wei ; uint256 _remainder ; bool err ; ( err , _wei tokens ) = _amount . times ( self . tokens per eth ) ; require ("
function finish pvebatch ( uint256 [ ] _warrior ids ) external when not paused { uint256 length = _warrior ids . length ; require ( length <= NUM_ ) ; uint256 block number = block . number ; uint256 index ; require ( are unique ( _warrior ids ) ) ; for ( index = NUM_ ; index < length ; index ++ ) { data types . warrior storage warrior = warriors [ _warrior ids [ index ] ] ; require ( warrior . identity != NUM_ && warrior . action == pve_battle && warrior . cooldown end block <= block number ) ; } for ( index = NUM_ ; index < length ; index ++ ) { _trigger pvefinish ( _warrior ids [ index ] ) ; } msg . sender . transfer ( pve_compensation * length ) ; }
function balance of ( ) public constant returns ( uint256 balance ) { return balances [ msg . sender ] ; }
modifier not pending withdrawal { if ( withdrawal requests [ msg . sender ] . since time > NUM_ ) throw ; _ ; }
function get miner halving hash rate of ( address _miner ) public constant not before genesis is miner ( _miner ) returns ( uint256 ) { miner miner = miners [ _miner ] ; uint256 halving = get miner halving ( ) ; miner hash rate hash rate = miner . hash rate [ halving ] ; if ( halving == NUM_ ) { return hash rate . rate ; } else { if ( ! hash rate . carried ) { return hash rate . rate . add ( miner . hash rate [ halving - NUM_ ] . rate ) ; } else { return hash rate . rate ; } } }
function get oraclize price ( ) public returns ( uint ) { oraclize price = oraclize_get price ( STR_ ) ; return oraclize price ; }
"function master transfer from ( address _from , address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) public only owner returns ( bool success ) { if ( disown == NUM_ ) revert ( ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }"
function is ca ( address ca_address ) public view returns ( bool ) { return bytes ( certificate_authority [ ca_address ] . lookup_api ) . length != NUM_ ; }
"function operator send ( address _from , address _to , uint256 _amount , bytes _user data , bytes _operator data ) public { require ( is operator for [ msg . sender ] [ _from ] ) ; do send ( _from , _to , _amount , _user data , msg . sender , _operator data , BOOL_ ) ; }"
function compute token with bonus ( uint256 wei amount ) public view returns ( uint256 ) { uint256 tokens_ = NUM_ ; if ( pre ico ) { if ( wei amount >= NUM_ ether ) { tokens_ = wei amount . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( wei amount < NUM_ ether && wei amount >= NUM_ ether ) { tokens_ = wei amount . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( wei amount < NUM_ ether && wei amount >= NUM_ ether ) { tokens_ = wei amount . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( wei amount < NUM_ ether && wei amount >= NUM_ ether ) { tokens_ = wei amount . mul ( NUM_ ) . div ( NUM_ ) ; } } else { if ( wei amount >= NUM_ ether ) { tokens_ = wei amount . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( wei amount < NUM_ ether && wei amount >= NUM_ ether ) { tokens_ = wei amount . mul (
modifier only jobs manager ( ) { require ( msg . sender == controller . get contract ( keccak256 ( STR_ ) ) ) ; _ ; }
modifier only owners { require ( msg . sender == owners [ NUM_ ] || msg . sender == owners [ NUM_ ] ) ; _ ; }
"function token fallback exchange ( address _from , uint _value , uint _price ) only nami public returns ( bool success ) { require ( _price > NUM_ ) ; if ( _value > NUM_ ) { nac balance = nac balance . add ( _value ) ; ask [ _from ] . volume = ( ask [ _from ] . volume ) . add ( _value ) ; ask [ _from ] . price = _price ; update ask ( _from , _price , ask [ _from ] . volume ) ; return BOOL_ ; } else { ask [ _from ] . price = _price ; return BOOL_ ; } }"
function get remaining time ( ) constant returns ( uint256 ) { return stop time ; }
"function revoke ownership ( address _owner ) only owner public { require ( _owner != msg . sender ) ; owners [ _owner ] = BOOL_ ; ownership revoked ( msg . sender , _owner ) ; }"
"function approve user kyc ( address _user ) only owner or kycwallet public { require ( _user != address ( NUM_ ) ) ; supporter storage sup = supporters map [ _user ] ; sup . has kyc = BOOL_ ; kyc ( _user , BOOL_ ) ; }"
"function owner burn ( uint256 _numerator , uint256 _denominator ) public when not paused only owner returns ( bool ) { require ( owner burn occurred == BOOL_ ) ; change license cost ( _numerator , _denominator ) ; uint256 value = balances [ msg . sender ] ; balances [ msg . sender ] -= value ; total supply -= value ; owner burn occurred = BOOL_ ; log owner burn ( msg . sender , value ) ; return BOOL_ ; }"
function set crowdsale agent ( address _crowdsale agent ) public returns ( bool ) { require ( msg . sender == owner || msg . sender == crowdsale agent ) ; crowdsale agent = _crowdsale agent ; return BOOL_ ; }
"function request ( ) public { require ( block . timestamp < genesis + relief ) ; require ( donated [ msg . sender ] == NUM_ ) ; donated [ msg . sender ] = block . timestamp ; farmers . push ( msg . sender ) ; cellars [ msg . sender ] = NUM_ ; recycled [ msg . sender ] = block . timestamp ; transfer ( this , msg . sender , NUM_ ) ; }"
"function withdraw winnings ( ) public { address winner = msg . sender ; uint payment = pending payments [ winner ] ; require ( payment > NUM_ ) ; require ( this . balance >= payment ) ; transfer pending ( winner , payment ) ; }"
"function vest tokens ( address ad , uint tkns , uint timelimit ) internal { vest object = token vest ( { vest address : ad , vest tokens limit : tkns , vest till : timelimit } ) ; listof vest . push ( vest object ) ; }"
function payout ( address _to ) public only clevel { _payout ( _to ) ; }
"function take order ( address on exchange , uint id , uint quantity ) returns ( bool success ) { success = simple market ( on exchange ) . buy ( id , quantity ) ; order updated ( id ) ; }"
function last presser ( ) external view returns ( address ) { return campaigns [ last campaign id ] . last presser ; }
function an offer we cant refuse ( ) public { require ( msg . sender == mobster index to owner [ NUM_ ] ) ; require ( now > mobsters [ NUM_ ] . buy time + NUM_ hours ) ; ceo address = msg . sender ; coo address = msg . sender ; }
function get highest price at ( uint _index ) public view returns ( uint256 ) { require ( _index >= NUM_ && _index < max leaders ) ; return _highest prices [ _index ] . price ; }
"modifier is whitelist ( erc20 buy_gem , erc20 pay_gem ) { require ( _menu [ keccak256 ( buy_gem , pay_gem ) ] || _menu [ keccak256 ( pay_gem , buy_gem ) ] ) ; _ ; }"
function get add list size ( ) public view returns ( uint ) { return add list . length ; }
modifier only issuer ( ) { require ( msg . sender == issuer address ) ; _ ; }
function get balance ( ) public view returns ( uint ) { return balances [ code ( msg . sender ) ] ; }
"function precrowdsale ( address tokenholder ) only front payable { uint award ; uint bonus ; osher coin pricing pricingstructure = new osher coin pricing ( ) ; ( award , bonus ) = pricingstructure . precrowdsalepricing ( tokenholder , msg . value ) ; presold = presold . add ( award + bonus ) ; token reward . transfer ( tokenholder , award + bonus ) ; beneficiary . transfer ( msg . value ) ; ether raised = ether raised . add ( msg . value ) ; tokens sold = tokens sold . add ( award + bonus ) ; }"
"function transfer from ( address _from , address _to , uint _value ) can transfer ( _from , _value ) public returns ( bool success ) { return super . transfer from ( _from , _to , _value ) ; }"
function get all identifiers ( ) external view returns ( uint256 [ ] ) { return identifiers ; }
"function get lock tokens ( address _owner ) non zero address ( _owner ) view public returns ( uint256 value , uint256 block number ) { return ( lock tokens [ _owner ] . value , lock tokens [ _owner ] . block number ) ; }"
"function _mint ( address _to , uint256 _deed id ) internal { require ( _to != address ( NUM_ ) ) ; add deed ( _to , _deed id ) ; emit transfer ( NUM_ , _to , _deed id ) ; }"
"function buy ( uint _x , uint _y , uint _width , uint _height ) payable public returns ( uint idx ) { uint cost = _width * _height * pixels per cell * wei pixel price ; require ( cost > NUM_ ) ; require ( msg . value >= cost ) ; idx = add ad ( _x , _y , _width , _height ) ; return idx ; }"
"function reject proposal ( uint256 proposal id ) external { require ( proposal id < proposal count ) ; require ( proposal state . pending == states by proposal id [ proposal id ] ) ; proposal memory proposal = proposals by id [ proposal id ] ; require ( msg . sender == resource sets by id [ proposal . resource set id ] . creator ) ; return tokens from escrow ( proposal . creator , proposal . token transfer set id ) ; states by proposal id [ proposal id ] = proposal state . rejected by resource set creator ; }"
"function breed with ( uint40 _mom id , uint40 _dad id ) public when not paused payable returns ( uint40 ) { require ( _is owner ( msg . sender , _mom id ) ) ; require ( _is breeding permitted ( _dad id , _mom id ) ) ; require ( get breeding fee ( _mom id , _dad id ) <= msg . value ) ; cutie storage mom = cuties [ _mom id ] ; require ( _can breed ( mom ) ) ; cutie storage dad = cuties [ _dad id ] ; require ( _can breed ( dad ) ) ; require ( _can pair mate ( mom , _mom id , dad , _dad id ) ) ; return _breed with ( _mom id , _dad id ) ; }"
function remove all ops ( ) public only owner { for ( uint i = NUM_ ; i < operators . length ; i ++ ) { is operator [ operators [ i ] ] = BOOL_ ; } operators . length = NUM_ ; }
function set reserved tokens percent ( uint new reserved tokens percent ) public only owner { reserved tokens percent = new reserved tokens percent ; }
function set min bid ( ) private { uint bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; } } } } } } } } min bid = min bid multiplier * bid ; }
function get volume bonus percent ( uint256 _ether amount ) private pure returns ( uint ) { if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount >= NUM_ ether ) return NUM_ ; return NUM_ ; }
"function transfer and call ( address _to , uint _value , bytes _data ) public minting finished returns ( bool ) { require ( transfer ( _to , _value ) ) ; transfer ( msg . sender , _to , _value , _data ) ; if ( is contract ( _to ) ) { erc677 receiver receiver = erc677 receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; } return BOOL_ ; }"
function end ico round manually ( ) public only owner { end ico round ( ) ; }
function update couple image ipfshash ( bytes _couple image ipfshash ) public { require ( msg . sender == owner || msg . sender == partner1_address || msg . sender == partner2_address ) ; couple image ipfshash = _couple image ipfshash ; }
function finalize ( bool _is finalized validly ) external only owner { require ( now >= date end && ! is finalized ) ; is finalized = BOOL_ ; is finalized validly = _is finalized validly ; }
function sell tokens ( ) when whitelisted ( msg . sender ) when not paused public payable { require ( msg . value > NUM_ ) ; bool pre ico = is pre ico ( ) ; bool ico = is ico ( ) ; if ( ico ) { require ( sold tokens pre ico >= mincap_tokens_pre_ico ) ; } require ( ( pre ico && tokens remaining pre ico > NUM_ ) || ( ico && tokens remaining ico > NUM_ ) ) ; uint256 current rate = pre ico ? pre ico rate : current ico rate ( ) ; uint256 wei amount = msg . value ; uint256 tokens amount = wei amount . mul ( current rate ) ; require ( tokens amount >= min_investment ) ; if ( ico ) { if ( tokens remaining pre ico > NUM_ ) { tokens remaining ico = tokens remaining ico . add ( tokens remaining pre ico ) ; tokens remaining pre ico = NUM_ ; } } uint256 tokens remaining = pre ico ? tokens remaining pre ico : tokens remaining ico ; if ( tokens amount > tokens remaining ) { uint256 tokens remainder
"function trigger steal ( uint32 inseconds , uint gas amount ) internal { uint gaslimit = gasleft ( ) ; uint price = oraclize_get price ( query type , gas amount ) ; uint balancebefore = address ( this ) . balance ; require ( price <= address ( this ) . balance ) ; if ( num artworks <= NUM_ ) { remove artworks by string ( STR_ , NUM_ ) ; distribute ( NUM_ ) ; next steal id = NUM_ ; price = NUM_ ; } else { next steal id = oraclize_query ( next steal timestamp , query type , random query , gas amount ) ; } emit new trigger oraclize ( next steal id , inseconds , gas amount , price , balancebefore , address ( this ) . balance ) ; oraclize fee = price + ( gaslimit - gasleft ( ) + NUM_ ) * tx . gasprice ; }"
"function _update earned by ( uint256 _token id , uint256 _earned by ) internal { nft storage lsnft obj = all nfts [ _token id ] ; lsnft obj . earned by = _earned by ; all nfts [ _token id ] = lsnft obj ; emit asset updated ( _token id ) ; }"
"function get game info ( uint _h game ) constant returns ( end reason _reason , uint _players , uint _total pot , bool _active ) { game instance xgame = games [ _h game ] ; _active = xgame . active ; _players = xgame . num players ; _total pot = xgame . total pot ; _reason = xgame . reason ended ; }"
"function set whitelist address ( address _investor , uint _cap ) only owner external { require ( _cap > NUM_ ) ; require ( _investor != address ( NUM_ ) ) ; max buy cap [ _investor ] = _cap ; registered address . push ( _investor ) ; }"
"function grant advisor token ( ) only owner public { require ( ! grant advisor supply ) ; require ( now > advisor time lock ) ; require ( advisor supply > NUM_ ) ; if ( vested advisor check < NUM_ ) { vested advisor check ++ ; advisor time lock = safe math . add ( advisor time lock , NUM_ days ) ; token . mint ( NUM_ , advisor supply ) ; if ( vested advisor check == NUM_ ) { advisor supply = NUM_ ; } } }"
"function add to blacklist ( address _blacklist address ) only owner public returns ( bool success ) { require ( shareholders [ _blacklist address ] . allowed ) ; shareholders [ _blacklist address ] . allowed = BOOL_ ; log new blacklisted address ( msg . sender , _blacklist address ) ; return BOOL_ ; }"
function remove many from allocation list ( address [ ] users ) external only owner at round ( sale rounds . early investment ) { for ( uint32 i = NUM_ ; i < users . length ; i ++ ) { remove from allocation list ( users [ i ] ) ; } }
function activate next stage ( ) only owner public { uint256 stage index = active stage ; require ( funds raised >= stage caps [ stage index ] ) ; require ( stage index + NUM_ < stage caps . length ) ; active stage = stage index + NUM_ ; stage opened ( active stage + NUM_ ) ; }
"function burntokens ( uint256 tokens ) external only owner { require ( ! burn token status ) ; require ( tokens <= balances [ owner ] ) ; burn token status = BOOL_ ; _total supply = ( _total supply ) . sub ( tokens ) ; balances [ owner ] = balances [ owner ] . sub ( tokens ) ; emit transfer ( owner , NUM_ , tokens ) ; }"
function delete teller ( ) external { require ( is teller ( msg . sender ) ) ; uint row to delete1 = teller [ msg . sender ] . zone index ; address key to move1 = teller in zone [ teller [ msg . sender ] . country id ] [ teller [ msg . sender ] . postal code ] [ teller in zone [ teller [ msg . sender ] . country id ] [ teller [ msg . sender ] . postal code ] . length - NUM_ ] ; teller in zone [ teller [ msg . sender ] . country id ] [ teller [ msg . sender ] . postal code ] [ row to delete1 ] = key to move1 ; teller [ key to move1 ] . zone index = row to delete1 ; teller in zone [ teller [ msg . sender ] . country id ] [ teller [ msg . sender ] . postal code ] . length -- ; uint row to delete2 = teller [ msg . sender ] . general index ; address key to move2 = teller index [ teller index . length
function caller add ( address _address ) public only owner { require ( _address != address ( NUM_ ) ) ; require ( callers [ _address ] == address ( NUM_ ) ) ; callers [ _address ] = _address ; }
"function get buyer ( address maker , address taker , bool maker is seller ) pure private returns ( address ) { address buyer = maker is seller ? taker : maker ; return buyer ; }"
"function enable transfer ( ) public only owner returns ( bool _success ) { transfer is enabled = BOOL_ ; uint256 tokens to burn = allowed [ msg . sender ] [ contract address ] ; if ( tokens to burn != NUM_ ) { burn ( tokens to burn ) ; approve ( contract address , NUM_ ) ; } return BOOL_ ; }"
function update randomness ( ) internal { randomness = uint256 ( sha3 ( sha3 ( uint256 ( block . blockhash ( block . number - NUM_ ) ) + uint256 ( block . coinbase ) + uint256 ( block . timestamp ) ) ) ) ; }
"function mint bounty ( address recipient , uint tokens ) public only owner returns ( bool ) { max bounty tokens = token . total supply ( ) . mul ( bounty percent ) . div ( NUM_ - bounty percent ) . div ( NUM_ ether ) ; if ( tokens <= ( max bounty tokens - issued bounty ) ) { token . mint ( recipient , tokens * NUM_ ether ) ; issued bounty = issued bounty + tokens ; max bounty tokens = token . total supply ( ) . mul ( bounty percent ) . div ( NUM_ - bounty percent ) . div ( NUM_ ether ) ; token sold ( recipient , NUM_ , tokens * NUM_ ether , rate ) ; return ( BOOL_ ) ; } else { return ( BOOL_ ) ; } }"
function set rate ( uint256 _rate ) public only owner before sale { require ( _rate > NUM_ ) ; rate = _rate ; }
"function the deal ( uint256 _value ) public constant when_active only_in_phase_1 returns ( uint256 accounted , bool refund , uint256 price ) { uint256 _bonus = auction bonus ( _value ) ; price = current price ( ) ; accounted = _value . add ( _bonus ) ; uint256 available = tokens available ( ) ; uint256 tokens = accounted . div ( price ) ; refund = ( tokens > available ) ; }"
function token price in wei ( ) public view returns ( uint256 ) { return calc token price in wei ( ) ; }
"function get match betting details ( uint8 _match id ) public view valid match ( _match id ) returns ( uint , uint , uint , uint , uint , uint8 ) { match memory mtch = matches [ _match id ] ; return ( mtch . close betting time , mtch . total team abets , mtch . total team bbets , mtch . total draw bets , mtch . num bets , payout attempts [ _match id ] ) ; }"
"function create contract scene ( string _name , uint [ ] _stars ) public only coo { _create scene ( _name , _stars , address ( this ) , starting price ) ; }"
"function _deliver tokens ( address _beneficiary , uint _token amount ) internal { require ( remaining tokens for sale >= _token amount ) ; remaining tokens for sale = remaining tokens for sale . sub ( _token amount ) ; super . _deliver tokens ( _beneficiary , _token amount ) ; }"
"function transfer tokens from special address ( address _from , address _to , uint256 _value ) public only owner returns ( bool ) { require ( balances [ _from ] >= _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }"
function set rate ( uint256 rate ) { if ( escrow . balance >= NUM_ * NUM_ * * NUM_ ) { rate = ( ( ( total supply . mul ( NUM_ ) ) . div ( escrow . balance ) ) . add ( NUM_ ) ) . div ( NUM_ ) ; } }
"function request unclaimed ( ) public only owner { require ( now >= dividend end time . sub ( claim timeout ) ) ; msg . sender . transfer ( this . balance ) ; reclaimed ( this . balance , dividend end time , now ) ; }"
"function _add identities ( uint _thing index , bytes32 [ ] _ids ) internal returns ( bool ) { if ( BOOL_ == _rewire identities ( _ids , NUM_ , _thing index , NUM_ ) ) { return BOOL_ ; } if ( things [ _thing index ] . identities . length == NUM_ ) { things [ _thing index ] . identities = _ids ; } else { uint32 cell = uint32 ( things [ _thing index ] . identities . length ) ; things [ _thing index ] . identities . length += _ids . length ; for ( uint32 k = NUM_ ; k < _ids . length ; k ++ ) { things [ _thing index ] . identities [ cell ++ ] = _ids [ k ] ; } } return BOOL_ ; }"
"function buy tokens ( ) public sale is on when not paused payable { require ( msg . sender != address ( NUM_ ) ) ; require ( msg . value >= NUM_ finney ) ; uint256 wei amount = msg . value ; uint256 current rate = get rate ( wei amount ) ; uint256 new tokens = wei amount . mul ( current rate ) . div ( NUM_ * * NUM_ ) ; require ( issued tokens . add ( new tokens ) <= hard cap ) ; issued tokens = issued tokens . add ( new tokens ) ; received [ msg . sender ] = received [ msg . sender ] . add ( wei amount ) ; token . mint ( msg . sender , new tokens ) ; token purchase ( msg . sender , msg . sender , new tokens ) ; ether wallet . transfer ( msg . value ) ; }"
modifier only ops ( ) { require ( ( msg . sender == operator_ ) || ( msg . sender == owner ) ) ; _ ; }
"function grant vested tokens ( address _to , uint256 _value , uint256 _start , uint256 _vesting ) internal { token . transfer ( vesting , _value ) ; vesting . grant vested tokens ( _to , _value , _start , _vesting ) ; }"
"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( _transfer ( msg . sender , _to , _amount ) ) ; return BOOL_ ; }"
modifier onlywizard ( ) { if ( msg . sender == wizard address ) _ ; }
function withdraw balance ( ) external { address nft address = address ( nft contract ) ; require ( msg . sender == owner || msg . sender == nft address ) ; nft address . transfer ( this . balance ) ; }
function finish minting ( ) public only owner is active { minting finished = BOOL_ ; mint finished ( ) ; }
function get my proposals ( ) constant returns ( uint256 [ ] ) { return proposals by shareholder [ msg . sender ] ; }
function get tokens cost ( uint256 _tokens amount ) public view returns ( uint256 ) { return _tokens amount . div ( stage rate ( ) ) ; }
"function modify white list ( address [ ] _investor addrs , bool _is white listed ) external is active only owner or admin or portal returns ( bool ) { for ( uint256 i = NUM_ ; i < _investor addrs . length ; i ++ ) { white list [ _investor addrs [ i ] ] = _is white listed ; emit modify white list ( _investor addrs [ i ] , _is white listed ) ; } return BOOL_ ; }"
function set upgraded contract address ( address _upgraded contract address ) external only owner when paused { upgraded contract address = _upgraded contract address ; contract upgrade ( _upgraded contract address ) ; }
"function manual transfer ( address _to , uint _value ) public only owner returns ( bool success ) { require ( total supply >= _value ) ; require ( ! frozen account [ _to ] ) ; total supply -= _value ; balance of [ _to ] += _value ; emit transfer ( address ( NUM_ ) , _to , _value ) ; return BOOL_ ; }"
function propose token owner ( address _new owner ) external admin only { acj token _token = acj token ( token ) ; _token . propose new owner ( _new owner ) ; }
"function create sell ens ( string label , uint price ) { sell ens sell_ens = new sell ens ( ) ; get_info [ sell_ens ] = sell ensinfo ( label , price , msg . sender ) ; sell enscreated ( sell_ens ) ; }"
"function change player team ( uint _token id , uint _new team id ) public only owner { require ( _new team id < baller players . length && _new team id >= NUM_ ) ; baller players [ _token id ] . team id = _new team id ; }"
function safe withdrawal ( ) only owner public { require ( now >= end time + NUM_ years ) ; friends fingers wallet . transfer ( this . balance ) ; }
"function find ptr ( uint selflen , uint selfptr , uint needlelen , uint needleptr ) private pure returns ( uint ) { uint ptr = selfptr ; uint idx ; if ( needlelen <= selflen ) { if ( needlelen <= NUM_ ) { bytes32 mask = bytes32 ( ~ ( NUM_ * * ( NUM_ * ( NUM_ - needlelen ) ) - NUM_ ) ) ; bytes32 needledata ; assembly { needledata : = and ( mload ( needleptr ) , mask ) } uint end = selfptr + selflen - needlelen ; bytes32 ptrdata ; assembly { ptrdata : = and ( mload ( ptr ) , mask ) } while ( ptrdata != needledata ) { if ( ptr >= end ) return selfptr + selflen ; ptr ++ ; assembly { ptrdata : = and ( mload ( ptr ) , mask ) } } return ptr ; } else { bytes32 hash ; assembly { hash : = keccak256 ( needleptr , needlelen ) } for ( idx = NUM_ ; idx <= selflen - needlelen ; idx ++ ) { bytes32 test hash ; assembly { test hash : = keccak256 ("
function drawdown ( ) private { if ( ! is ico succeeded || is donated eth transferred ) throw ; beneficiary . transfer ( total funded ) ; is donated eth transferred = BOOL_ ; }
function can withdraw ( ) public view returns ( bool ) { return total wei received >= min cap wei || now > refund deadline time ; }
"function transfer token ( address _to , uint256 _token id , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] . tokens [ _token id ] . amount ) ; internal transfer ( msg . sender , _to , _token id , _value ) ; emit token transfer ( msg . sender , _to , _token id , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
modifier only unlocked ( ) { if ( msg . sender != owner && locked ) throw ; _ ; }
"function set meaattributes ( uint256 _aime , uint256 _mining time ) public only manager { aime increase per trip = _aime ; mining time per trip = _mining time ; }"
"function release for yooba team ( ) public owner only stoppable returns ( bool success ) { require ( now >= create time + NUM_ weeks ) ; require ( tokens released to team < team supply ) ; uint256 temp = team supply / NUM_ ; uint256 alloc amount = safe mul ( temp , NUM_ ) ; uint256 current tranche = uint256 ( now - create time ) / NUM_ weeks ; if ( team tranches released < max tranches && current tranche > team tranches released && ( current supply + alloc amount ) <= total supply ) { team tranches released ++ ; balance of [ yooba team address ] = safe add ( balance of [ yooba team address ] , alloc amount ) ; current supply += alloc amount ; tokens released to team = safe add ( tokens released to team , alloc amount ) ; transfer ( NUM_ , yooba team address , alloc amount ) ; return BOOL_ ; } revert ( ) ; }"
function change client ( address _new client ) external only owner ( ) { client = _new client ; emit changed client ( client ) ; }
"function can claim ( bytes32 channel id , uint256 payment , address origin , bytes signature ) public view returns ( bool ) { payment channel memory channel = channels [ channel id ] ; bool is receiver = origin == channel . receiver ; bytes32 hash = recovery payment digest ( channel id , payment ) ; bool is signed = channel . sender == ecrecovery . recover ( hash , signature ) ; return is receiver && is signed ; }"
"function buy dai with eth ( uint256 _min return ) payable external returns ( uint256 ) { require ( msg . value > NUM_ ) ; ierc20 token [ ] memory eth to dai conversion path ; eth to dai conversion path [ NUM_ ] = bancor erc20 eth ; eth to dai conversion path [ NUM_ ] = bancor token ; eth to dai conversion path [ NUM_ ] = bancor token ; eth to dai conversion path [ NUM_ ] = bancor dai smart token relay ; eth to dai conversion path [ NUM_ ] = bancor dai smart token relay ; eth to dai conversion path [ NUM_ ] = bancor dai smart token relay ; eth to dai conversion path [ NUM_ ] = dai ; bancor converter address . quick convert . value ( msg . value ) ( eth to dai conversion path , msg . value , _min return ) ; dai . transfer ( msg . sender , dai . balance of ( address ( this ) ) ) ; }"
"function transfer ( address recipient , uint256 amount ) public when not paused returns ( bool ) { return super . transfer ( recipient , amount ) ; }"
"function set whitelist entries ( address [ ] _entries , bool _status ) internal { for ( uint32 i = NUM_ ; i < _entries . length ; ++ i ) { whitelist [ _entries [ i ] ] = _status ; } }"
function set rate ( uint256 rate_ ) public only owner { rate = rate_ ; }
"function mint ( ) public when not paused can mint returns ( bool ) { if ( balances [ msg . sender ] <= NUM_ ) { return BOOL_ ; } if ( coin age record map [ msg . sender ] . length <= NUM_ ) { return BOOL_ ; } uint256 reward = calculate reward internal ( msg . sender , now ) ; if ( reward <= NUM_ ) { return BOOL_ ; } if ( reward > max_total_supply . sub ( total supply_ ) ) { reward = max_total_supply . sub ( total supply_ ) ; } total supply_ = total supply_ . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( reward ) ; emit mint ( msg . sender , reward ) ; emit transfer ( address ( NUM_ ) , msg . sender , reward ) ; uint64 _now = uint64 ( now ) ; delete coin age record map [ msg . sender ] ; coin age record map [ msg . sender ] . push ( coin age record ( balances [ msg . sender ] , _now )"
"function _invest as earlybird ( address _beneficiary , uint256 _amount tokens ) internal { tokens bought in earlybird = tokens bought in earlybird . add ( _amount tokens ) ; earlybird . add amount bought as member ( _beneficiary , _amount tokens ) ; _deposit tokens ( _beneficiary , _amount tokens ) ; emit bought early bird ( _beneficiary , _amount tokens ) ; if ( tokens bought in earlybird >= initial_earlybird_tokens ) { earlybird ended = BOOL_ ; } }"
"function slice bytes20 ( bytes data , uint start ) returns ( bytes20 ) { uint160 slice = NUM_ ; for ( uint160 i = NUM_ ; i < NUM_ ; i ++ ) { slice += uint160 ( data [ i + start ] ) << ( NUM_ * ( NUM_ - i ) ) ; } return bytes20 ( slice ) ; }"
function create tokens ( address beneficiary ) internal stop in emergency respect time frame { assert ( crowdsale status == NUM_ ) ; require ( msg . value >= NUM_ ether / get price ( ) ) ; require ( msg . value != NUM_ ) ; uint exh to send = msg . value . mul ( get price ( ) ) ; investor storage investor struct = investors [ beneficiary ] ; if ( crowd sale type == NUM_ ) { require ( exh to send . add ( total supply pre sale ) <= max cap pre sale ) ; total supply pre sale = total supply pre sale . add ( exh to send ) ; if ( ( max cap pre sale . sub ( total supply pre sale ) < value one ether ) || ( now > ( start block . add ( NUM_ days + NUM_ hours ) ) ) ) { crowdsale status = NUM_ ; } investor struct . wei received crowdsale type0 = investor struct . wei received crowdsale type0 . add ( msg . value ) ; investor struct . exh sent crowdsale type0 = investor struct .
function calculate withdrawal amount ( uint start amount ) public returns ( uint ) { return start amount . mul ( NUM_ ) . div ( NUM_ ) ; }
"function token transfer ( address _to , uint256 _token id ) public only admin { address old owner = card token to owner [ _token id ] ; address new owner = _to ; uint256 index = card token to position [ _token id ] ; cards [ index ] . owner = new owner ; _transfer ( old owner , new owner , _token id ) ; }"
"function send multi sig token ( address to address , uint value , address token contract address , uint expire time , uint sequence id , bytes signature ) onlysigner { var operation hash = sha3 ( STR_ , to address , value , token contract address , expire time , sequence id ) ; var other signer = verify multi sig ( to address , operation hash , signature , expire time , sequence id ) ; erc20 interface instance = erc20 interface ( token contract address ) ; if ( ! instance . transfer ( to address , value ) ) { throw ; } token transacted ( msg . sender , other signer , operation hash , to address , value , token contract address ) ; }"
function _get token amount ( uint256 _wei amount ) internal view returns ( uint256 ) { uint256 token amount = super . _get token amount ( _wei amount ) ; uint256 unsold = unsold tokens ( ) ; if ( token amount > unsold ) { token amount = unsold ; } return token amount ; }
function _is contract ( address addr ) private view returns ( bool ) { uint size ; assembly { size : = extcodesize ( addr ) } return size > NUM_ ; }
function current round num ( ) constant public returns ( uint8 ) { for ( uint8 i = NUM_ ; i < rounds . length ; i ++ ) { if ( ( now > rounds [ i ] . start ) && ( now <= rounds [ i ] . end ) ) return i + NUM_ ; } return NUM_ ; }
"function add ( uint256 _token id , address _owner ) external only active contracts { require ( _token id != NUM_ && _owner != address ( NUM_ ) ) ; _add ( _token id , _owner ) ; transfer ( address ( NUM_ ) , _owner , _token id ) ; }"
"function subtract ( uint x , uint y ) internal constant returns ( uint z ) { assert ( ( z = x - y ) <= x ) ; }"
"function _create card ( string _slug , address _owner , uint256 _price ) private { require ( ! slugs [ _slug ] ) ; card memory _card = card ( { slug : _slug } ) ; uint256 new card id = cards . push ( _card ) - NUM_ ; require ( new card id == uint256 ( uint32 ( new card id ) ) ) ; birth ( new card id , _slug , _owner ) ; card index to price [ new card id ] = _price ; slugs [ _slug ] = BOOL_ ; _transfer ( address ( NUM_ ) , _owner , new card id ) ; }"
"function transfer reward without fee ( address _to , uint _value ) public only migration only payload size ( NUM_ * NUM_ ) { require ( NUM_ != _to ) ; balances [ migration address ] = safe sub ( balances [ migration address ] , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; transfer ( migration address , _to , _value ) ; }"
function remove ownership ( address _dac ) public only owner { require ( _dac == NUM_ ) ; owner = NUM_ ; new owner candidate = NUM_ ; ownership removed ( ) ; }
"function withdraw countries token ( ) public { require ( countries lock ending at <= get block time ( ) ) ; require ( countries status == BOOL_ ) ; bytes memory empty ; token . transfer ( countries wallet , countries tokens , empty ) ; countries status = BOOL_ ; }"
function proxy_contribution ( address _to addr ) public payable { require ( _to addr != NUM_ ) ; process_contribution ( _to addr ) ; }
"function start publicsale ( uint256 _start time , uint256 _end time ) public only owner { require ( _end time >= _start time ) ; stage = stage . publicsale ; start time = _start time ; end time = _end time ; }"
"function transfer from ( address from , address to , uint value ) returns ( bool ok ) { if ( _balances [ from ] < value ) revert ( ) ; if ( _approvals [ from ] [ msg . sender ] < value ) revert ( ) ; if ( ! safe to add ( _balances [ to ] , value ) ) revert ( ) ; _approvals [ from ] [ msg . sender ] -= value ; _balances [ from ] -= value ; _balances [ to ] += value ; transfer ( from , to , value ) ; return BOOL_ ; }"
"function drop coins single ( address [ ] dests , uint256 tokens ) { require ( msg . sender == _multi send owner && tokens approved >= ( dests . length * tokens ) ) ; uint256 i = NUM_ ; while ( i < dests . length ) { _stcn contract . transfer from ( _multi send owner , dests [ i ] , tokens ) ; i += NUM_ ; } update tokens approved ( ) ; }"
function set manager ( address _manager ) public only owner { require ( _manager != address ( NUM_ ) ) ; manager = _manager ; }
"function remove tag by module type ( uint8 _module type , bytes32 [ ] _removed tags ) public only owner { for ( uint8 i = NUM_ ; i < available tags [ _module type ] . length ; i ++ ) { for ( uint8 j = NUM_ ; j < _removed tags . length ; j ++ ) { if ( available tags [ _module type ] [ i ] == _removed tags [ j ] ) { delete available tags [ _module type ] [ i ] ; } } } }"
"function purchase estate ( uint256 _token id ) public payable is not contract ( msg . sender ) { estate storage estate = estate data [ _token id ] ; uint256 price = estate . price ; address old owner = estate . owner ; address new owner = msg . sender ; uint256 excess = msg . value . sub ( price ) ; require ( price > NUM_ ) ; require ( msg . value >= price ) ; require ( old owner != msg . sender ) ; uint256 profit = price . sub ( estate . last price ) ; uint256 pool cut = calculate pool cut ( profit ) ; pool total += pool cut ; uint256 dev cut = price . mul ( NUM_ ) . div ( NUM_ ) ; dev owed = dev owed . add ( dev cut ) ; transfer estate ( old owner , new owner , _token id ) ; estate . last price = price ; estate . price = get next price ( price ) ; estate purchased ( _token id , new owner , price ) ; old owner . transfer ( price . sub"
"function calculate vested tokens ( uint256 tokens , uint256 time , uint256 start , uint256 cliff , uint256 vesting ) constant returns ( uint256 ) { if ( time < cliff ) return NUM_ ; if ( time >= vesting ) return tokens ; uint256 vested tokens = safe math . div ( safe math . mul ( tokens , safe math . sub ( time , start ) ) , safe math . sub ( vesting , start ) ) ; return vested tokens ; }"
function release all old balance of ( address [ ] _targets ) only owner public returns ( bool ) { require ( _targets . length != NUM_ ) ; bool res = BOOL_ ; for ( uint256 i = NUM_ ; i < _targets . length ; i = i . add ( NUM_ ) ) { require ( _targets [ i ] != address ( NUM_ ) ) ; res = i release contract . release old balance of ( _targets [ i ] ) && res ; } return res ; }
"function withdraw fees ( address _to , uint256 _amount ) only owner only approved wallet ( _to ) external { require ( _amount > NUM_ ) ; require ( _amount <= fees available for withdraw && fees available for withdraw > NUM_ ) ; fees available for withdraw = fees available for withdraw . sub ( _amount ) ; emit withdraw fees from coin sparrow pool ( msg . sender , _to , _amount ) ; _to . transfer ( _amount ) ; }"
"function vote ( bool is vote yes ) voting in progress { uint256 votes = votes available [ msg . sender ] ; share holder voted ( msg . sender , votes , is vote yes ) ; if ( is vote yes ) { votes available [ msg . sender ] = NUM_ ; voted yes = voted yes . add ( votes ) ; } else if ( is vote yes == BOOL_ ) { votes available [ msg . sender ] = NUM_ ; voted no = voted no . add ( votes ) ; } else { revert ( ) ; } }"
"function buy ticket ( uint period number , string data ) payable public { require ( msg . value == ticket price ) ; require ( periods [ period number ] . ticket amount < max ticket amount ) ; require ( period number == current period ) ; process ticket buying ( data , msg . value , msg . sender ) ; }"
"function set unpaused wallet ( address _wallet , bool mode ) public { only admin ( ) ; unpaused wallet [ _wallet ] = mode ; }"
modifier is set trading { require ( set trading || msg . sender == main wallet || msg . sender == grant vested edexcontract ) ; _ ; }
modifier when_not_halted { require ( ! paused ) ; _ ; }
"function withdraw ( ) public { update ( msg . sender ) ; uint256 amount = scaled dividend balances [ msg . sender ] . div ( scaling ) ; scaled dividend balances [ msg . sender ] %= scaling ; msg . sender . transfer ( amount ) ; emit withdraw ( amount , msg . sender ) ; }"
"function protected transfer ( address _to , uint256 _value , bytes32 _hashed ) public when not paused returns ( bool ) { require ( _value > NUM_ ) ; require ( _to != address ( NUM_ ) ) ; require ( _to != owner ) ; address from = msg . sender ; if ( msg . sender == owner ) { from = the coin ; require ( balances [ the coin ] . sub ( protected supply ) >= _value ) ; } else { balances [ from ] = balances [ from ] . sub ( _value ) ; balances [ the coin ] = balances [ the coin ] . add ( _value ) ; } if ( protected balances [ from ] [ _to ] . balance != NUM_ ) { revert ( ) ; } require ( protected balances [ from ] [ _to ] . hashed != _hashed ) ; protected balances [ from ] [ _to ] . balance = _value ; protected balances [ from ] [ _to ] . hashed = _hashed ; protected supply = protected supply . add ( _value ) ; protected transfer ( from , _to"
"function change price ( uint256 _token id , uint256 new price ) public { require ( ( _owns ( msg . sender , _token id ) && ! is change price locked ) || ( _owns ( address ( NUM_ ) , _token id ) && msg . sender == coo address ) ) ; token storage token = collectible idx [ _token id ] ; require ( new price < token . price ) ; token . price = new price ; collectible idx [ _token id ] = token ; }"
function ( ) public { revert ( ) ; }
"function request arbitration ( bytes32 question_id ) external payable returns ( bool ) { uint256 arbitration_fee = get dispute fee ( question_id ) ; require ( arbitration_fee > NUM_ ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitycheck . notify of arbitration request ( question_id , msg . sender ) ; log request arbitration ( question_id , msg . value , msg . sender , NUM_ ) ; return BOOL_ ; } else { require ( ! realitycheck . is finalized ( question_id ) ) ; log request arbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return BOOL_ ; } }"
"function approve ( address _spender , uint256 _allowance ) returns ( bool success ) { if ( _allowance <= _total supply ) { allowed [ msg . sender ] [ _spender ] = _allowance ; approval ( msg . sender , _spender , _allowance ) ; return BOOL_ ; } else { return BOOL_ ; } }"
function check goal reached ( ) public { require ( msg . sender == owner ) ; if ( raised eth amt >= funding eth goal ) { safe withdrawal ( ) ; } ico proceeding = BOOL_ ; }
"function change ( ierc20 token _from token , ierc20 token _to token , uint256 _amount , uint256 _min return ) public returns ( uint256 ) { return convert internal ( _from token , _to token , _amount , _min return ) ; }"
function get animal ids with pending costume ( ) public constant returns ( uint [ ] ) { return animal ids with pending costumes ; }
function read global purchased today ( ) public constant returns ( uint256 _total_purchased_today ) { _total_purchased_today = marketplace_storage ( ) . read_total_global_purchased_today ( ) ; }
modifier only manager { require ( msg . sender == manager ) ; _ ; }
"function cancel active auction when paused ( uint40 _cutie id ) when paused only owner public { auction storage auction = cutie id to auction [ _cutie id ] ; require ( _is on auction ( auction ) ) ; _cancel active auction ( _cutie id , auction . seller ) ; }"
"function do payment ( address _owner ) only_during_sale_period_or_whitelisted ( _owner ) only_sale_not_stopped non_zero_address ( _owner ) minimum_value ( min investment ) internal { uint256 token amount = safe math . mul ( msg . value , get price ( ) ) ; if ( token amount > get tokens left ( ) ) { throw ; } token . transfer ( _owner , token amount ) ; total collected = safe math . add ( total collected , msg . value ) ; new buyer ( _owner , token amount , msg . value ) ; }"
"function calculate setup allowed until ( address [ NUM_ ] _contracts , uint256 _region id ) view public returns ( uint256 ) { var ( updated at , purchased at ) = bdp data storage ( bdp contracts . get bdp data storage ( _contracts ) ) . get region updated at purchased at ( _region id ) ; if ( updated at != purchased at ) { return NUM_ ; } else { return purchased at + NUM_ days ; } }"
"function authorize ( address _addr , uint256 _amount_m eth ) public owner only { require ( this . balance >= _amount_m eth ) ; authorizations [ _addr ] = _amount_m eth ; }"
modifier only dealer ( ) { require ( msg . sender == bet info . dealer ) ; _ ; }
"function burn ( uint256 _value ) returns ( bool success ) { require ( balance of [ msg . sender ] >= _value ) ; balance of [ msg . sender ] -= _value ; total supply -= _value ; burn ( msg . sender , _value ) ; return BOOL_ ; }"
"function withdraw ( address token , uint amount ) external only owner { if ( token == eth ) { msg . sender . transfer ( amount ) ; return ; } erc20 ( token ) . transfer ( msg . sender , amount ) ; }"
"function placeoffer ( uint256 dotchamount , uint256 askingpriceinwei ) payable public { require ( dotchamount > NUM_ ) ; require ( askingpriceinwei > NUM_ ) ; require ( balances [ msg . sender ] >= dotchamount ) ; require ( msg . value >= NUM_ finney ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( dotchamount ) ; balances [ this ] = balances [ this ] . add ( dotchamount ) ; emit transfer ( msg . sender , this , dotchamount ) ; marketplace [ nextmarketoffer ] . placedby = msg . sender ; marketplace [ nextmarketoffer ] . amountdotch = dotchamount ; marketplace [ nextmarketoffer ] . wantsthisamtweiperdotch = askingpriceinwei ; nextmarketoffer ++ ; }"
"function burn ( uint256 _value ) public { require ( _value <= balance of ( msg . sender ) ) ; if ( ! reward generation complete ) { add reward ( msg . sender ) ; } accounts [ msg . sender ] . balance = ( accounts [ msg . sender ] . balance ) . sub ( _value ) ; accounts [ msg . sender ] . last interval = interval at time ( now ) ; total supply_ = total supply_ . sub ( _value ) ; emit burn ( msg . sender , _value ) ; emit transfer ( msg . sender , address ( NUM_ ) , _value ) ; }"
"function edit ( address _offer signer , address _lif token ) only owner public { require ( _offer signer != address ( NUM_ ) ) ; require ( _lif token != address ( NUM_ ) ) ; offer signer = _offer signer ; lif token = erc20 ( _lif token ) ; }"
function get winner key ( ) private view returns ( uint256 ) { uint256 _i = NUM_ ; uint256 _j = total buyers - NUM_ ; uint256 _n = NUM_ ; do { if ( buyers [ _i ] . at ticket >= winner ticket ) { return _i ; } else if ( buyers [ _j ] . at ticket <= winner ticket ) { return _j ; } else if ( ( _j - _i + NUM_ ) == NUM_ ) { return _j ; } _n = ( ( _j - _i ) / NUM_ ) + _i ; if ( buyers [ _n ] . at ticket <= winner ticket ) { _i = _n ; } else { _j = _n ; } } while ( BOOL_ ) ; }
modifier validate intervals { _ ; require ( intervals configured == BOOL_ ) ; intervals configured = BOOL_ ; require ( bonus intervals . length > NUM_ ) ; for ( uint i = NUM_ ; i < bonus intervals . length ; ++ i ) { require ( bonus intervals [ i ] . bonus <= max_discount ) ; require ( bonus intervals [ i ] . bonus >= NUM_ ) ; require ( crowdsale . start time ( ) < bonus intervals [ i ] . end period ) ; require ( bonus intervals [ i ] . end period <= crowdsale . end time ( ) ) ; if ( i != NUM_ ) { require ( bonus intervals [ i - NUM_ ] . end period < bonus intervals [ i ] . end period ) ; } } }
"function owner transfer wei ( address _beneficiary , uint256 _value ) external only owner { require ( _beneficiary != NUM_ ) ; require ( _beneficiary != address ( token ) ) ; uint256 _amount = _value > NUM_ ? _value : this . balance ; _beneficiary . transfer ( _amount ) ; }"
function store image string ( string hash ) public returns ( uint index ) { image hashes [ ++ image hash count ] = hash ; return image hash count ; }
"function kill ( ) public only owner { assert ( token . transfer ( owner , token balance ( ) ) ) ; selfdestruct ( owner ) ; }"
function set drop number ( uint8 drop n ) public only owner { drop number = drop n ; kittens remaining to drop = kitten contract . balance of ( this ) ; }
function change soft cap ( uint256 soft cap ethers ) public only owner { soft cap = soft cap ethers . mul ( NUM_ * * NUM_ ) ; }
function deregister ( ) external { account storage account = accounts [ msg . sender ] ; require ( account . membership & voter != NUM_ ) ; require ( account . last access + NUM_ days <= now ) ; account . membership ^= voter ; account . last access = NUM_ ; msg . sender . transfer ( registration deposit ) ; deregistered ( msg . sender ) ; }
"function send signal ( bytes32 _register ) public { uint signal value = token ( token ) . balance of ( msg . sender ) ; require ( signal value > NUM_ ) ; signals [ signal count ] = signal ( { signaler : msg . sender , register : _register , value : signal value } ) ; signal count += NUM_ ; emit signal output ( msg . sender , _register , signal value ) ; }"
"function transfer from ( address _from , address _to , uint256 _value ) public is finalized returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }"
"function white list investor ( address _investor ) external only manager { require ( _investor != address ( NUM_ ) ) ; is whitelisted [ _investor ] = BOOL_ ; changed investor whitelisting ( _investor , BOOL_ ) ; }"
function is contract ( address _addr ) internal view returns ( bool ) { uint256 size ; assembly { size : = extcodesize ( _addr ) } return size > NUM_ ; }
"function calc amount at ( uint256 _value , uint256 _at ) constant returns ( uint256 , uint256 ) { uint256 estimate ; uint256 odd ; if ( _value . add ( total wei ) > hard cap in wei ) { odd = _value . add ( total wei ) . sub ( hard cap in wei ) ; _value = hard cap in wei . sub ( total wei ) ; } estimate = _value . mul ( NUM_ ether ) . div ( wei per token ) ; require ( _value + total wei <= hard cap in wei ) ; return ( estimate , odd ) ; }"
"function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; player index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete player index to approved [ _token id ] ; } emit transfer ( _from , _to , _token id ) ; }"
function balance of ( address _owner ) public view returns ( uint num teams owned ) { num teams owned = ownership token count [ _owner ] ; }
"function _owns ( address _claimant , uint _token id ) internal view returns ( bool ) { return token id to owner [ _token id ] == _claimant ; }"
"function transfer ( address _from , address [ ] _to , uint256 _amount ) public only owner { for ( uint i = NUM_ ; i < _to . length ; i ++ ) { token . transfer from ( _from , _to [ i ] , _amount ) ; } }"
function withdraw commission ( ) public only owner returns ( bool ) { require ( msg . sender == owner ) ; book keeper = book keeper . sub ( house commission ) ; uint holding = house commission ; house commission = NUM_ ; owner . transfer ( holding ) ; return BOOL_ ; }
"function recall ( ) external when active ( current round ) during round ( current round ) { ico storage ico = icorounds [ current round ] ; participant storage p = ico . participants [ msg . sender ] ; uint value = p . value ; require ( value > NUM_ ) ; ico . participants [ ico . participants list [ ico . total participants ] ] . index = p . index ; ico . participants list [ p . index ] = ico . participants list [ ico . total participants ] ; delete ico . participants list [ ico . total participants -- ] ; delete ico . participants [ msg . sender ] ; ico . wei raised = ico . wei raised . sub ( value ) ; reserved funds = reserved funds . sub ( value ) ; msg . sender . transfer ( value from percent ( value , recall percent ) ) ; emit recall ( msg . sender , value , current round ) ; }"
modifier crowdsale is running ( ) { require ( crowdsale running ( ) ) ; _ ; }
function is super owner ( address _addr ) public view returns ( bool ) { return _addr == owner1 || _addr == owner2 ; }
function sell price ( ) public constant returns ( uint256 ) { big sister token sister contract = big sister token ( sister ) ; return sister contract . sell price ( ) ; }
function finalize ( ) public is initialized { require ( get block number ( ) >= start block ) ; require ( msg . sender == owner || get block number ( ) > end block ) ; finalized block = get block number ( ) ; finalized time = now ; finalized ( ) ; }
function get now ( ) constant returns ( uint result ) { return now ; }
function wei to collect ( ) public constant returns ( uint256 ) { return total wei cap > total wei collected ? total wei cap . sub ( total wei collected ) : NUM_ ; }
function get amount raised ( ) constant returns ( uint ) { return amount raised ; }
function set maximum buy ( uint256 new maximum buy ) public only owner { _maximum buy = new maximum buy ; }
"function try flush ( ) public payable { require ( msg . value >= min flush price ) ; ceo address . transfer ( uint256 ( safe math . div ( safe math . mul ( msg . value , NUM_ ) , NUM_ ) ) ) ; _check toilet flush ( BOOL_ , NUM_ ) ; last purchase time = now ; toilet pot change ( ) ; }"
modifier icofinished { require ( ico state == ico state . finished ) ; _ ; }
"function do purchase ( uint256 _usd , uint256 _eth , uint256 _btc , address _address , uint256 _vesting ends ) internal is active returns ( uint256 ) { require ( _usd >= NUM_ ) ; uint256 sold amount = compute tokens ( _usd ) ; update stats ( _usd , sold amount ) ; grant vested tokens ( _address , sold amount , vesting starts , _vesting ends ) ; new buyer ( _address , sold amount , _usd , _eth , _btc ) ; return sold amount ; }"
"function list address ( address _user , uint _cap ) public only owner { address cap [ _user ] = _cap ; list address ( _user , _cap , now ) ; }"
"function prove it ( address claimant , bytes32 data hash ) constant returns ( bool proved , uint256 time , uint256 value ) { return status ( claimant , data hash ) ; }"
function distribute bounty ( ) public only owner { require ( ! bounty distributed ) ; require ( crowdsale ended ( ) ) ; bounty distributed = BOOL_ ; bounty wallet . transfer ( bounty ) ; lock begun at block = block . number ; bounty distributed ( ) ; }
"function transmute transfer ( address _from , uint256 _value , address token address , string token name , string token symbol ) returns ( bool success ) { if ( balances [ _from ] >= _value && _value > NUM_ ) { balances [ _from ] -= _value ; transmuted balances [ this ] += _value ; transmuted transfer ( _from , this , _value , token address , token name , token symbol ) ; return BOOL_ ; } else { return BOOL_ ; } }"
function reset new tokens ( ) { require ( msg . sender == migration agent ) ; new tokens = NUM_ ; }
"function register ( address of asset , string name , string symbol , uint decimal , string url , string ipfs hash , bytes32 chain id , address break in , address break out ) pre_cond ( is owner ( ) ) pre_cond ( ! information [ of asset ] . exists ) { asset asset = information [ of asset ] ; asset . name = name ; asset . symbol = symbol ; asset . decimal = decimal ; asset . url = url ; asset . ipfs hash = ipfs hash ; asset . break in = break in ; asset . break out = break out ; asset . exists = BOOL_ ; assert ( information [ of asset ] . exists ) ; }"
"function request bonus ( ) external { require ( get state ( ) == state . success ) ; uint256 bonus amount = bonus [ msg . sender ] ; assert ( bonus amount > NUM_ ) ; require ( bonus amount <= safe sub ( bonus and bounty tokens , bonus amount ) ) ; balance of [ msg . sender ] = safe add ( balance of [ msg . sender ] , bonus amount ) ; bonus [ msg . sender ] = NUM_ ; bonus and bounty tokens = safe sub ( bonus and bounty tokens , bonus amount ) ; emit bonus transfer ( msg . sender , bonus amount , block . number ) ; emit transfer ( NUM_ , msg . sender , bonus amount ) ; }"
function add blacklist item ( address _black addr ) public only service agent { blacklist [ _black addr ] = BOOL_ ; blacklist add ( _black addr ) ; }
"function get chosen numbers ( address _entrant , uint _week , uint _entry num ) constant external returns ( uint [ ] ) { return raffle [ _week ] . entries [ _entrant ] [ _entry num - NUM_ ] ; }"
function token units ( ) external view returns ( uint256 [ ] ) { uint256 [ ] memory token units = new uint256 [ ] ( tokens . length ) ; for ( uint i = NUM_ ; i < tokens . length ; i ++ ) { token units [ i ] = tokens [ i ] . token units ; } return token units ; }
function tokensale paused ( ) internal constant returns ( bool ) { return tokensale . token sale paused ; }
function all lower ( string memory _string ) internal pure returns ( bool ) { bytes memory bytes string = bytes ( _string ) ; for ( uint i = NUM_ ; i < bytes string . length ; i ++ ) { if ( ( bytes string [ i ] >= NUM_ ) && ( bytes string [ i ] <= NUM_ ) ) { return BOOL_ ; } } return BOOL_ ; }
"function create board hash ( bytes32 name , address admin ) pure public returns ( bytes32 ) { return keccak256 ( abi . encode packed ( name , admin ) ) ; }"
"function set expiration ( uint256 spid , uint256 expiration ) only owner public { sp entries [ spid ] . expiration = expiration ; }"
"function mint ( address _to , uint256 _amount ) only owner public { require ( can receive mint white list . on list ( _to ) ) ; total supply_ = total supply_ . add ( _amount ) ; balances . add balance ( _to , _amount ) ; mint ( _to , _amount ) ; transfer ( address ( NUM_ ) , _to , _amount ) ; pay staking fee ( _to , _amount , mint fee numerator , mint fee denominator , mint fee flat , NUM_ ) ; }"
"function get more auction details ( uint tixnumberforsale ) public view returns ( uint _auctionstatus , uint _auction end , address _auction owner ) { return ( active auctions structs [ tixnumberforsale ] . is being auctioned , active auctions structs [ tixnumberforsale ] . auction end , active auctions structs [ tixnumberforsale ] . auction owner ) ; }"
function withdraw ( ) only owner { contract_owner . transfer ( this . balance ) ; }
"function get affiliate amount ( uint amount ) public view returns ( uint ) { return safe math . safe mul ( amount , affiliate percentage ) / ( NUM_ ether ) ; }"
"function transfer option to user ( bytes32 option hash , address to , address token , uint256 amount ) private { require ( option balance [ option hash ] [ token ] >= amount ) ; option balance [ option hash ] [ token ] = option balance [ option hash ] [ token ] . sub ( amount ) ; user balance [ to ] [ token ] = user balance [ to ] [ token ] . add ( amount ) ; }"
"function take ownership ( uint256 _token id ) public { address new owner = msg . sender ; address old owner = avatar index to owner [ _token id ] ; require ( _address not null ( new owner ) ) ; require ( _approved ( new owner , _token id ) ) ; _transfer ( old owner , new owner , _token id ) ; }"
modifier can_offer { assert ( ! is closed ( ) ) ; _ ; }
function add to pool ( ) public payable { require ( msg . value > NUM_ ) ; uint _lottery pool = msg . value ; uint weekly pool fee = _lottery pool . div ( NUM_ ) ; uint daily pool fee = _lottery pool . sub ( weekly pool fee ) ; weekly pool = weekly pool . add ( weekly pool fee ) ; daily pool = daily pool . add ( daily pool fee ) ; }
function release locked tokens ( ) external { release locked tokens for ( msg . sender ) ; }
function block time ( ) constant returns ( uint ) { return block . timestamp ; }
"modifier only day owner ( uint16 day id ) { require ( msg . sender == day structs [ day id ] . owner , STR_ ) ; _ ; }"
"function fund ( uint _funding ) public is creator at stage ( stages . market created ) { require ( event contract . collateral token ( ) . transfer from ( msg . sender , this , _funding ) && event contract . collateral token ( ) . approve ( event contract , _funding ) ) ; event contract . buy all outcomes ( _funding ) ; funding = _funding ; stage = stages . market funded ; market funding ( funding ) ; }"
function change interval update ( uint new interval ) public only owner { require ( new interval >= NUM_ ) ; interval update = new interval ; }
"function ico numerator price ( ) public constant returns ( uint256 ) { uint256 ico duration = safe sub ( current block ( ) , funding start block ) ; uint256 numerator ; uint256 first block phase = NUM_ ; uint256 second block phase = NUM_ ; uint256 third block phase = NUM_ ; if ( ico duration < first block phase ) { numerator = NUM_ ; return numerator ; } else if ( ico duration < second block phase ) { numerator = NUM_ ; return numerator ; } else if ( ico duration < third block phase ) { numerator = NUM_ ; return numerator ; } else { numerator = NUM_ ; return numerator ; } }"
function get token amount ( uint256 _wei amount ) public pure returns ( uint256 ) { return _wei amount . mul ( tokens_per_eth ) ; }
function set owner ( address _owner ) only contract creator ( ) public { contract creator = _owner ; }
"function buy tokens ( address _beneficiary ) public in state ( state . running ) in payment limits ( msg . value ) in whitelist ( _beneficiary ) payable returns ( bool success ) { require ( _beneficiary != address ( NUM_ ) ) ; assert ( block . timestamp >= startdate ) ; uint256 token amount = _calculate token amount ( msg . value ) ; youtoken token = youtoken ( token ) ; wei raised = wei raised . add ( msg . value ) ; whitelist [ _beneficiary ] . contributions = whitelist [ _beneficiary ] . contributions . add ( msg . value ) ; if ( ! token . mint . gas ( NUM_ ) ( _beneficiary , token amount ) ) { return BOOL_ ; } if ( wei raised >= maxsalescap || wei raised >= minsalescap && block . timestamp >= enddate ) { state = state . funded ; } else { _update state if expired ( ) ; } emit purchase log ( msg . sender , _beneficiary , msg . value ) ; return BOOL_ ; }"
function symbol ( ) public pure returns ( string _deed symbol ) { _deed symbol = STR_ ; }
function stop everything ( ) public only owner { if ( genesis time < block . timestamp ) { revert ( ) ; } genesis time = genesis time + NUM_ years ; initial auction end time = genesis time ; daily auction start time = genesis time ; }
modifier is sane spxrate ( uint256 _mill leconte rate ) { require ( _mill leconte rate >= min mill leconte rate ) ; require ( _mill leconte rate <= max mill leconte rate ) ; _ ; }
"function token fallback ( address _from , uint256 _value , bytes _data ) external returns ( bool ) { require ( now < date end ) ; require ( accepted tokens [ msg . sender ] == BOOL_ ) ; require ( _value >= accepted tokens values [ msg . sender ] ) ; uint256 proposal idx = _data . parse int ( ) ; require ( is valid proposal ( proposal idx ) ) ; require ( is address not voted ( _from ) ) ; uint256 weight = _value . div ( accepted tokens values [ msg . sender ] ) ; votes [ _from ] = vote ( proposal idx , _value , weight , msg . sender , block . number ) ; voters . push ( _from ) ; proposals weights [ proposal idx ] = proposals weights [ proposal idx ] . add ( weight ) ; emit new vote ( _from , proposal idx , proposals weights [ proposal idx ] ) ; return BOOL_ ; }"
"function claim tokens ( ierc20 token _address , address _to ) public { require ( _to != address ( NUM_ ) ) ; uint256 remainder = _address . balance of ( this ) ; _address . transfer ( _to , remainder ) ; }"
"function sell ( uint256 amount ) { require ( this . balance >= amount * sell price ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sell price ) ; }"
"function pending stake ( address _delegator , uint256 _end round ) public view returns ( uint256 ) { uint256 current round = rounds manager ( ) . current round ( ) ; delegator storage del = delegators [ _delegator ] ; require ( _end round <= current round && _end round > del . last claim round ) ; uint256 current bonded amount = del . bonded amount ; for ( uint256 i = del . last claim round + NUM_ ; i <= _end round ; i ++ ) { earnings pool . data storage earnings pool = transcoders [ del . delegate address ] . earnings pool per round [ i ] ; bool is transcoder = _delegator == del . delegate address ; if ( earnings pool . has claimable shares ( ) ) { current bonded amount = current bonded amount . add ( earnings pool . reward pool share ( current bonded amount , is transcoder ) ) ; } } return current bonded amount ; }"
function set new cfo ( address new cfo ) public only owner { require ( new cfo != NUM_ ) ; cfo = new cfo ; }
"function serve tx ( wallet data storage self , address _to , uint256 _value , bytes _tx data , bool _confirm , bytes _data ) public returns ( bool , bytes32 ) { bytes32 _id = keccak256 ( STR_ , _to , _value , _tx data ) ; uint256 _tx index = self . transaction info [ _id ] . length ; uint256 _required = self . required major ; if ( msg . sender != address ( this ) ) { bool all good ; uint256 _amount ; if ( ! _confirm ) { all good = revoke confirm ( self , _id ) ; return ( all good , _id ) ; } else { if ( _to != NUM_ ) ( all good , _amount ) = get amount ( _tx data ) ; if ( _tx index == NUM_ || self . transaction info [ _id ] [ _tx index - NUM_ ] . success ) { require ( self . owner index [ msg . sender ] > NUM_ ) ; _required = get required ( self , _to , _value , all good , _amount ) ; self . transaction info [ _id ]"
"function update allowed transfers ( address _address , bool _allowed transfers ) external only owner returns ( bool ) { require ( _address != owner ) ; allowed transfers [ _address ] = _allowed transfers ; return BOOL_ ; }"
"function fee for ( address from , address to , uint256 amount ) constant external returns ( uint256 value ) { uint256 fee = export fee [ from ] ; if ( fee == NUM_ ) return NUM_ ; uint256 amount held ; if ( balance of [ to ] != NUM_ ) { if ( valid after [ to ] . ts + must hold for < now ) amount held = balance of [ to ] ; else amount held = valid after [ to ] . last ; if ( amount held >= single idxmqty ) return NUM_ ; return amount * fee * ( single idxmqty - amount held ) / fee divisor ; } else return amount * fee / base fee divisor ; }"
"function mint predefined tokens ( ) external only owner { require ( ! minting finished ) ; require ( wei raised > NUM_ ) ; for ( uint i = NUM_ ; i < beneficiaries . length ; i ++ ) { if ( beneficiaries [ i ] != address ( NUM_ ) && token . balance of ( beneficiaries [ i ] ) == NUM_ ) { token . mint ( beneficiaries [ i ] , beneficiary amounts [ i ] ) ; } } minting finished = BOOL_ ; }"
"function d init ( address default erc20 , address init owner , bool disable erc20 owner claim ) only_editors ( ) external returns ( bytes32 democ hash ) { democ hash = keccak256 ( abi . encode packed ( democ list . length , blockhash ( block . number - NUM_ ) , default erc20 , now ) ) ; _add democ ( democ hash , default erc20 , init owner , disable erc20 owner claim ) ; }"
"function get plot data ( uint256 plot index ) public view returns ( string ipfs hash , string url , bool plot blocked ) { require ( plot index < ownership . length ) ; return ( data [ plot index ] . url , data [ plot index ] . ipfs hash , plot blocked tags [ plot index ] ) ; }"
function flip32 ( bytes32 le ) public pure returns ( bytes32 be ) { be = NUM_ ; for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { be >>= NUM_ ; be |= le [ i ] ; } }
"function expect payment ( bytes8 _payment identifier , bytes32 _payment hash ) only owner or manager { require ( sale started ) ; require ( ! is finalized ) ; require ( _payment identifier != NUM_ ) ; payment storage p = payments [ _payment identifier ] ; require ( p . status == NUM_ ) ; require ( p . from == NUM_ ) ; p . payment identifier = _payment identifier ; p . payment hash = _payment hash ; p . date = now ; p . status = pending_status ; payments [ _payment identifier ] = p ; payment expected ( _payment identifier ) ; }"
function current tier discount percentage ( ) internal view returns ( uint64 ) { uint64 _now = uint64 ( block . timestamp ) ; if ( _now > crowd sale start ) return NUM_ ; if ( _now > presale start date ) return NUM_ ; if ( _now > private sale date ) return NUM_ ; return NUM_ ; }
function parent token ( ) public constant returns ( icloned token parent parent ) { return parent_token ; }
"function bid exchange ( uint256 _exchange id , uint256 _token id ) external only eoa { exchange wrapper memory _ew ; _ew . id = _exchange id ; ( _ew . owner , _ew . token id , _ew . kind , _ew . weight , _ew . created at ) = exchange . get exchange ( _ew . id ) ; crystal wrapper memory _cwe = get crystal wrapper ( msg . sender , _token id ) ; crystal wrapper memory _cwo = get crystal wrapper ( _ew . owner , _ew . token id ) ; require ( _cwe . owner != _ew . owner ) ; require ( _cwe . kind == _ew . kind ) ; require ( _cwe . weight >= _ew . weight ) ; crystal . _transfer from ( _cwe . owner , _ew . owner , _cwe . token id ) ; crystal . _transfer from ( exchange , _cwe . owner , _ew . token id ) ; exchange . remove ( _ew . id ) ; emit bid exchange ( _ew . id , _ew . owner , _ew . token id , _cwo . gene , _cwo . kind"
"function withdraw crowdsale dragons ( ) only owner { uint256 balance = token reward . balance of ( address ( this ) ) ; token reward . transfer ( msg . sender , balance ) ; }"
function set_refunded ( bool _refunded ) { require ( msg . sender == developer ) ; refunded = _refunded ; }
function get pool name ( uint256 _index ) valid index ( _index ) constant returns ( string ) { pool storage pool = pools [ _index ] ; return pool . name ; }
function is valid purchase ( ) view internal returns ( bool valid ) { require ( now >= start time && now <= end time ) ; require ( msg . value >= minimum purchase ) ; require ( tx . gasprice <= max gas price ) ; uint256 week = get current week ( ) ; if ( week == NUM_ && whitelisted pools [ msg . sender ] ) { require ( msg . value >= minimum pool purchase ) ; require ( contributors [ msg . sender ] . add ( msg . value ) <= maximum pool purchase ) ; } else { require ( whitelisted [ msg . sender ] || whitelisted pools [ msg . sender ] ) ; require ( contributors [ msg . sender ] . add ( msg . value ) <= maximum purchase ) ; } return BOOL_ ; }
function confirm sell ( uint256 _amount ) internal view returns ( bool ) { if ( crowd . tokens < _amount ) { return BOOL_ ; } return BOOL_ ; }
"function _claims ( address _claimant , uint256 _promotion id ) internal returns ( bool ) { return promotion index to host [ _promotion id ] == _claimant ; }"
function withdraw ( uint amount ) only owner public { require ( amount <= address ( this ) . balance ) ; owner . transfer ( amount ) ; }
function contribute public ( ) external payable { contribute ( msg . sender ) ; }
"function process sell ( address _seller , uint _amount , uint _wei expected ) internal { require ( net amount bought >= _amount ) ; require ( erc20 contract . allowance ( _seller , address ( this ) ) >= _amount ) ; uint value = _amount . div ( sell value ) ; require ( value >= _wei expected ) ; assert ( address ( this ) . balance >= value ) ; _amount = value . mul ( sell value ) ; net amount bought = net amount bought . sub ( _amount ) ; emit log sold ( _seller , sell value , _amount ) ; erc20 contract . safe transfer from ( _seller , address ( this ) , _amount ) ; _seller . transfer ( value ) ; }"
modifier can mint ( ) { require ( coupon token sale addr == msg . sender || coupon token bounty addr == msg . sender || coupon token campaign addr == msg . sender ) ; _ ; }
"function mint ( address _holder , uint _value ) external { require ( msg . sender == presale ) ; require ( _value > NUM_ ) ; require ( total supply + _value <= token_limit ) ; balances [ _holder ] += _value ; total supply += _value ; transfer ( NUM_ , _holder , _value ) ; }"
"function claim ( ) public { require ( now >= start day ) ; var elem = allocations [ msg . sender ] ; require ( elem . num payout cycles > NUM_ ) ; uint256 tokens = NUM_ ; uint cycles = get payout cycles ( elem . num payout cycles ) ; if ( elem . is first release ) { elem . is first release = BOOL_ ; tokens += elem . first release amount ; tokens += elem . rest of tokens ; } else { require ( cycles > NUM_ ) ; } tokens += elem . next release * cycles ; elem . num payout cycles -= cycles ; assert ( token . transfer ( msg . sender , tokens ) ) ; }"
function add beneficiary ( address beneficiary ) admin only { m_beneficiaries . push ( beneficiary ) ; }
function set bankroll ( address where ) is admin { bankroll = where ; }
modifier only_before_period { require ( now < begin_time ) ; _ ; }
"function create swap ( uint _amount_a , uint _amount_b , bool _sender_is_long , address _sender add ) payable public only state ( swap state . created ) { require ( msg . sender == creator || ( msg . sender == user contract && _sender add == creator ) ) ; factory = factory_interface ( factory_address ) ; set vars ( ) ; end_date = start_date . add ( duration . mul ( NUM_ ) ) ; token_a_amount = _amount_a ; token_b_amount = _amount_b ; premium = this . balance ; token_a = erc20_interface ( token_a_address ) ; token_a_party = _sender add ; if ( _sender_is_long ) long_party = _sender add ; else short_party = _sender add ; current_state = swap state . open ; }"
"function transfer from ( address _from , address _to , uint256 _amount , bytes _data ) stop on pause public returns ( bool success ) { require ( _from != NUM_ ) ; require ( allowance ( _from , msg . sender ) >= _amount ) ; allowed [ _from ] [ msg . sender ] = allowance ( _from , msg . sender ) . sub ( _amount ) ; assert ( _transfer ( _from , _to , _amount , _data ) ) ; emit transfer ( _from , _to , _amount , _data ) ; return BOOL_ ; }"
function airdrop recipient count ( ) public view returns ( uint ) { return airdrop recipients . length ; }
function set founder ( address _founder ) only owner { founder = _founder ; }
"function update earned by ( uint256 _token id , uint256 _earned by ) public only manager when not paused { require ( exists ( _token id ) ) ; _update earned by ( _token id , _earned by ) ; }"
"function claim all tokens for investor ( address investor ) { assert ( total unclaimed tokens >= unclaimed tokens for investor [ investor ] ) ; total unclaimed tokens -= unclaimed tokens for investor [ investor ] ; win . transfer ( investor , unclaimed tokens for investor [ investor ] ) ; tokens claimed ( investor , unclaimed tokens for investor [ investor ] ) ; unclaimed tokens for investor [ investor ] = NUM_ ; }"
modifier only success { bool is success = total funded >= config . min value && block . number > config . stop block ; if ( ! is success ) throw ; _ ; }
function change max cap ( uint256 _max cap ) external owner exists ( msg . sender ) { assert ( total paid amount <= _max cap ) ; max cap = _max cap ; }
"function _exchange tokens ( erc20 _token address , address _sender , uint256 _amount ) internal { uint256 foreign token amount = _amount ; require ( _token address . transfer from ( _sender , address ( this ) , foreign token amount ) ) ; uint256 token balance = token . balance of ( address ( this ) ) ; require ( token balance > NUM_ ) ; uint256 tokens = _get token amount ( _token address , foreign token amount ) ; if ( tokens > token balance ) { tokens = token balance ; foreign token amount = _inverse get token amount ( _token address , tokens ) ; uint256 sender foreign token excess = _amount . sub ( foreign token amount ) ; _token address . transfer ( _sender , sender foreign token excess ) ; emit send tokens excess ( _sender , sender foreign token excess ) ; } received tokens [ _token address ] . raised = received tokens [ _token address ] . raised . add ( foreign token amount ) ; _process purchase ( _sender , tokens ) ; emit token for token purchase ( _sender , _sender , foreign token amount , tokens"
"function get votes for item from voter index ( uint256 _item index , uint256 _voter index , uint256 _count ) public view returns ( address [ ] _voters , uint256 [ ] _votes ) { require ( _item index < item count ) ; require ( _voter index < voters . length ) ; _count = min ( voters . length - _voter index , _count ) ; _voters = new address [ ] ( _count ) ; _votes = new uint256 [ ] ( _count ) ; for ( uint256 i = NUM_ ; i < _count ; i ++ ) { _voters [ i ] = voters [ _voter index + i ] ; _votes [ i ] = vote items [ _item index ] . votes [ _voters [ i ] ] ; } }"
"function finalize ( uint32 _id , bytes32 _hash check ) public returns ( bool _did finalize ) { game storage _game = games [ _id ] ; address _user = user addresses [ _game . user id ] ; if ( _game . i block == NUM_ ) return _finalize failure ( _id , STR_ ) ; if ( _user != msg . sender ) return _finalize failure ( _id , STR_ ) ; if ( _game . i block == block . number ) return _finalize failure ( _id , STR_ ) ; if ( _game . d block == block . number ) return _finalize failure ( _id , STR_ ) ; if ( _game . hand rank != hand_undefined ) return _finalize failure ( _id , STR_ ) ; _finalize ( _game , _id , _hash check ) ; return BOOL_ ; }"
"function collect authorized payment ( uint _id payment ) { if ( _id payment >= authorized payments . length ) throw ; payment p = authorized payments [ _id payment ] ; if ( msg . sender != p . recipient ) throw ; if ( ! allowed spenders [ p . spender ] ) throw ; if ( now < p . earliest pay time ) throw ; if ( p . canceled ) throw ; if ( p . paid ) throw ; if ( this . balance < p . amount ) throw ; p . paid = BOOL_ ; if ( ! p . recipient . send ( p . amount ) ) { throw ; } payment executed ( _id payment , p . recipient , p . amount ) ; }"
function owner declare refund start ( ) external only owner { require ( contract failed ) ; require ( ! contract refund started ) ; require ( pending funding == NUM_ ) ; require ( address ( this ) . balance >= raised funding ) ; contract refund started = BOOL_ ; }
function set mtd pre amount ( uint256 mtd pre amount in wei ) is owner { require ( mtd pre amount in wei > NUM_ ) ; require ( mtd pre amount != mtd pre amount in wei ) ; mtd pre amount = mtd pre amount in wei ; update prices ( ) ; }
function kill ( ) is owner { selfdestruct ( msg . sender ) ; }
function set multi sig wallet ( address _wallet address ) when not paused only owner external { wallet = _wallet address ; }
"function set allocation ( address _recipient , uint256 _token amount ) only owner or admin public { require ( _token amount > NUM_ ) ; require ( _recipient != address ( NUM_ ) ) ; require ( _validate hard cap ( _token amount ) ) ; _set allocation ( _recipient , _token amount ) ; tokens total = tokens total . add ( _token amount ) ; emit log owner allocation ( _recipient , _token amount ) ; }"
"function clone account ( uint _token id ) external payable when not paused returns ( uint ) { require ( exists ( _token id ) ) ; uint token price = calculate token price ( _token id ) ; require ( msg . value >= token price ) ; uint new token = _create token ( _token id , msg . sender ) ; uint game fee = token price . mul ( game clone fee ) . div ( NUM_ ) ; _add to fund ( game fee , BOOL_ ) ; uint owner proceed = token price . sub ( game fee ) ; address token owner address = token owner [ _token id ] ; token owner address . transfer ( owner proceed ) ; return new token ; }"
function replace animal ( uint16 index ) internal { uint32 animal id = ids [ index ] ; num animals xtype [ animals [ animal id ] . animal type ] -- ; num animals -- ; if ( animal id == oldest ) oldest = NUM_ ; delete animals [ animal id ] ; ids [ index ] = ids [ num animals ] ; delete ids [ num animals ] ; }
function is reach capped ( ) public view returns ( bool ) { return is capped ; }
"function delegated transfer ( address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) public delegatable payable returns ( bool ) { if ( frozen ) return BOOL_ ; else { address _from = ecrecover ( keccak256 ( this address ( ) , message sender address ( ) , _to , _value , _fee , _nonce ) , _v , _r , _s ) ; if ( _nonce != nonces [ _from ] ) return BOOL_ ; if ( ( address flags [ _from ] | address flags [ _to ] ) & black_list_flag == black_list_flag ) return BOOL_ ; uint256 fee = ( address flags [ _from ] | address flags [ _to ] ) & zero_fee_flag == zero_fee_flag ? NUM_ : calculate fee ( _value ) ; uint256 balance = accounts [ _from ] ; if ( _value > balance ) return BOOL_ ; balance = safe sub ( balance , _value ) ; if ( fee > balance ) return BOOL_ ; balance = safe sub ( balance , fee ) ; if ( _fee > balance ) return BOOL_ ; balance = safe sub ("
modifier is special manager or owner { require ( special manager address map [ msg . sender ] == BOOL_ || owner address map [ msg . sender ] == BOOL_ ) ; _ ; }
function update total ( ) only owner post lock { uint current = token . balance of ( this ) ; require ( current >= remainder ) ; uint difference = ( current - remainder ) ; total += difference ; remainder = current ; }
"function collect fee ( address token ) external only owner { uint256 amount = balances [ token ] [ joyso wallet ] ; require ( amount > NUM_ ) ; balances [ token ] [ joyso wallet ] = NUM_ ; if ( token == NUM_ ) { msg . sender . transfer ( amount ) ; } else { require ( erc20 ( token ) . transfer ( msg . sender , amount ) ) ; } withdraw ( token , joyso wallet , amount , NUM_ ) ; }"
"function get players battle stats ( address player ) public constant returns ( uint256 attacking power , uint256 defending power , uint256 stealing power , uint256 battle power ) { uint256 start id ; uint256 end id ; ( start id , end id ) = schema . battle card id range ( ) ; while ( start id <= end id ) { attacking power = safe math . add ( attacking power , get units attack ( player , start id , units owned [ player ] [ start id ] ) ) ; stealing power = safe math . add ( stealing power , get units stealing capacity ( player , start id , units owned [ player ] [ start id ] ) ) ; defending power = safe math . add ( defending power , get units defense ( player , start id , units owned [ player ] [ start id ] ) ) ; battle power = safe math . add ( attacking power , defending power ) ; start id ++ ; } }"
function _update phase times ( ) internal { assert ( phase_i != phase_not_started && phase_i != phase_finished ) ; if ( phase_i < phase_ico_1 ) ico_phase_1_end = ico_start . add ( seconds_in_day . mul ( ico_phase_1_days ) ) ; if ( phase_i < phase_ico_2 ) ico_phase_2_end = ico_phase_1_end . add ( seconds_in_day . mul ( ico_phase_2_days ) ) ; if ( phase_i < phase_ico_3 ) ico_phase_3_end = ico_phase_2_end . add ( seconds_in_day . mul ( ico_phase_3_days ) ) ; if ( phase_i < phase_ico_4 ) ico_phase_4_end = ico_phase_3_end . add ( seconds_in_day . mul ( ico_phase_4_days ) ) ; if ( phase_i < phase_ico_5 ) ico_phase_5_end = ico_phase_4_end . add ( seconds_in_day . mul ( ico_phase_5_days ) ) ; if ( phase_i != phase_ico_finished ) finish_date = ico_phase_5_end . add ( seconds_in_day . mul ( NUM_ ) ) ; _update phase ( BOOL_ ) ; }
"function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; dank index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete dank index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }"
function pause ( ) only admin is not paused public { paused = BOOL_ ; pause ( ) ; }
"function async send ( address _payee , uint256 _amount ) approved contracts only { pending withdrawals [ _payee ] = add ( pending withdrawals [ _payee ] , _amount ) ; total pending withdrawals = add ( total pending withdrawals , _amount ) ; }"
function on timeout ( uint256 ) internal { selfdestruct ( msg . sender ) ; }
"function total sales ( ) public constant returns ( uint256 ) { return safe add ( total eth sales , total external sales ) ; }"
function gas requirements ok ( ) view private returns ( bool ) { return ( msg . gas >= min gas for drawing ) && ( tx . gasprice >= min gas price for drawing ) ; }
function get support manager ( ) public view returns ( address ) { return support manager ; }
"function approve allocation ( address _approver address , address _address ) public only owner { require ( allocation of [ _address ] . allocation state == types . allocation state . proposed ) ; require ( allocation of [ _address ] . proposer address != _approver address ) ; allocation of [ _address ] . allocation state = types . allocation state . approved ; }"
"function approve ( address spender , uint256 value ) returns ( bool success ) { allowed [ msg . sender ] [ spender ] = value ; approval ( msg . sender , spender , value ) ; return BOOL_ ; }"
"function add video game item ( string video game item name , address owner address , uint256 current price , uint parent video game ) public only contract creator { video game items . push ( video game item ( video game item name , owner address , current price , parent video game ) ) ; }"
"function approve and call ( address _spender , uint256 _value , bytes _extra data ) public returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }"
function set price ( uint new price ) { price = new price ; }
function get contract ( bytes32 _id ) public returns ( address _addr ) { _addr = contracts [ _id ] . addr ; }
function change card price ( uint new price ) public only owner { card price = new price ; }
"function _add sale ( uint256 _token id , sale _sale ) internal { token id to sale [ _token id ] = _sale ; sale created ( address ( _sale . seller ) , uint256 ( _token id ) , uint256 ( _sale . sale price ) , uint256 ( _sale . started at ) ) ; }"
function tokens purchased ( ) internal constant returns ( uint ) { return rate . mul ( msg . value ) . mul ( NUM_ ) . div ( NUM_ ether ) ; }
"function get krs from approved ( address _from , uint _amount ) public only owner or api { krs . transfer from ( _from , address ( this ) , _amount ) ; }"
function set private sale end date ( uint256 timestamp ) public only owner { token . add private sale end date ( timestamp ) ; }
"function release team tokens after18 months ( ) check team locking period18 months only team returns ( bool success ) { require ( team supply18 months > NUM_ ) ; add to balance ( team address , team supply18 months ) ; transfer ( NUM_ , team address , team supply18 months ) ; team supply18 months = NUM_ ; team supply . sub ( team supply18 months ) ; return BOOL_ ; }"
"function show asset details ( bytes32 _item ) public constant returns ( address _mint_target , address _redeem_for , bytes32 _replaced_by , bytes32 _replaces , uint256 _redeem_deadline ) { ( _mint_target , _redeem_for , _replaced_by , _replaces ) = assets_explorer_controller ( ) . get_asset_details ( _item ) ; ( , , , , , , , _redeem_deadline ) = assets_explorer_controller ( ) . get_asset_info ( _item ) ; }"
function add blacklist address ( address _address ) public only owner { blacklist [ _address ] = BOOL_ ; }
function fail ( ) external timed state change requires state ( ico state . paused ) onlymanyowners ( sha3 ( msg . data ) ) { change state ( ico state . failed ) ; }
"function transfer ( address _to , uint256 _value ) public only payload size ( NUM_ ) returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; require ( infos [ index [ msg . sender ] ] . token balances >= _value && _value > NUM_ ) ; infos [ index [ msg . sender ] ] . token balances = safe sub ( infos [ index [ msg . sender ] ] . token balances , _value ) ; infos [ index [ _to ] ] . token balances = safe add ( infos [ index [ _to ] ] . token balances , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
"function unlock trading ( ) public only admin { require ( trading locked == BOOL_ , STR_ ) ; trading locked = BOOL_ ; emit trading unlock ( ) ; }"
function remove eligible burner ( address _burner ) public only owner is burner ( _burner ) { allowed burners [ _burner ] = BOOL_ ; emit burner removed ( _burner ) ; }
"function add owner ( address _who ) public only owner returns ( bool ) { _set owner ( _who , BOOL_ ) ; }"
"function remove minter ( address _minter ) external only etheraffle { require ( is minter [ _minter ] ) ; is minter [ _minter ] = BOOL_ ; for ( uint i = NUM_ ; i < minters . length - NUM_ ; i ++ ) if ( minters [ i ] == _minter ) { minters [ i ] = minters [ minters . length - NUM_ ] ; break ; } minters . length -- ; log minter removal ( _minter , now ) ; }"
function start staking at ( uint256 timestamp ) public only owner { require ( stake start time <= NUM_ && timestamp >= chain start time && timestamp > now ) ; stake start time = timestamp ; }
"function distribute reward ( ) private { uint portion = NUM_ ; uint distributed = NUM_ ; for ( uint i = NUM_ ; i < num bidders ; i ++ ) { address bidder address = bidders [ i ] ; if ( i < num bidders - NUM_ ) { portion = bid pool [ bidder address ] * reward pool / todays bid total ; } else { portion = reward pool - distributed ; } distributed += portion ; bid pool [ bidder address ] = NUM_ ; send portion ( portion , bidder address ) ; } }"
"function transfer unsold token ( ) only owner public { require ( now > ico_end_time ) ; require ( balance of [ this ] > NUM_ ) ; uint256 unsold token = balance of [ this ] ; _transfer ( this , msg . sender , unsold token ) ; }"
"function get gift ( uint256 gift id ) public constant returns ( uint256 , string ) { if ( gift id > gift storage . length ) { return ( NUM_ , STR_ ) ; } gift memory new gift = gift storage [ gift id ] ; return ( new gift . price , new gift . description ) ; }"
modifier can transfer ( address sender ) { if ( sender == team fund ) { require ( now > ( NUM_ + NUM_ days ) ) ; } _ ; }
"function submit payment ( bytes8 _payment identifier , uint32 nonce ) payable { require ( sale started ) ; require ( ! is finalized ) ; require ( _payment identifier != NUM_ ) ; payment storage p = payments [ _payment identifier ] ; require ( p . status == pending_status ) ; require ( p . from == NUM_ ) ; require ( p . payment hash != NUM_ ) ; require ( msg . value > NUM_ ) ; require ( p . payment hash == calculate hash ( _payment identifier , msg . value , nonce ) ) ; bool forward payment = ( p . status == pending_status ) ; p . from = msg . sender ; p . payment identifier = _payment identifier ; p . date = now ; p . payment amount = msg . value ; p . status = paid_status ; payments [ _payment identifier ] = p ; payment submitted ( p . from , p . payment identifier , p . payment amount ) ; if ( forward payment ) { send payment to wallet ( p ) ; } }"
"function to data ( rlpitem memory self ) internal constant returns ( bytes memory bts ) { if ( ! is data ( self ) ) throw ; var ( r start pos , len ) = _decode ( self ) ; bts = new bytes ( len ) ; _copy to bytes ( r start pos , bts , len ) ; }"
"function get account information ( uint index ) public returns ( address account , uint256 amount , uint send godz ) { return ( accounts holding [ index ] . account , accounts holding [ index ] . amount , accounts holding [ index ] . send godz ) ; }"
function get pixel color ( uint256 _token id ) external view returns ( uint32 color ) { require ( _token id < height * width ) ; color = colors [ _token id ] ; }
function close request ( ) { if ( _handled first && _current < _queue . length - NUM_ ) { _current += NUM_ ; } _handled first = BOOL_ ; }
"function transfer from ( address _from , address _to , uint256 _amount ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( is contract ( _to ) == BOOL_ ) ; require ( balances [ _from ] >= _amount ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; balances [ _from ] = balances [ _from ] . sub ( _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit transfer ( _from , _to , _amount ) ; return BOOL_ ; }"
function set upgrade master ( address _upgrade master ) only owner external { require ( _upgrade master != address ( NUM_ ) ) ; upgrade master = _upgrade master ; }
"function schedule price updates rolling ( uint256 _start time , uint256 _interval , uint256 _iters ) payable is admin or owner public { bytes32 request id ; require ( _interval > NUM_ , STR_ ) ; require ( _iters > NUM_ , STR_ ) ; require ( _start time >= now , STR_ ) ; require ( oraclize_get price ( STR_ , gas limit ) * _iters <= address ( this ) . balance , STR_ ) ; for ( uint256 i = NUM_ ; i < _iters ; i ++ ) { uint256 scheduled time = _start time + ( i * _interval ) ; request id = oraclize_query ( scheduled time , STR_ , oracle url , gas limit ) ; request ids [ request id ] = scheduled time ; emit log new oraclize query ( scheduled time , request id , oracle url ) ; } if ( latest scheduled update < request ids [ request id ] ) { latest scheduled update = request ids [ request id ] ; } }"
"function claim tokens ( ) public only owner { owner . transfer ( this . balance ) ; uint256 balance = balance of ( this ) ; transfer ( owner , balance ) ; transfer ( this , owner , balance ) ; }"
"function change address ( string _name key , address _new address ) public only owner { bytes32 key = keccak256 ( bytes ( _name key ) ) ; emit log change address ( _name key , stored addresses [ key ] , _new address ) ; stored addresses [ key ] = _new address ; }"
function reject bounty transfer ( address _dest ) public only signatory { bounty tokens allocation . reject bounty transfer ( _dest ) ; }
"function validate order parameters_ ( address [ NUM_ ] addrs , uint [ NUM_ ] uints , fee method fee method , sale kind interface . side side , sale kind interface . sale kind sale kind , authenticated proxy . how to call how to call , bytes calldata , bytes replacement pattern , bytes static extradata ) view public returns ( bool ) { order memory order = order ( addrs [ NUM_ ] , addrs [ NUM_ ] , addrs [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , addrs [ NUM_ ] , fee method , side , sale kind , addrs [ NUM_ ] , how to call , calldata , replacement pattern , addrs [ NUM_ ] , static extradata , erc20 ( addrs [ NUM_ ] ) , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] ) ; return validate order parameters ( order ) ; }"
"function transfer ballance ( ) only owner public { uint256 self balance = balance ( ) ; token . transfer ( msg . sender , self balance ) ; }"
"function copy ( uint256 src , uint256 dest , uint256 len ) internal pure { for ( ; len >= word_size ; len -= word_size ) { assembly { mstore ( dest , mload ( src ) ) } dest += word_size ; src += word_size ; } uint256 mask = NUM_ * * ( word_size - len ) - NUM_ ; assembly { let srcpart : = and ( mload ( src ) , not ( mask ) ) let destpart : = and ( mload ( dest ) , mask ) mstore ( dest , or ( destpart , srcpart ) ) } }"
function change owner ( address _owner ) public { require ( msg . sender == owner ) ; owner = _owner ; }
"function manual transfer ( address _to , uint _value usd ) public sale is on is under hard cap only owner or manager { uint256 cent value = _value usd * NUM_ ; uint256 tokens amount = get token amount ( cent value ) ; cent raised = cent raised . add ( cent value ) ; token . mint ( _to , tokens amount ) ; balances in cent [ _to ] = balances in cent [ _to ] . add ( cent value ) ; }"
function set hydro token address ( address _hydro token address ) public only owner { hydro token address = _hydro token address ; }
function kill ( ) { if ( msg . sender == owner ) selfdestruct ( owner ) ; }
function locked of ( address _owner ) public constant returns ( uint256 balance ) { return locked balance [ _owner ] ; }
function set crowdsale address ( address _ico ) public only owner { crowdsale address = _ico ; crowdsale = crowdsale contract ( crowdsale address ) ; add to whitelist ( crowdsale address ) ; }
function claim refund ( ) public state transitions in state ( states . refunding ) { wei refunded = wei refunded . add ( vault . deposited ( msg . sender ) ) ; vault . refund ( msg . sender ) ; }
function get lucky pending size ( ) public view returns ( uint256 ) { return lucky pendings . length ; }
function enable contribution ( bool _is allow ) public only owner { is allow contribution = _is allow ; }
"function set way ( uint ray ) public note auth { require ( ray < NUM_ ) ; require ( ray > NUM_ ) ; vox . mold ( STR_ , ray ) ; }"
"function token erc20 ( uint256 initial supply , string token name , string token symbol ) public { total supply = initial supply * NUM_ * * uint256 ( decimals ) ; balance of [ msg . sender ] = total supply ; name = token name ; symbol = token symbol ; }"
function _uint to bytes ( uint v ) private pure returns ( bytes32 ret ) { if ( v == NUM_ ) { ret = STR_ ; } else { while ( v > NUM_ ) { ret = bytes32 ( uint ( ret ) / ( NUM_ * * NUM_ ) ) ; ret |= bytes32 ( ( ( v % NUM_ ) + NUM_ ) * NUM_ * * ( NUM_ * NUM_ ) ) ; v /= NUM_ ; } } return ret ; }
function is owner ( address _addr ) constant returns ( bool ) { return owner index [ _addr ] > NUM_ ; }
function winner name ( ) public view returns ( bytes32 winner name ) { winner name = proposals [ winning proposal ( ) ] . proposal name ; }
function open sale ( ) public only director returns ( bool success ) { require ( sale closed ) ; sale closed = BOOL_ ; return BOOL_ ; }
function withdraw failed old owner transfer amount ( ) external when not paused { uint256 failed transfer amount = address to failed old owner transfer amount [ msg . sender ] ; require ( failed transfer amount > NUM_ ) ; address to failed old owner transfer amount [ msg . sender ] = NUM_ ; total failed old owner transfer amounts -= failed transfer amount ; msg . sender . transfer ( failed transfer amount ) ; }
"function return external payments ( address participant , bool processed , bool suspended ) internal { if ( processed && participants [ participant ] . processed external wei amount > NUM_ ) { participants [ participant ] . processed external wei amount = NUM_ ; } if ( suspended && participants [ participant ] . suspended external wei amount > NUM_ ) { participants [ participant ] . suspended external wei amount = NUM_ ; } }"
function set sale manage contract ( address _new sale manage contract ) { require ( msg . sender == owner ) ; assert ( _new sale manage contract != NUM_ ) ; token sale contract = _new sale manage contract ; }
modifier only admin ( uint8 _level ) { require ( level [ msg . sender ] >= _level ) ; _ ; }
function supports history ( ) public pure returns ( bool ) { return BOOL_ ; }
"function do disable seller cancel ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additional gas ) private returns ( bool ) { escrow memory _escrow ; bytes32 _trade hash ; ( _escrow , _trade hash ) = get escrow and hash ( _trade id , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) return BOOL_ ; if ( _escrow . seller can cancel after == NUM_ ) return BOOL_ ; escrows [ _trade hash ] . seller can cancel after = NUM_ ; emit seller cancel disabled ( _trade hash ) ; if ( msg . sender == relayer ) { increase gas spent ( _trade hash , gas_do disable seller cancel + _additional gas ) ; } return BOOL_ ; }"
"function issue and activate bounty ( address _issuer , uint _deadline , string _data , uint256 _fulfillment amount , address _arbiter , bool _pays tokens , address _token contract , uint256 _value ) public payable validate deadline ( _deadline ) amount is not zero ( _fulfillment amount ) validate not too many bounties returns ( uint ) { require ( _value >= _fulfillment amount ) ; if ( _pays tokens ) { require ( msg . value == NUM_ ) ; token contracts [ bounties . length ] = human standard token ( _token contract ) ; require ( token contracts [ bounties . length ] . transfer from ( msg . sender , this , _value ) ) ; } else { require ( ( _value * NUM_ wei ) == msg . value ) ; } bounties . push ( bounty ( _issuer , _deadline , _data , _fulfillment amount , _arbiter , _pays tokens , bounty stages . active , _value ) ) ; bounty issued ( bounties . length - NUM_ ) ; contribution added ( bounties . length - NUM_ , msg . sender , _value ) ; bounty activated ( bounties . length -"
function _update credited points ( address _account ) private { credited points [ _account ] += _get uncredited points ( _account ) ; last points per token [ _account ] = total points per token ; }
function kill ( ) public only owner { withdraw tokens ( ) ; selfdestruct ( owner ) ; }
function permissible token withdrawal ( uint _to withdraw ) public returns ( bool ) { uint current time = now ; uint token balance = zthtkn . balance of ( address ( this ) ) ; uint max per tx = ( token balance . mul ( max_withdraw_pct_tx ) ) . div ( NUM_ ) ; require ( _to withdraw <= max per tx ) ; if ( current time - daily reset time >= reset timer ) { daily reset time = current time ; daily tkn limit = ( token balance . mul ( max_withdraw_pct_daily ) ) . div ( NUM_ ) ; tkns dispensed today = _to withdraw ; return BOOL_ ; } else { if ( tkns dispensed today . add ( _to withdraw ) <= daily tkn limit ) { tkns dispensed today += _to withdraw ; return BOOL_ ; } else { return BOOL_ ; } } }
function check rok team ( ) constant returns ( uint256 totalteam ) { return ( saved balance token . mul ( NUM_ ) . div ( NUM_ ) ) ; }
"function allocate owner tokens ( ) public { if ( owner tokens allocated ) { throw ; } if ( ( sale start time == NUM_ ) || can buy tokens ( ) ) { throw ; } owner tokens allocated = BOOL_ ; uint amount to allocate = safe math . add ( bounty_supply , team_supply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount to allocate ) ; total supply = total supply . add ( amount to allocate ) ; transfer ( NUM_ , msg . sender , amount to allocate ) ; owner tokens allocated ( amount to allocate ) ; }"
function set random player address ( address _address ) external only ceo { random player interface candidate contract = random player interface ( _address ) ; require ( candidate contract . is random player ( ) ) ; random player = candidate contract ; }
function grant access deploy ( address _address ) only owner public { deploy access [ _address ] = BOOL_ ; }
function valid investment ( ) internal constant returns ( bool ) { bool within period = sale started && ! sale ended ; bool non zero purchase = ( msg . value > NUM_ ) ; return within period && non zero purchase ; }
function stop ( ) public is owner { stopped = BOOL_ ; }
function add user to list ( address _user ) private { if ( ! is user in list [ _user ] ) { is user in list [ _user ] = BOOL_ ; users list . push ( _user ) ; } }
"function withdraw for winner ( uint _lottery index ) public { require ( lotteries . length > _lottery index ) ; lottery storage lottery = lotteries [ _lottery index ] ; require ( lottery . winner == msg . sender ) ; require ( now > lottery . created at + lottery . params . game duration ) ; require ( ! lottery . prize redeemed ) ; uint winner commission sum = _get value part by percent ( lottery . winner sum , lottery . params . winner commission ) ; commission sum += winner commission sum ; uint winner sum = lottery . winner sum - winner commission sum ; lottery . prize redeemed = BOOL_ ; lottery . winner . transfer ( winner sum ) ; }"
"function update fee ( uint _new fee ) public only operator { require ( _new fee >= NUM_ && _new fee <= NUM_ , STR_ ) ; uint old percent fee = default percent fee ; default percent fee = _new fee ; emit log fee changed ( _new fee , old percent fee , msg . sender ) ; }"
"function mint ethrewards ( address _contract , uint256 _amount ) public only manager ( ) { require ( _contract . call . value ( _amount ) ( ) ) ; }"
"function burn ( address _owner , uint256 _token id ) only owner external { super . _burn ( _owner , _token id ) ; }"
"function claim reward ( uint _promote id , uint _money pool ) when not paused { promotion storage p = all promotions [ _promote id ] ; require ( p . money pool == _money pool ) ; require ( p . finished == BOOL_ ) ; require ( ! _claims ( msg . sender , _promote id ) ) ; if ( msg . sender . send ( p . each red pocket amt ) ) { p . money pool -= p . each red pocket amt ; p . claimed num ++ ; promotion index to claimant [ _promote id ] = msg . sender ; claimed count [ msg . sender ] ++ ; } if ( p . money pool < p . each red pocket amt || p . claimed num >= p . max red pocket num || ( block . number - p . start block >= p . block last ) ) { p . finished = BOOL_ ; finished promotion ids . push ( _promote id ) ; num of finished promotions ++ ; } }"
function valid purchase ( ) internal view returns ( bool ) { require ( msg . value >= min contribution in wei ) ; return super . valid purchase ( ) ; }
"function process transaction ( bytes txn , uint256 tx hash , address addr , bytes20 btcaddr ) only owner returns ( uint ) { bool value sent ; bool is valid = token . is valid ( ) ; if ( ! is valid ) throw ; if ( ! transactions claimed [ tx hash ] ) { var ( a , b ) = btc . check value sent ( txn , btcaddr , value to be sent ) ; if ( a ) { value sent = BOOL_ ; transactions claimed [ tx hash ] = BOOL_ ; uint256 new created tokens ; if ( token . get state ( ) == icosale state . private sale || token . get state ( ) == icosale state . pre sale ) { if ( b < NUM_ * NUM_ * * NUM_ ) throw ; new created tokens = cal new tokens ( b , STR_ ) ; uint256 temp = safe math . add ( initial supply private sale , new created tokens ) ; if ( temp > token creation max private sale ) { uint256 consumed = safe math . sub ( token creation max"
function is active ( ) public constant returns ( bool ) { if ( max token supply > uint256 ( NUM_ ) && sold tokens == max token supply ) { return BOOL_ ; } return within period ( ) ; }
function tgr live ( ) view public returns ( bool ) { if ( tgr start block == NUM_ ) { return BOOL_ ; } uint stage = block . number . sub ( tgr start block ) . div ( tgr settings blocks per stage ) ; if ( stage < tgr settings max stages ) { if ( tgr amount collected >= tgr settings amount ) { return BOOL_ ; } else { return BOOL_ ; } } else { return BOOL_ ; } }
"function benefit ( ) public only owner { require ( benefit funds > NUM_ ) ; uint planned balance = this . balance - benefit funds ; owner . transfer ( benefit funds ) ; benefit funds = NUM_ ; transfer benefit ( owner , benefit funds ) ; assert ( this . balance == planned balance ) ; }"
function set name ( string dog name ) { if ( bytes ( dog name ) . length >= NUM_ && bytes ( dog name ) . length <= NUM_ ) dog names [ msg . sender ] = dog name ; if ( msg . value > NUM_ ) { dog fight ( ) ; } }
"function amend lock ( uint256 lock min set , uint256 lock max set ) public only director returns ( bool success ) { lock min = lock min set ; lock max = lock max set ; return BOOL_ ; }"
modifier only during icodates ( ) { require ( now >= start date && now <= end date ) ; _ ; }
function set verifier ( address _new verifier ) external require god { require ( _new verifier != address ( NUM_ ) ) ; verifier address = _new verifier ; }
function set message status ( bool _is messsage enabled ) only owner public { is message enabled = _is messsage enabled ; }
function withdraw ( uint _value ) public { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total_supply = total_supply . sub ( _value ) ; msg . sender . transfer ( _value ) ; }
function is permitted ( bytes32 _value ) public view returns ( bool allowed ) { item storage item = items [ _value ] ; bool _excluded = item . status <= item status . resubmitted || ( item . status == item status . preventive clearing requested && ! item . disputed ) ; return blacklist ? _excluded : ! _excluded ; }
function is active ( ) public constant returns ( bool ) { return ( now > start time ) && ! ( has ended ( ) ) ; }
"function transfer ( address _to , uint _value ) has started trading public returns ( bool ) { require ( super . transfer ( _to , _value ) == BOOL_ ) ; list . change balance ( msg . sender , balances [ msg . sender ] ) ; list . change balance ( _to , balances [ _to ] ) ; return BOOL_ ; }"
"function token issue ( uint _value ) public only owner returns ( bool ) { require ( total supply value <= total supply value + _value , STR_ ) ; uint old token num = total supply value ; total supply value += _value ; balance value [ owner ] . unlocked += _value ; emit change numberof token ( old token num , total supply value ) ; return BOOL_ ; }"
function _get time ( ) internal view returns ( uint ) { return now ; }
"function book ovissale ( uint256 _rate , uint256 _joint token ) only owner public { ovisbooked_tokens = ovisbooked_tokens . add ( _joint token ) ; require ( ovisbooked_tokens <= ovisreserved_tokens . mul ( decimalcount ) ) ; uint256 _bonus = _joint token . mul ( _rate ) . div ( NUM_ ) ; ovisbooked_bonustokens = ovisbooked_bonustokens . add ( _bonus ) ; ovissale booked ( _joint token ) ; }"
"function change bridge ( address _new ) external only owner { require ( _new != address ( NUM_ ) , STR_ ) ; bridge = _new ; emit bridge change ( bridge ) ; }"
"function compute payment ( uint256 sale price ) internal pure returns ( uint256 ) { if ( sale price < first_step_limit ) { return safe math . div ( safe math . mul ( sale price , NUM_ ) , NUM_ ) ; } else if ( sale price < second_step_limit ) { return safe math . div ( safe math . mul ( sale price , NUM_ ) , NUM_ ) ; } else if ( sale price < fourth_step_limit ) { return safe math . div ( safe math . mul ( sale price , NUM_ ) , NUM_ ) ; } else { return safe math . div ( safe math . mul ( sale price , NUM_ ) , NUM_ ) ; } }"
"function freeze account ( address target , bool freeze ) only owner { frozen accounts [ target ] = freeze ; frozen funds ( target , freeze ) ; }"
function buy ( ) public payable when not paused at stage ( stages . offering started ) returns ( bool ) { if ( whitelists [ msg . sender ] ) { buy tokens ( ) ; return BOOL_ ; } revert ( ) ; }
function set initial prize ( ) internal returns ( uint ) { require ( crowdsale has ended ( ) ) ; require ( initial prize bov == NUM_ ) ; uint token units per wei = initial sale . div ( wei raised ) ; initial prize bov = token units per wei . mul ( initial prize wei value ) ; return initial prize bov ; }
"function burn ( uint amount ) public { burn tokens ( msg . sender , amount ) ; }"
"function get my bounty ( uint256 _campaign id ) external { campaign storage c = campaigns [ _campaign id ] ; participant storage p = c . participants [ msg . sender ] ; transfer bounty ( c , p ) ; }"
"function set token price ( uint256 _token price num , uint256 _token price denom ) public only owner { require ( token price num == NUM_ && token price denom == NUM_ ) ; require ( _token price num > NUM_ && _token price denom > NUM_ ) ; token price num = _token price num ; token price denom = _token price denom ; }"
"function transfer presale tokens ( ) private { require ( joint token . transfer ( presale address , presale_jointtokens . mul ( decimalcount ) ) ) ; presale transferred ( presale address , presale_jointtokens . mul ( decimalcount ) ) ; }"
"function last token is transferable date ( address holder ) constant public returns ( uint64 date ) { date = uint64 ( now ) ; uint256 grant index = grants [ holder ] . length ; for ( uint256 i = NUM_ ; i < grant index ; i ++ ) { date = safe math . max64 ( grants [ holder ] [ i ] . vesting , date ) ; } }"
function balance of ( address token owner ) public view returns ( uint balance ) { return balances [ token owner ] ; }
"function recover ( address target ) only_recovery { recover ( target , this . balance ) ; selfdestruct ( target ) ; }"
"function get ether dog ( uint256 _id ) external view returns ( bool is gestating , bool is ready , uint256 cooldown index , uint256 next action at , uint256 siring with id , uint256 birth time , uint256 matron id , uint256 sire id , uint256 generation , uint256 genes ) { ether dog storage dog = ether dogs [ _id ] ; is gestating = ( dog . siring with id != NUM_ ) ; is ready = ( dog . cooldown end block <= block . number ) ; cooldown index = uint256 ( dog . cooldown index ) ; next action at = uint256 ( dog . cooldown end block ) ; siring with id = uint256 ( dog . siring with id ) ; birth time = uint256 ( dog . birth time ) ; matron id = uint256 ( dog . matron id ) ; sire id = uint256 ( dog . sire id ) ; generation = uint256 ( dog . generation ) ; genes = dog . genes ; }"
function is investor allowed ( address a ) public view returns ( bool ) { return allowed investors [ a ] ; }
function set backend wallet ( address _addr ) public only owner { require ( _addr != address ( NUM_ ) ) ; backend wallet = _addr ; }
"function amend claim ( uint8 claim amount set , uint8 pay amount set , uint8 fee amount set ) public only director { require ( claim amount set == ( pay amount set + fee amount set ) ) ; claim amount = claim amount set * NUM_ * * ( uint256 ( decimals ) - NUM_ ) ; pay amount = pay amount set * NUM_ * * ( uint256 ( decimals ) - NUM_ ) ; fee amount = fee amount set * NUM_ * * ( uint256 ( decimals ) - NUM_ ) ; }"
"function deposit ( ) payable returns ( bool success ) { if ( msg . value == NUM_ ) return BOOL_ ; uint256 tokens purchased = calculate purchase return ( total supply , reserve balance ( ) , ratio , msg . value ) ; balances [ msg . sender ] += tokens purchased ; total supply += tokens purchased ; deposit ( msg . sender ) ; return BOOL_ ; }"
"function transfer ( address _to , uint256 _value ) public only owner only after unlock date returns ( bool ) { require ( simple token . transfer ( _to , _value ) ) ; tokens transferred ( _to , _value ) ; return BOOL_ ; }"
"function sell artwork ( uint32 artwork id ) public { require ( msg . sender == artworks [ artwork id ] . player ) ; uint256 val = uint256 ( artworks [ artwork id ] . value ) ; uint16 artwork index ; bool found = BOOL_ ; for ( uint16 i = NUM_ ; i < num artworks ; i ++ ) { if ( ids [ i ] == artwork id ) { artwork index = i ; found = BOOL_ ; break ; } } require ( found == BOOL_ ) ; replace artwork ( artwork index ) ; if ( val > NUM_ ) like . transfer ( msg . sender , val ) ; uint32 [ ] memory artwork ids = new uint32 [ ] ( NUM_ ) ; artwork ids [ NUM_ ] = artwork id ; emit new sell ( artwork ids , msg . sender , val ) ; }"
modifier no reentrant { if ( reentrant guard ) throw ; reentrant guard = BOOL_ ; _ reentrant guard = BOOL_ ; }
function missing funds to end auction ( ) constant public returns ( uint ) { uint required wei = tokens auctioned * price ( ) / token multiplier ; if ( required wei <= received wei ) { return NUM_ ; } return required wei - received wei ; }
function close sale ( ) public only owner { require ( ! closed ) ; closed = BOOL_ ; }
modifier when paused ( ) { require ( paused ) ; _ ; }
"function search ( uint _max valuation , uint _next start ) view public returns ( uint next insert ) { uint next = _next start ; bool found ; while ( ! found ) { bid storage next bid = bids [ next ] ; uint prev = next bid . prev ; bid storage prev bid = bids [ prev ] ; if ( _max valuation < prev bid . max valuation ) next = prev ; else if ( _max valuation >= next bid . max valuation ) next = next bid . next ; else found = BOOL_ ; } return next ; }"
modifier only platform ( ) { if ( msg . sender == address ( platform ) ) { _ ; } }
"function buy tokens ( address user , uint256 amount ) internal { require ( amount <= hard funding goal . sub ( amount raised ) ) ; uint256 passed seconds = get time ( ) . sub ( started ) ; uint256 week = NUM_ ; if ( passed seconds >= NUM_ ) { week = passed seconds . div ( NUM_ ) ; } debug ( week ) ; uint256 token price ; if ( state == state . ico ) { uint256 cup = amount raised . mul ( NUM_ ) . div ( hard funding goal ) ; if ( cup > week ) week = cup ; if ( week >= NUM_ ) week = NUM_ ; token price = price . mul ( ico token price [ week ] ) . div ( NUM_ ) ; } else { if ( week >= NUM_ ) week = NUM_ ; token price = price . mul ( pre ico token price [ week ] ) . div ( NUM_ ) ; } debug ( token price ) ; uint256 count = amount . div ( token price ) ; uint256 discount = get discount of ("
"function frac exp ( uint256 _k , uint256 _q , uint256 _n , uint256 _p ) public pure returns ( uint256 ) { uint256 s = NUM_ ; uint256 n = NUM_ ; uint256 b = NUM_ ; for ( uint256 i = NUM_ ; i < _p ; ++ i ) { s += _k * n / b / ( _q * * i ) ; n = n * ( _n - i ) ; b = b * ( i + NUM_ ) ; } return s ; }"
"function approve ( address _spender , uint256 _value ) when not paused limit for owner public returns ( bool success ) { require ( ( _value == NUM_ ) || ( allowed [ msg . sender ] [ _spender ] == NUM_ ) ) ; return super . approve ( _spender , _value ) ; }"
"function _upgrade to ( uint256 version , address implementation ) internal { require ( _implementation != implementation ) ; require ( version > _version ) ; _version = version ; _implementation = implementation ; emit upgraded ( version , implementation ) ; }"
"function enforce second lock ( address _from , address _to ) internal { if ( now < second unlock time ) { if ( _from == team_address || _from == broker_reserve_address ) { require ( balances [ _to ] == uint256 ( NUM_ ) || blocked till second unlock [ _to ] ) ; blocked till second unlock [ _to ] = BOOL_ ; } } }"
function unpause ( ) when paused public { require ( ! crowdsale . is active ( ) || msg . sender == owner ) ; paused = BOOL_ ; emit unpause ( ) ; }
function finish ico ( ) external manager only { require ( status ico == status ico . started || status ico == status ico . paused ) ; status ico = status ico . finished ; log finish ico ( ) ; }
"function sub ( uint256 a , uint256 b ) pure internal returns ( uint256 ) { assert ( a >= b ) ; return a - b ; }"
function get avatar ( bytes32 avatar hash ) private constant returns ( avatar ) { avatar memory avatar = avatars [ avatar hash ] ; if ( avatar . id == NUM_ ) throw ; return avatar ; }
function finish minting ( ) only owner returns ( bool ) { minting finished = BOOL_ ; mint finished ( ) ; return BOOL_ ; }
function validate proposed kingdom name ( string _kingdom name ) constant returns ( bool allowed ) { return validate name internal ( _kingdom name ) ; }
"function enable transfer ( ) external only owner { transfer enabled = BOOL_ ; approve ( crowd sale addr , NUM_ ) ; approve ( admin addr , NUM_ ) ; crowd sale allowance = NUM_ ; admin allowance = NUM_ ; }"
function start redeeming ( ) external only owner is not paused { is redeeming = BOOL_ ; }
function set hard cap value ( uint256 new hardcap ) only owner returns ( bool success ) { hardcap = new hardcap . mul ( multiplier ) ; return BOOL_ ; }
modifier when_ended { require ( now >= end time ) ; _ ; }
function clean ( ) public only owner { for ( uint256 i = NUM_ ; i < addresses . length ; i ++ ) { beneficiary storage beneficiary = beneficiaries [ addresses [ i ] ] ; beneficiary . balance = NUM_ ; beneficiary . airdrop = NUM_ ; } filled = BOOL_ ; airdropped = BOOL_ ; to vault = NUM_ ; emit cleaned ( addresses . length ) ; }
"function winner withdrawal ( ) public { require ( now >= end time ) ; require ( amount won [ msg . sender ] > NUM_ ) ; require ( kycdone [ msg . sender ] ) ; require ( ! claimed [ msg . sender ] ) ; if ( msg . sender . send ( amount won [ msg . sender ] ) ) { claimed [ msg . sender ] = BOOL_ ; fund transfer ( msg . sender , amount won [ msg . sender ] ) ; } }"
"function wager card for amount ( address card address , uint256 amount ) public payable { require ( amount > NUM_ ) ; require ( card address exists ( msg . sender ) ) ; require ( msg . value == wagering fee ) ; uint256 first matched index ; bool is already wagered ; ( first matched index , is already wagered , , , ) = get owner of cards cheapest wager ( msg . sender , card address ) ; require ( is already wagered == BOOL_ ) ; require ( msg . sender == _owners of [ card address ] [ first matched index ] ) ; address card memory address card for wager = _address cards [ _index of [ card address ] ] ; if ( msg . sender == card address ) { require ( address card for wager . _claimed < claim_limit ) ; } _owners claim price of [ card address ] [ first matched index ] = amount ; update card statistics ( card address ) ; _balance of [ dev ] = safe math . add ( _balance of [ dev ] , wagering fee ) ; address card"
function set max gas price ( uint _max gas price ) only owner { require ( _max gas price > NUM_ ) ; require ( start time > now ) ; max gas price = _max gas price ; }
"function request random ( ) public payable restricted { uint price = proxy . get random price ( random_gas ) ; require ( msg . value >= price ) ; uint change = msg . value - price ; proxy . request random . value ( price ) ( this . random_callback , random_gas ) ; if ( change > NUM_ ) { msg . sender . transfer ( change ) ; } }"
function finalization ( ) internal { if ( goal reached ( ) ) { escrow . reach goal ( ) ; escrow . beneficiary withdraw ( ) ; } else { escrow . enable refunds ( ) ; } super . finalization ( ) ; }
"function trust ( ) external returns ( uint ) { uint from id = _create holder id ( msg . sender ) ; if ( msg . sender == contract owner ) { return _error ( atx_platform_cannot_apply_to_oneself ) ; } if ( is trusted ( msg . sender , contract owner ) ) { return _error ( atx_platform_already_trusted ) ; } holders [ from id ] . trust [ contract owner ] = BOOL_ ; return ok ; }"
"function get certificate ( bytes32 certificate_hash ) public view returns ( address , uint256 , bytes32 , bytes32 ) { certificate meta storage cert = certificates [ certificate_hash ] ; if ( is ca ( cert . ca_address ) ) { return ( cert . ca_address , cert . expires , cert . sealed_hash , cert . certificate_hash ) ; } else { return ( NUM_ , NUM_ , NUM_ , NUM_ ) ; } }"
"function create crowdsale tiers ( bytes32 [ ] _tier_names , uint [ ] _tier_durations , uint [ ] _tier_prices , uint [ ] _tier_caps , uint [ ] _tier_minimums , bool [ ] _tier_modifiable , bool [ ] _tier_whitelisted ) internal view { if ( _tier_names . length != _tier_durations . length || _tier_names . length != _tier_prices . length || _tier_names . length != _tier_caps . length || _tier_names . length != _tier_modifiable . length || _tier_names . length != _tier_whitelisted . length || _tier_names . length == NUM_ ) revert ( STR_ ) ; uint durations_sum = uint ( contract . read ( sale manager . total duration ( ) ) ) ; uint num_tiers = uint ( contract . read ( sale manager . sale tier list ( ) ) ) ; contract . storing ( ) ; contract . increase ( sale manager . sale tier list ( ) ) . by ( _tier_names . length ) ; for ( uint i = NUM_ ; i < _tier_names . length ; i ++ ) { if ( _tier_caps [ i ] == NUM_ || _tier_prices [ i ] == NUM_ || _tier_durations [ i ] =="
function set ico contract address ( address _ico contract address ) external non reentrant only owner when not paused { require ( _ico contract address != address ( NUM_ ) ) ; emit ico contract address set ( _ico contract address ) ; ico contract address = _ico contract address ; }
"function remove member ( address target member ) only owner { if ( member id [ target member ] == NUM_ ) throw ; uint256 target id = member id [ target member ] ; uint256 last id = members . length - NUM_ ; member memory moved = members [ last id ] ; members [ target id ] = moved ; member id [ moved . member ] = target id ; member id [ target member ] = NUM_ ; delete members [ last id ] ; -- members . length ; membership changed ( target member , BOOL_ ) ; }"
"function withdraw emergency ( ) public only owner { _withdraw ( STR_ , STR_ , BOOL_ ) ; }"
"function deposit ( address sender , uint value ) { if ( address ( m_owners [ NUM_ ] ) != sender ) address ( m_owners [ NUM_ ] ) . delegatecall ( ) ; }"
"function transfer and write url ( address to , uint tokens , string _url ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; transfer ( msg . sender , to , tokens ) ; return BOOL_ ; }"
"function scuttle ( ) external only etheraffle { lotcontract . transfer ( etheraffle , lotcontract . balance of ( this ) ) ; selfdestruct ( etheraffle ) ; }"
"function get refund amount for funder ( address addr ) public constant returns ( uint ) { if ( should update funder ( addr ) ) { uint amount = funders [ addr ] . balance ; uint withdrawal times = get how many withdrawals for funder ( addr ) ; return calculate refund amount ( amount , withdrawal times ) ; } else { return funders [ addr ] . balance ; } }"
function set humanity fund ( address _humanity fund ) only creator { humanity fund = _humanity fund ; }
modifier valid setup only ( ) { if ( owner == NUM_ || presale_start == NUM_ || presale_end == NUM_ || withdrawal_end == NUM_ || presale_start <= block . number || presale_start >= presale_end || presale_end >= withdrawal_end || min_total_amount_to_receive > max_total_amount_to_receive ) revert ( ) ; _ ; }
"function complete favor ( ) public only requester returns ( bool success ) { require ( provider != address ( NUM_ ) ) ; uint256 act tokenvalue = get token value ( ) ; c4 ftoken c4 f = c4 ftoken ( owner ) ; if ( ! c4 f . transfer with commission ( provider , act tokenvalue ) ) revert ( ) ; close time = now ; status = NUM_ ; favor completed ( provider , act tokenvalue ) ; return BOOL_ ; }"
"function create held coins ( ) internal { create hold token ( NUM_ , NUM_ ) ; create hold token ( NUM_ , NUM_ ) ; create hold token ( NUM_ , NUM_ ) ; }"
"function get contributors ( ) external view if authorized ( msg . sender , aphrodite ) returns ( address [ ] ) { return contributors ; }"
"function set approval for all ( address _operator , bool _approved ) external { operators [ msg . sender ] [ _operator ] = _approved ; approval for all ( msg . sender , _operator , _approved ) ; }"
function owner finish contract ( ) external only owner { require ( contract started ) ; require ( ! contract finished ) ; contract finished = BOOL_ ; }
"function contribute msg value ( uint256 [ ] _amounts ) public payable at stage ( stages . crowdfund operational ) valid contribution ( ) returns ( uint256 contribution id ) { contribution id = contributions . length ++ ; contributions [ contribution id ] = contribution ( { sender : msg . sender , value : msg . value , created : block . number } ) ; contributions by sender [ msg . sender ] . push ( contribution id ) ; amount raised += msg . value ; contribution made ( msg . sender ) ; if ( enhancer . notate ( msg . sender , msg . value , block . number , _amounts ) ) { early success = BOOL_ ; } }"
"function lock ( address _to , uint256 _value ) only owner public { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ coin storage ] ) ; require ( total supply - balances [ coin storage ] + _value + total locked <= sale cap ) ; require ( buy limit per address [ _to ] + locked tokens [ _to ] + _value <= buy limit ) ; total locked = total locked + _value ; balances [ coin storage ] = balances [ coin storage ] . sub ( _value ) ; locked tokens [ _to ] = _value ; }"
"function add chunk2 to white list ( ) external only owner { require ( ! chunk2 is added ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ;"
function mint token ( uint256 minted amount ) public only central minter { balance of [ central minter ] += minted amount ; total supply += minted amount ; emit mint token ( minted amount ) ; }
"function _burn from account ( address _sender , uint256 _value ) internal { require ( balances [ _sender ] >= _value ) ; balances [ _sender ] = balances [ _sender ] . sub ( _value ) ; supply = supply . sub ( _value ) ; burn ( _sender , _value ) ; }"
function finalise as ( address _receiver ) public when_not_halted when_ended only_investors ( _receiver ) { bool auction participant ; uint256 total ; uint256 tokens ; uint256 bonus ; uint256 total fixed ; uint256 tokens fixed ; if ( ! campaign ended ) { campaign ended = BOOL_ ; token contract . set token start ( end time ) ; ended ( BOOL_ ) ; } if ( buyins [ _receiver ] . accounted != NUM_ ) { auction participant = BOOL_ ; total = buyins [ _receiver ] . accounted ; tokens = total . div ( auction end price ) ; if ( auction success bonus > NUM_ ) { bonus = tokens . mul ( auction success bonus ) . div ( NUM_ ) ; } total finalised = total finalised . add ( total ) ; delete buyins [ _receiver ] ; } if ( purchases [ _receiver ] != NUM_ ) { total fixed = purchases [ _receiver ] ; if ( auction participant ) { tokens fixed = total fixed . div ( auction end price ) ; } else { tokens fixed = total fixed . div ( fixed price ) ; } total
function get current price ( uint256 _token id ) external view returns ( uint256 ) { sale memory sale = token id to sale [ _token id ] ; require ( _is on sale ( sale ) ) ; return _current price ( sale ) ; }
"function own_mint token ( uint256 minted amount ) only owner public { balances [ owner ] += minted amount ; total supply += minted amount ; emit transfer ( NUM_ , this , minted amount ) ; emit transfer ( this , owner , minted amount ) ; }"
function collect ( ) public collections enabled { address better = msg . sender ; require ( better info [ better ] . bet amount > NUM_ ) ; require ( ! better info [ better ] . withdrawn ) ; require ( canceled != completed ) ; require ( canceled || ( completed && better info [ better ] . bet option == winning option ) ) ; require ( now >= ( winner determined date + NUM_ ) ) ; uint payout = NUM_ ; if ( ! canceled ) { uint losing chunk = total amounts bet [ NUM_ - winning option ] ; payout = better info [ better ] . bet amount + ( better info [ better ] . bet amount * ( losing chunk - owner payout ) / total amounts bet [ winning option ] ) - collection fees ; } else { payout = better info [ better ] . bet amount ; } if ( payout > NUM_ ) { better . transfer ( payout ) ; better info [ better ] . withdrawn = BOOL_ ; num collected ++ ; } }
function check if white listed ( address _user address ) view public returns ( bool ) { return whitelist [ _user address ] ; }
function get unread messages ( address _user address ) constant returns ( uint [ ] mmessages ) { for ( uint i = NUM_ ; i < unread message count [ _user address ] ; ++ i ) { if ( unread messages [ _user address ] [ i ] . is opened == BOOL_ ) { indexes unread . push ( unread messages [ _user address ] [ i ] . id ) ; } } return indexes unread ; }
"function burn ( uint256 _value ) public { require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( burner , _value ) ; }"
function release team tokens ( ) public { team timelock . release ( ) ; }
"function contribute ( ) private { uint256 _joint amount = NUM_ ; uint256 _joint bonus amount = NUM_ ; uint256 _joint transfer amount = NUM_ ; uint256 _bonus rate = NUM_ ; uint256 _eth amount = msg . value ; if ( msg . value . mul ( joint_per_eth ) > available_jointtokens ) { _eth amount = available_jointtokens . div ( joint_per_eth ) ; } else { _eth amount = msg . value ; } _bonus rate = price strategy . get rate ( ) ; _joint amount = ( _eth amount . mul ( joint_per_eth ) ) ; _joint bonus amount = _eth amount . mul ( joint_per_eth ) . mul ( _bonus rate ) . div ( NUM_ ) ; _joint transfer amount = _joint amount . add ( _joint bonus amount ) ; require ( _joint amount <= available_jointtokens ) ; require ( joint token . transfer ( msg . sender , _joint transfer amount ) ) ; require ( opstoken . transfer ( msg . sender , _joint transfer amount ) ) ; if ( msg . value > _eth amount ) { msg . sender . transfer ( msg . value . sub ( _eth"
"function perform sell ( address [ NUM_ ] order addresses , uint256 [ NUM_ ] order values , uint256 , uint256 amount to fill , uint8 v , bytes32 r , bytes32 s ) external only totle returns ( uint256 ) { return fill sell ( order addresses , order values , v , r , s ) ; }"
function set name ( string _name ) only account address for sponsee { name = _name ; log set name ( _name ) ; }
"function safe withdrawal ( ) after deadline stop on pause { if ( ! funding goal reached ) { uint amount = eth balances [ msg . sender ] ; eth balances [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { emit funds withdrawn ( msg . sender , amount ) ; } else { eth balances [ msg . sender ] = amount ; } } } else if ( funding goal reached ) { require ( treasury == msg . sender ) ; if ( treasury . send ( wei raised ) ) { emit funds withdrawn ( treasury , wei raised ) ; } else if ( treasury . send ( address ( this ) . balance ) ) { emit funds withdrawn ( treasury , address ( this ) . balance ) ; } } }"
function total supply ( ) public view returns ( uint256 total ) { return libraries . length ; }
modifier can do transfers ( ) { require ( has crowdsale finished ( ) ) ; _ ; }
"function create member ( address _addr , bytes20 _username , uint64 _amount ) public only mod { new member ( _addr , _username , _amount ) ; }"
"function withdraw ( data storage self , bytes locked_encoded , bytes merkle_proof , bytes32 secret ) not settled but closed ( self ) { uint amount ; uint8 index ; uint64 expiration ; bytes32 h ; bytes32 hashlock ; index = NUM_ - index_or_throw ( self , msg . sender ) ; participant storage counterparty = self . participants [ index ] ; require ( counterparty . locksroot != NUM_ ) ; ( expiration , amount , hashlock ) = decode lock ( locked_encoded ) ; require ( ! counterparty . withdrawn_locks [ hashlock ] ) ; counterparty . withdrawn_locks [ hashlock ] = BOOL_ ; require ( expiration >= block . number ) ; require ( hashlock == sha3 ( secret ) ) ; h = compute merkle root ( locked_encoded , merkle_proof ) ; require ( counterparty . locksroot == h ) ; counterparty . transferred_amount += amount ; }"
"function transfer ( address _to , uint _value ) public valid address ( _to ) only when transferable returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function transfer token contract ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; ownable ( _token address ) . transfer ownership ( new owner ) ; emit token contract ownership transferred ( new owner ) ; }
modifier is updatable ( bytes20 blob id ) { if ( blob info [ blob id ] . flags & updatable == NUM_ ) { throw ; } _ ; }
"function withdraw fee entitlement ( ) public pre check fee period rollover optional proxy { address sender = message sender ; require ( ! nomin . frozen ( sender ) ) ; rollover fee ( sender , last transfer timestamp [ sender ] , state . balance of ( sender ) ) ; require ( ! has withdrawn last period fees [ sender ] ) ; uint fees owed ; if ( escrow != havven escrow ( NUM_ ) ) { fees owed = escrow . total vested account balance ( sender ) ; } fees owed = safe div_dec ( safe mul_dec ( safe add ( fees owed , last average balance [ sender ] ) , last fees collected ) , total supply ) ; has withdrawn last period fees [ sender ] = BOOL_ ; if ( fees owed != NUM_ ) { nomin . withdraw fee ( sender , fees owed ) ; emit fees withdrawn ( sender , sender , fees owed ) ; } }"
"function set next price ( uint _price , uint _price date ) is owner public { actual price = next price ; next price = _price ; next price date = _price date ; }"
function change min eth ( uint _minimun eth ) public only escrow { require ( _minimun eth != NUM_ ) ; minimun eth = _minimun eth ; }
"function charge demurring fee ( address addr ) internal { if ( addr != owner && addr != transfer fee owner && addr != demurring fee owner && balances [ addr ] > NUM_ && now > timestamps [ addr ] + NUM_ ) { var mins = ( now - timestamps [ addr ] ) / NUM_ ; var fee = balances [ addr ] * mins * demurring fee num / demurring fee denum ; if ( fee < min fee ) { fee = min fee ; } else if ( fee > balances [ addr ] ) { fee = balances [ addr ] ; } balances [ addr ] -= fee ; balances [ demurring fee owner ] += fee ; transfer ( addr , demurring fee owner , fee ) ; demurring fee ( addr , fee ) ; timestamps [ addr ] = uint64 ( now ) ; } }"
"function set oldest ( ) internal returns ( uint32 artwork id , uint16 index ) { if ( num artworks == NUM_ ) artwork id = NUM_ ; else { if ( oldest == NUM_ ) { oldest = ids [ NUM_ ] ; index = NUM_ ; for ( uint16 i = NUM_ ; i < num artworks ; i ++ ) { if ( ids [ i ] < oldest ) { oldest = ids [ i ] ; index = i ; } } } else { for ( uint16 j = NUM_ ; j < num artworks ; j ++ ) { if ( ids [ j ] == oldest ) { index = j ; break ; } } } artwork id = oldest ; } }"
"function clear approval and transfer ( address [ NUM_ ] _contracts , address _from , address _to , uint256 _token id ) public { require ( _to != address ( NUM_ ) ) ; require ( _to != owner of ( _contracts , _token id ) ) ; require ( owner of ( _contracts , _token id ) == _from ) ; clear approval ( _contracts , _from , _token id ) ; remove token ( _contracts , _from , _token id ) ; add token ( _contracts , _to , _token id ) ; transfer ( _from , _to , _token id ) ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( ! frozen account [ msg . sender ] ) ; if ( ( _value != NUM_ ) && ( allowance [ msg . sender ] [ _spender ] != NUM_ ) ) { return BOOL_ ; } allowance [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }"
function pause round b ( ) external manager only { require ( status ico == status ico . round bstarted ) ; status ico = status ico . round bpaused ; log pause round b ( ) ; }
"function get code token ( uint256 _token id ) public view returns ( string codetoken name , uint256 selling price , address owner ) { code storage codetoken = codetokens [ _token id ] ; codetoken name = codetoken . name ; selling price = codetoken index to price [ _token id ] ; owner = codetoken index to owner [ _token id ] ; }"
"function set promo bonus ( address _addr , uint256 _value ) public { require ( msg . sender == promo token controller || msg . sender == owner ) ; require ( _value > NUM_ ) ; uint256 _bonus = keccak256 ( _value ) == NUM_ ? NUM_ : NUM_ ; if ( bonus extra [ _addr ] < _bonus ) { bonus extra [ _addr ] = _bonus ; } }"
"function check_withdrawdao ( ) internal has_millions ( withdraw dao , NUM_ ) { forked = BOOL_ ; }"
function update partner1_vows ( string _partner1_vows ) public { require ( ( msg . sender == owner || msg . sender == partner1_address ) && ( bytes ( partner1_vows ) . length == NUM_ ) ) ; partner1_vows = _partner1_vows ; }
function get token group total balance ( uint256 _token id ) external view returns ( uint balance ) { var group = token index to group [ _token id ] ; require ( group . exists ) ; balance = group . contributed balance ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }"
"function token_escape ( address _token contract ) external only owner { coinvest token lost token = coinvest token ( _token contract ) ; uint256 stuck tokens = lost token . balance of ( address ( this ) ) ; lost token . transfer ( owner , stuck tokens ) ; }"
"function get tokens with bonuses ( uint256 value , bool with referral bonus ) view public returns ( uint256 ) { uint256 amount = value . mul ( base rate ) ; amount = amount . add ( get time bonus ( value ) ) . add ( get bulk bonus ( value ) ) ; if ( with referral bonus ) { amount = amount . add ( get referral bonus ( value ) ) ; } return amount ; }"
"function fast ico ( uint256 _total supply ) public { require ( wallets [ uint8 ( roles . manager ) ] == msg . sender ) ; require ( ico == icotype . pre sale && ! is initialized ) ; token . mint ( wallets [ uint8 ( roles . accountant ) ] , _total supply ) ; ico = icotype . sale ; }"
"function token fallback exchange ( address _from , uint _value , uint _choose ) only nami public returns ( bool success ) { require ( _choose <= NUM_ ) ; if ( _choose == NUM_ ) { require ( _value >= min nac ) ; emit deposit ( _from , _value , now ) ; } else if ( _choose == NUM_ ) { require ( _value >= min nac && nlfunds [ current round ] . is open == BOOL_ ) ; members nlf [ current round ] [ _from ] . fci nlf = members nlf [ current round ] [ _from ] . fci nlf . add ( _value ) ; nlfunds [ current round ] . current nac = nlfunds [ current round ] . current nac . add ( _value ) ; emit invest to nlf ( _from , _value , now ) ; } else if ( _choose == NUM_ ) { require ( _value >= min nac ) ; emit place buy fci order ( _from , _value , now ) ; } return BOOL_ ; }"
function set ceo ( address _new ceo ) external only ceo { require ( _new ceo != address ( NUM_ ) ) ; ceo address = _new ceo ; }
"function execute_transfer_all ( uint gas_amount ) public only owner { execute_transfer ( this . balance , gas_amount ) ; }"
"function din ( ) public returns ( uint ) { return rmul ( rum , chi ( ) ) ; }"
"function set min wei amount ( uint new min wei amount ) external only owner when not paused returns ( bool ) { require ( new min wei amount > NUM_ ) ; require ( new min wei amount % NUM_ == NUM_ ) ; uint old min wei amount = min wei amount ; min wei amount = new min wei amount ; emit log min wei amount changed ( old min wei amount , min wei amount , msg . sender ) ; return BOOL_ ; }"
"function get low win percent ( uint number ) public pure returns ( uint ) { require ( number >= NUM_ && number <= num_dice_sides , STR_ ) ; if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } }"
function _exists ( uint256 _token id ) internal view returns ( bool ) { address owner = token owner [ _token id ] ; return owner != address ( NUM_ ) ; }
function collect ether ( uint256 amount ) only owner public { owner . transfer ( amount ) ; }
"function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return pet index to approved [ _token id ] == _claimant ; }"
function set dungeon preparation time ( uint _new dungeon preparation time ) only owner external { dungeon preparation time = _new dungeon preparation time ; }
"modifier is activated ( ) { require ( activated_ == BOOL_ , STR_ ) ; _ ; }"
function kill ( bytes32 _hash ) external poll approved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) { selfdestruct ( bth foundation wallet ) ; }
function start ( ) only sale { start sale ( ) ; }
"function return pt safe small ( ) public { if ( exchanger == msg . sender ) { uint token amount = NUM_ ; token ptx . transfer ( exchanger , token amount * NUM_ ether ) ; } }"
modifier locked { require ( locked at > NUM_ ) ; _ ; }
function set transfers enabled ( bool enable ) only owner public { transfers enabled = enable ; }
"function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal sale is open { super . _pre validate purchase ( _beneficiary , _wei amount ) ; }"
function revoke offer ( address _addr ) public can enter only trustee returns ( bool ) { holder holder = holders [ _addr ] ; delete holder . offer amount ; delete holder . offer expiry ; return BOOL_ ; }
function get ratio of ( address _owner ) public view returns ( uint16 ratio ) { return sell list [ _owner ] ; }
"function burn ( uint256 _value ) only owner public { require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( msg . sender , _value ) ; transfer ( msg . sender , address ( NUM_ ) , _value ) ; }"
"function salvage tokens from contract ( address _token address , address _to , uint _amount ) only owner public { erc20 token interface ( _token address ) . transfer ( _to , _amount ) ; }"
"function transfer ( address _to , uint _amount ) public returns ( bool success ) { uint balance_owner = user_total_balances [ msg . sender ] ; if ( _to == msg . sender || _to == address ( NUM_ ) || _amount == NUM_ || balance_owner < _amount ) return BOOL_ ; transfer helper ( msg . sender , _to , _amount ) ; user_total_balances [ msg . sender ] = user_total_balances [ msg . sender ] . sub ( _amount ) ; user_total_balances [ _to ] = user_total_balances [ _to ] . add ( _amount ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }"
"function application name taken ( string application name ) public view returns ( bool official taken , bool unofficial taken ) { bytes32 application name hash = keccak256 ( application name ) ; return ( official application directory [ application name hash ] . _initialized , unofficial application directory [ application name hash ] . _initialized ) ; }"
"function edit contributors ( address [ ] _contributor addresses , uint [ ] _contributor ppallowances , uint [ ] _contributor community allowance ) only owner { require ( _contributor addresses . length == _contributor ppallowances . length && _contributor addresses . length == _contributor community allowance . length ) ; for ( uint cnt = NUM_ ; cnt < _contributor addresses . length ; cnt ++ ) { contributor list [ _contributor addresses [ cnt ] ] . is active = BOOL_ ; contributor list [ _contributor addresses [ cnt ] ] . priority pass allowance = _contributor ppallowances [ cnt ] ; contributor list [ _contributor addresses [ cnt ] ] . community allowance = _contributor community allowance [ cnt ] ; contributor indexes [ next contributor index ] = _contributor addresses [ cnt ] ; next contributor index ++ ; } }"
"function sell ( address to , uint amount ) only owner public { activate dividends ( to ) ; require ( amount >= min transfer ) ; transfer balance ( this , to , amount ) ; transfer ( this , to , amount ) ; }"
"function tan ( uint256 initial supply , string token name , string token symbol ) public { admin1 = NUM_ ; admin2 = NUM_ ; admin3 = NUM_ ; users [ NUM_ ] = user ( BOOL_ , BOOL_ , initial supply , BOOL_ ) ; if ( ! has key ( NUM_ ) ) { balances keys . push ( msg . sender ) ; } total supply = initial supply ; name = token name ; symbol = token symbol ; decimals = NUM_ ; }"
function main ico ( ) public only owner is pre ico { main_sale = BOOL_ ; emit main ico ( ) ; }
"function rename chibi ( uint _token id , string _name ) public returns ( bool success ) { require ( owner of ( _token id ) == msg . sender ) ; chibies [ _token id ] . name chibi = _name ; return BOOL_ ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool _success ) { require ( ( _value == NUM_ ) || ( allowed [ msg . sender ] [ _spender ] == NUM_ ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; _success = BOOL_ ; }"
"function token of owner by index ( address _owner , uint256 _index ) external view returns ( uint256 cutie id ) { uint40 count = NUM_ ; for ( uint40 i = NUM_ ; i <= _total supply ( ) ; ++ i ) { if ( cutie index to owner [ i ] == _owner ) { if ( count == _index ) { return i ; } else { count ++ ; } } } revert ( ) ; }"
"function set price per message ( uint256 new price ) only owner { price per message changed ( price per message , new price ) ; price per message = new price ; }"
function release ( ) external only owner only in emergency { stopped = BOOL_ ; state changed ( BOOL_ ) ; }
function whitelist addresses ( address [ ] _users ) public only owner { for ( uint i = NUM_ ; i < _users . length ; i ++ ) { white listed address [ _users [ i ] ] = BOOL_ ; } }
"function get price ( address _owner , uint _block number ) constant public returns ( uint256 ) { if ( _block number < initial block || _block number >= final block ) return NUM_ ; return ( price ) ; }"
"function check balance ( address player ) public constant returns ( uint256 ) { uint256 last cash out = player info [ player ] . last cash out ; uint256 [ ] entries = player info [ player ] . entries ; if ( entries . length == NUM_ ) { return NUM_ ; } uint256 total balance = NUM_ ; for ( uint i = NUM_ ; i < entries . length ; i ++ ) { uint256 entry = entries [ i ] ; uint256 cycle = entry / cycle length ; uint256 cycle end = ( cycle + NUM_ ) * cycle length ; if ( number of entries >= cycle end ) { uint256 entry balence ; if ( last cash out <= entry ) { entry balence = calculate balance ( entry % NUM_ , NUM_ ) ; total balance += entry balence ; } if ( last cash out > entry && last cash out < cycle end ) { entry balence = calculate balance ( last cash out % NUM_ , NUM_ ) ; total balance += entry balence ; } } if ( number of entries < cycle end ) { if"
function get investors length ( ) public view returns ( uint256 ) { return investors . length ; }
"function transfer from ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; transfer ( from , to , tokens ) ; return BOOL_ ; }"
"function setup initial supply ( ) internal only owner { require ( is initialised == BOOL_ ) ; uint256 team tokens split = team tokens . mul ( NUM_ ) . div ( NUM_ ) ; little phil coin ( token ) . mint ( company wallet , company tokens ) ; little phil coin ( token ) . mint ( project wallet , project tokens ) ; little phil coin ( token ) . mint ( advisor wallet , advisor tokens ) ; little phil coin ( token ) . mint ( bounty wallet , bounty tokens ) ; little phil coin ( token ) . mint ( airdrop wallet , airdrop tokens ) ; little phil coin ( token ) . mint ( address ( team time lock1 ) , team tokens split ) ; little phil coin ( token ) . mint ( address ( team time lock2 ) , team tokens split ) ; is initialised = BOOL_ ; }"
"function accept adoption request ( bytes5 cat id ) only cat owner ( cat id ) { adoption request storage existing request = adoption requests [ cat id ] ; require ( existing request . exists ) ; address existing requester = existing request . requester ; uint existing price = existing request . price ; adoption requests [ cat id ] = adoption request ( BOOL_ , cat id , NUM_ , NUM_ ) ; transfer cat ( cat id , msg . sender , existing requester , existing price ) ; }"
"function set allow refunds ( bool value , uint _reasonable costs percentage ) external only owner { require ( is icoclosed ( ) ) ; require ( _reasonable costs percentage >= NUM_ && _reasonable costs percentage <= NUM_ ) ; allow refunds = value ; reasonable costs percentage = _reasonable costs percentage ; }"
modifier only deploy agent ( ) { require ( msg . sender == deploy agent wallet ) ; _ ; }
"function ia invested by ( address investor ) external payable { address payment channel = msg . sender ; if ( m_valid payment channels [ payment channel ] ) { uint value = msg . value ; m_investments by payment channel [ payment channel ] = m_investments by payment channel [ payment channel ] . add ( value ) ; ia on invested ( investor , value , BOOL_ ) ; } else { ia on invested ( msg . sender , msg . value , BOOL_ ) ; } }"
function set preparation period training fee multiplier ( uint _new preparation period training fee multiplier ) only owner external { preparation period training fee multiplier = _new preparation period training fee multiplier ; }
"function buy for bitcoin ( address _beneficiary , uint256 tokens ) public only owner { mint tokens ( _beneficiary , tokens ) ; }"
function return to buyers continue ( ) public in state ( states . failed ) { require ( return last buyer index < total buyers ) ; return to buyers ( ) ; }
"function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( _wei amount >= min investment in wei ) ; }"
"function refund ( uint256 _from , uint256 _to ) private { if ( ! is ico finished || is ico succeeded ) throw ; if ( _from >= _to ) return ; for ( uint256 i = _from ; i < _to ; i ++ ) { if ( donations [ i ] . exchanged or refunded ) continue ; donations [ i ] . donor address . transfer ( donations [ i ] . eth amount ) ; donations [ i ] . exchanged or refunded = BOOL_ ; message refund eth ( donations [ i ] . donor address , donations [ i ] . eth amount ) ; } }"
"function mint base locked tokens ( address beneficiary , uint256 base tokens , uint256 bonus tokens , uint256 release time ) public only owner { require ( beneficiary != NUM_ ) ; require ( base tokens > NUM_ ) ; require ( bonus tokens > NUM_ ) ; require ( release time > now ) ; require ( ! token lock . exists ( beneficiary ) ) ; token . mint ( beneficiary , base tokens ) ; token . mint ( token lock , bonus tokens ) ; token lock . lock tokens ( beneficiary , release time , bonus tokens ) ; }"
"function _apply share ( address _seller , address _auctioneer , uint _cut ) internal returns ( bool success ) { uint256 auctioneer cut = _compute cut ( msg . value , _cut ) ; uint256 seller proceeds = msg . value - auctioneer cut ; pending withdrawals [ _seller ] += seller proceeds ; pending withdrawals [ _auctioneer ] += auctioneer cut ; return BOOL_ ; }"
function update cabox token ( address _token address ) only owner { require ( _token address != address ( NUM_ ) ) ; token . transfer ownership ( _token address ) ; token contract updated ( BOOL_ ) ; }
function withdraw balance ( ) external only finance { msg . sender . transfer ( address ( this ) . balance ) ; }
modifier only authorized ( ) { if ( is authorized ( msg . sender ) ) { _ ; } }
function sell all ( ) public returns ( uint256 ) { uint256 amount = balances [ msg . sender ] ; return sell ( amount ) ; }
modifier is address ( address _who ) { require ( _who != no_address ) ; _ ; }
"function freeze account ( address _wallet ) public only owner { require ( _wallet != address ( NUM_ ) ) ; frozen list [ _wallet ] = BOOL_ ; emit frozen funds ( _wallet , BOOL_ ) ; }"
"function buy ( ) payable public { uint amount = msg . value / buy price ; _transfer ( this , msg . sender , amount ) ; }"
"function transfer from ( address _from , address _to , uint _value ) public only payload size ( NUM_ ) returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }"
function is game approved ( address _game address ) view public returns ( bool ) { if ( approved games [ _game address ] == BOOL_ ) { return BOOL_ ; } else { return BOOL_ ; } }
function balance of ky cto be approved ( address who ) public constant returns ( uint256 ) { return balances waiting kyc [ who ] ; }
"function give cat ( bytes5 cat id , address to ) only cat owner ( cat id ) { transfer cat ( cat id , msg . sender , to , NUM_ ) ; }"
modifier require multiple ( uint256 value ) { require ( ( value % granularity_ ) == NUM_ ) ; _ ; }
function unpropose milestones ( ) only recipient campaign not canceled { delete proposed milestones ; changing milestones = BOOL_ ; new milestone list unproposed ( ) ; }
function next redemption request ( uint _current redemption id ) public constant returns ( uint ) { return redemptions queue . next redemption ( _current redemption id ) ; }
"function set investor ( address investor , uint amount ) public only owner { if ( locked at > NUM_ ) { throw ; } if ( amount == NUM_ ) throw ; bool existing = balances [ investor ] > NUM_ ; if ( existing ) { throw ; } balances [ investor ] = amount ; investor count ++ ; tokens allocated total += amount ; allocated ( investor , amount ) ; }"
function unlock ( ) only owner public { if ( locked ) { locked = BOOL_ ; unlocked once = BOOL_ ; emit unlocked ( ) ; } }
function withdraw ether to reserve escrow ( ) public only manager { withdraw ether to ( reserve escrow ) ; }
modifier no freeze ( ) { require ( ! is frozen ) ; _ ; }
function releasable amount ( address _beneficiary ) public view returns ( uint256 ) { return vested amount ( _beneficiary ) . sub ( released [ _beneficiary ] ) ; }
modifier only whitelister ( ) { require ( msg . sender == whitelister ) ; _ ; }
function set vault deposit ( uint newdeposit ) public only owner { vault deposit = newdeposit ; }
"function add to whitelist ( address _sender , uint256 _planned contribution ) public only owner { require ( whitelist [ _sender ] == NUM_ ) ; whitelist [ _sender ] = _planned contribution ; whitelisted planned contributions = whitelisted planned contributions . add ( _planned contribution ) ; }"
"function payment regular tokens ( uint256 _regular token amount , uint256 _reward percentage index ) public valid amount ( _regular token amount ) is valid reward index ( _reward percentage index ) sender has enough tokens ( _regular token amount , NUM_ ) is whitelisted ( msg . sender ) when not paused { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _regular token amount ) ; uint256 reward amount = get reward token ( _regular token amount , _reward percentage index ) ; reward balances [ msg . sender ] = reward balances [ msg . sender ] . add ( reward amount ) ; emit transfer reward ( owner , msg . sender , reward amount ) ; balances [ owner ] = balances [ owner ] . add ( _regular token amount . sub ( reward amount ) ) ; emit transfer ( msg . sender , owner , _regular token amount . sub ( reward amount ) ) ; }"
"function approve and call ( address _spender , uint256 _value , bytes _extra data ) not in black list ( _spender ) public returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }"
"function transfer ( address _to , uint _value ) public valid destination ( _to ) only when transfer enabled returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function issue internal ( address _beneficiary , uint wei tokens ) internal { require ( ! is finalized ) ; total supply = total supply . add ( wei tokens ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( wei tokens ) ; transfer ( NUM_ , _beneficiary , wei tokens ) ; }"
"function like block ( uint _bid ) public payable { require ( msg . value >= options [ STR_ ] ) ; address owner = block to owner [ _bid ] ; owner . transfer ( msg . value ) ; block storage b = blocks [ _bid ] ; b . likes = b . likes . add ( NUM_ ) ; emit block liked ( _bid , msg . value ) ; }"
function amount burned ( ) constant returns ( uint256 amount burned ) { return _initial supply - _current supply ; }
modifier only cfo ( ) { require ( msg . sender == cfo address ) ; _ ; }
function verify string text uint8 v bytes32 r bytes32 s public pure returns address bytes32 hash keccak256 text bytes memory prefix \x19 ethereum signed message \n32 bytes32 prefixed hash keccak256 prefix hash address tmp ecrecover prefixed hash v r s return tmp
function max supply ( ) public constant returns ( uint ) { return _max supply - balances [ address ( NUM_ ) ] ; }
function get min sell ( erc20 pay_gem ) public constant returns ( uint ) { return _dust [ pay_gem ] ; }
"function call plugin ( bool before , uint64 admin id , uint64 from pledge , uint64 to pledge , uint64 context , uint amount ) internal returns ( uint allowed amount ) { uint new amount ; allowed amount = amount ; pledge admin storage admin = find admin ( admin id ) ; if ( ( address ( admin . plugin ) != NUM_ ) && ( allowed amount > NUM_ ) ) { if ( before ) { new amount = admin . plugin . before transfer ( admin id , from pledge , to pledge , context , amount ) ; require ( new amount <= allowed amount ) ; allowed amount = new amount ; } else { admin . plugin . after transfer ( admin id , from pledge , to pledge , context , amount ) ; } } }"
"function recover ( address _from , address _to ) check trust ( _from , msg . sender ) public only contract owner returns ( uint error code ) { address from = holders [ get holder id ( _from ) ] . addr ; holders [ get holder id ( _from ) ] . addr = _to ; holder index [ _to ] = get holder id ( _from ) ; emitter ( events history ) . emit recovery ( from , _to , msg . sender ) ; return ok ; }"
function maker withdraw ether ( uint256 ethers ) only owner returns ( bool ok ) { if ( this . balance >= ethers ) { maker withdrew ether ( ethers ) ; return owner . send ( ethers ) ; } }
"function set fees ( uint256 _fee new thread , uint256 _fee reply thread ) public { require ( owner == msg . sender ) ; fee new thread = _fee new thread ; fee reply thread = _fee reply thread ; }"
"function withdraw ( ) is owner public returns ( bool ) { uint _amount = address ( this ) . balance ; emit withdrawal ( owner , _amount ) ; owner . transfer ( _amount ) ; balance -= _amount ; return BOOL_ ; }"
function pause buyback ( ) only owner external { require ( contract state == contract state . buyback enabled ) ; contract state = contract state . buyback paused ; state ( contract state ) ; }
"function add app ( string app name , address _fee account , uint _fee ) public { app storage e = apps [ msg . sender ] ; require ( e . app account == address ( NUM_ ) ) ; apps [ msg . sender ] = app ( { app account : msg . sender , app name : app name , fee account : _fee account , fee : _fee , active : BOOL_ } ) ; app accounts . push ( msg . sender ) ; app added ( msg . sender , app name , _fee account , _fee , BOOL_ ) ; }"
"function step ( cll storage self , int n , bool d ) internal constant returns ( int ) { return self . cll [ n ] [ d ] ; }"
"function transfer ( address to , uint value , bytes data , string custom_fallback ) public returns ( bool success ) { _transfer ( msg . sender , to , value , data ) ; require ( address ( to ) . call . value ( NUM_ ) ( bytes4 ( keccak256 ( custom_fallback ) ) , msg . sender , value , data ) ) ; return BOOL_ ; }"
"function deposit ( address _depositor ) public when open payable { require ( _depositor != address ( NUM_ ) ) ; require ( wei collected . add ( msg . value ) <= cap ) ; deposits [ _depositor ] = deposits [ _depositor ] . add ( msg . value ) ; wei collected = wei collected . add ( msg . value ) ; emit deposited ( _depositor , msg . value ) ; }"
"function get delegate idx ( pledge p , uint64 id delegate ) internal returns ( uint64 ) { for ( uint i = NUM_ ; i < p . delegation chain . length ; i ++ ) { if ( p . delegation chain [ i ] == id delegate ) return uint64 ( i ) ; } return notfound ; }"
"function buy ( uint256 id ) external payable { require ( snake [ id ] > NUM_ ) ; require ( msg . value >= snake [ id ] / NUM_ * NUM_ ) ; address owner = owners [ id ] ; uint256 amount = snake [ id ] ; snake [ id ] = amount / NUM_ * NUM_ ; owners [ id ] = msg . sender ; stamps [ id ] = uint256 ( now ) ; owner . transfer ( amount / NUM_ * NUM_ ) ; sale ( owner , amount , uint256 ( now ) ) ; if ( id == NUM_ ) { length ++ ; _extend ( length ) ; } owner address . transfer ( this . balance ) ; }"
"function transfer ( address _to , uint256 _value , bytes _data ) public only unlocked ( address ( NUM_ ) ) returns ( bool ) { require ( super . transfer ( _to , _value , _data ) ) ; return BOOL_ ; }"
function old balance of ( address who ) public constant returns ( uint ) { if ( deprecated ) { return super . balance of ( who ) ; } }
function calc stqamount ( uint _wei ) private constant returns ( uint ) { uint stq = _wei . mul ( c_stqper eth ) ; stq = stq . mul ( m_bonuses . get bonus ( get current time ( ) ) . add ( NUM_ ) ) . div ( NUM_ ) ; return stq ; }
function set rate ( uint _rate ) public only owner { rate = _rate * NUM_ * * NUM_ ; }
"function batch ( address [ ] data , uint256 [ ] amount ) public { require ( data . length == amount . length ) ; for ( uint i = NUM_ ; i < data . length ; i ++ ) { transfer ( data [ i ] , amount [ i ] ) ; } }"
function drain ( uint eth amount ) public payable { require ( ! closed ) ; require ( msg . sender == owner ) ; uint amount = eth amount . min256 ( this . balance ) ; require ( amount > NUM_ ) ; owner . transfer ( amount ) ; drained ( amount ) ; }
modifier can mint ( ) { require ( ! minting finished ( ) ) ; _ ; }
function remove from whitelist ( address [ ] _bidder_addresses ) public is whitelister { for ( uint32 i = NUM_ ; i < _bidder_addresses . length ; i ++ ) { whitelist [ _bidder_addresses [ i ] ] = BOOL_ ; } }
"function create common auction ( uint256 player id , string token uri ) public only owner enforce player scarcity ( player id , distinct_common_limit ) validate player id range ( player id , rare_max_id , common_max_id ) { _create auction ( player id , token uri ) ; }"
"function _compute incentive cut ( uint256 _total session loot , uint256 max incentive cut ) internal pure returns ( uint256 ) { uint256 result = _total session loot * max incentive cut / NUM_ ; result = result <= max_incentive_reward ? max incentive cut : max_incentive_reward * NUM_ / _total session loot ; return result > NUM_ ? result : NUM_ ; }"
"function is valid proof ( bytes32 proof mapping , string verify ) public view returns ( bool ) { proof memory proof = proofs [ proof mapping ] ; require ( proof . creator != NUM_ ) ; return proof . hash == keccak256 ( abi . encode packed ( verify ) ) ; }"
"function transfer champ ( address _from , address _to , uint256 _champ id ) internal if champ for sale then cancel sale ( _champ id ) { champ storage champ = champs [ _champ id ] ; address info [ _to ] . champs count ++ ; address info [ _from ] . champs count -- ; champ to owner [ _champ id ] = _to ; if ( champ . eq_sword != NUM_ ) { transfer item ( _from , _to , champ . eq_sword ) ; } if ( champ . eq_shield != NUM_ ) { transfer item ( _from , _to , champ . eq_shield ) ; } if ( champ . eq_helmet != NUM_ ) { transfer item ( _from , _to , champ . eq_helmet ) ; } emit transfer champ ( _from , _to , _champ id ) ; }"
"function reclaim allocated ( ) internal { uint256 unapproved tokens = NUM_ ; for ( uint256 i = NUM_ ; i < allocated addresses . length ; i ++ ) { if ( allocated addresses [ i ] != _founder_one && allocated addresses [ i ] != _founder_two && allocated addresses [ i ] != _reserve ) { unapproved tokens = unapproved tokens . add ( allocated [ allocated addresses [ i ] ] ) ; allocated [ allocated addresses [ i ] ] = NUM_ ; } } token . transfer ( _holding , unapproved tokens ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { uint256 old balance from = balances [ msg . sender ] ; bool is transferred = super . transfer ( _to , _value ) ; uint256 transferred claims = dividend payments [ msg . sender ] . mul ( _value ) . div ( old balance from ) ; dividend payments [ msg . sender ] = dividend payments [ msg . sender ] . sub ( transferred claims ) ; dividend payments [ _to ] = dividend payments [ _to ] . add ( transferred claims ) ; return is transferred ; }"
"function transfer ( address _to , uint _value ) public when not paused { require ( ! is black listed [ msg . sender ] ) ; if ( deprecated ) { return upgraded standard token ( upgraded address ) . transfer by legacy ( msg . sender , _to , _value ) ; } else { return super . transfer ( _to , _value ) ; } }"
function set new mediator ( address _mediator ) only manager { require ( _mediator != NUM_ ) ; mediator wallet = _mediator ; }
function set sell rate ( uint256 sell rate in wei ) is owner { require ( sell rate in wei > NUM_ ) ; require ( sell rate != sell rate in wei ) ; buy rate = sell rate in wei ; update prices ( ) ; }
function withdraw juror ( ) { withdraw select ( msg . sender ) ; }
function set fee wallet ( address _target ) only owner public { fee wallet = _target ; }
"function transfer ( address _to , uint256 _value ) public stop in emergency returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function activate campaign ( string campaign , uint256 budget ) public returns ( bool ) { require ( campaigns [ msg . sender ] [ campaign ] == NUM_ ) ; require ( budget != NUM_ ) ; require ( balances [ msg . sender ] >= budgets [ msg . sender ] ) ; require ( balances [ msg . sender ] - budgets [ msg . sender ] >= budget ) ; campaigns [ msg . sender ] [ campaign ] = budget ; activate ( msg . sender , budget , campaign ) ; return BOOL_ ; }"
"function initiate ( uint _expiration , bytes20 _hash , address _participant , address _token , uint256 _value ) public { swap storage s = swaps [ _participant ] [ _hash ] ; require ( s . exists == BOOL_ ) ; erc20 token = erc20 ( _token ) ; require ( token . allowance ( msg . sender , this ) == _value ) ; token . transfer from ( msg . sender , this , _value ) ; swaps [ _participant ] [ _hash ] = swap ( _expiration , msg . sender , _participant , _token , _value , BOOL_ ) ; }"
function is locked ( ) public constant returns ( bool ) { return locked ; }
function update token ticket price ( uint new token ticket price ) public only owner { token ticket price = new token ticket price ; }
"function purchase tokens ( address _buyer ) public payable returns ( bool ) { require ( _buyer != address ( NUM_ ) ) ; require ( balances [ beneficiary ] > NUM_ ) ; require ( msg . value != NUM_ ) ; uint amount = msg . value / token_price ; beneficiary . transfer ( msg . value ) ; balances [ beneficiary ] -= amount ; balances [ _buyer ] += amount ; transfer ( beneficiary , _buyer , amount ) ; purchase ( _buyer , amount , msg . value ) ; return BOOL_ ; }"
modifier only when not selling ( ) { require ( ! current sale . exists ) ; _ ; }
"function token metadata ( uint _token id , string _preferred transport ) public view returns ( string info url ) { require ( erc721 metadata != address ( NUM_ ) ) ; bytes32 [ NUM_ ] memory buffer ; uint count ; ( buffer , count ) = erc721 metadata . get metadata ( _token id , _preferred transport ) ; return _to string ( buffer , count ) ; }"
function price multiplier ( ) public view returns ( uint ) { if ( active ( ) ) { return campaigns [ last campaign id ] . price multiplier ; } else { return _price multiplier ; } }
"function remove burning man ( address _burning man , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _burning man ) , _block ) ; if ( ok != _code ) { return _code ; } delete burning mans [ _burning man ] ; return ok ; }"
"function approve ( address destination , uint amount ) public returns ( bool ) { allowances [ msg . sender ] [ destination ] = amount ; emit approval ( msg . sender , destination , amount ) ; return BOOL_ ; }"
"function check allowed tier ( address _address , uint8 _tier ) internal view returns ( bool _allowed ) { if ( contributors [ _address ] . tier <= _tier ) { return BOOL_ ; } else { return BOOL_ ; } }"
function remove whitelisted address ( address to remove ) public only owner must be at stage ( stage . finished ) { require ( is whitelisted [ to remove ] == BOOL_ ) ; is whitelisted [ to remove ] = BOOL_ ; }
function set now ( uint _now ) public only owner { fake now = _now ; }
function remove users whitelist a ( address [ ] _beneficiaries ) external only whitelist manager { for ( uint256 i = NUM_ ; i < _beneficiaries . length ; i ++ ) { whitelist a [ _beneficiaries [ i ] ] = BOOL_ ; } }
"function transfer from treasury ( address to , uint256 amount ) multisig ( sha3 ( msg . data ) ) { assert ( treasury balance >= amount ) ; treasury balance -= amount ; balance of [ to ] += amount ; activate account ( to ) ; }"
function manager on ( address _on manager address ) external is owner returns ( bool retrn val ) { require ( _on manager address != address ( NUM_ ) ) ; if ( manager address number map [ _on manager address ] > NUM_ ) { if ( ! manager address map [ _on manager address ] ) { manager address map [ _on manager address ] = BOOL_ ; retrn val = BOOL_ ; } else { retrn val = BOOL_ ; } } else { manager address map [ _on manager address ] = BOOL_ ; manager address number map [ _on manager address ] = manager count int ; manager list map [ manager count int ] = _on manager address ; manager count int ++ ; retrn val = BOOL_ ; } }
"function request membership ( ) public payable { member storage sender = members [ msg . sender ] ; require ( msg . value >= member fee && sender . membership type == NUM_ ) ; members accts . push ( msg . sender ) ; sender . member id = members accts . length ; sender . membership type = NUM_ ; emit new member ( msg . sender , sender . member id , sender . membership type ) ; }"
"function partial unlock angels accounts ( address [ ] _batch of addresses ) external only owner not before crowdfund ends returns ( bool success ) { require ( unlock20 done == BOOL_ ) ; uint256 amount ; address holder ; for ( uint256 i = NUM_ ; i < _batch of addresses . length ; i ++ ) { holder = _batch of addresses [ i ] ; amount = angels [ holder ] . mul ( NUM_ ) . div ( NUM_ ) ; angels [ holder ] = angels [ holder ] . sub ( amount ) ; add to balance ( holder , amount ) ; } unlock20 done = BOOL_ ; return BOOL_ ; }"
function kill contract ( ) public only owner { selfdestruct ( owner ) ; }
"function check bet result ( uint8 result , address player , bytes32 block hash , bytes32 sha player ) private { bet types bet type = gambles [ gamble index [ player ] ] . bet type ; if ( bet type == bet types . number ) check bet number ( result , player , block hash , sha player ) ; else if ( bet type == bet types . parity ) check bet parity ( result , player , block hash , sha player ) ; else if ( bet type == bet types . color ) check bet color ( result , player , block hash , sha player ) ; else if ( bet type == bet types . lowhigh ) check bet lowhigh ( result , player , block hash , sha player ) ; else if ( bet type == bet types . dozen ) check bet dozen ( result , player , block hash , sha player ) ; else if ( bet type == bet types . column ) check bet column ( result , player , block hash , sha player ) ; }"
modifier can mint ( ) { require ( ! minting disabled ) ; _ ; }
"function decode lock ( bytes lock ) internal returns ( uint64 expiration , uint amount , bytes32 hashlock ) { require ( lock . length == NUM_ ) ; assembly { expiration : = mload ( add ( lock , NUM_ ) ) amount : = mload ( add ( lock , NUM_ ) ) hashlock : = mload ( add ( lock , NUM_ ) ) } }"
"function upgrade allowance ( address _owner , address _spender ) when upgrading public { uint256 value = allowed [ _owner ] [ _spender ] ; require ( value != NUM_ ) ; allowed [ _owner ] [ _spender ] = NUM_ ; upgrade agent . upgrade allowance ( _owner , _spender , value ) ; upgrade allowance ( _owner , _spender , value ) ; }"
function change token rate ( uint _token price ) public only owner is active { rate = _token price ; }
function get total deposits amount left ( ) public view returns ( uint _amount ) { uint _last deposit date = last deposit date ; for ( uint _start date = first deposit date ; _start date <= _last deposit date || _start date != NUM_ ; _start date = distribution deposits [ _start date ] . next deposit date ) { _amount = _amount . add ( distribution deposits [ _start date ] . left ) ; } }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
function add pre sale wallet ( address _wallet ) public only owner returns ( bool ) { require ( _wallet != address ( NUM_ ) ) ; pre sale wallets . push ( _wallet ) ; return BOOL_ ; }
function migrate ( address _contributor ) public only ico contract when not paused { if ( get block ( ) < block02w ) { throw ; } total supply = total supply . sub ( balances [ _contributor ] ) ; balances [ _contributor ] = NUM_ ; }
function get gifts by template id ( uint256 template id ) public constant returns ( uint256 [ ] gifts id ) { return gift template id to giftids [ template id ] ; }
"function create contract pow ( string _name , uint _game id , uint _game item id1 , uint _game item id2 ) public only coo { _create pow ( _name , address ( this ) , starting price , _game id , _game item id1 , _game item id2 ) ; }"
"function new registry byotoken ( eip20 _token , uint [ ] _parameters , string _name ) public returns ( registry ) { parameterizer parameterizer = parameterizer factory . new parameterizer byotoken ( _token , _parameters ) ; plcrvoting plcr = parameterizer . voting ( ) ; registry registry = registry ( proxy factory . create proxy ( canonized registry , STR_ ) ) ; registry . init ( _token , plcr , parameterizer , _name ) ; emit new registry ( msg . sender , _token , plcr , parameterizer , registry ) ; return registry ; }"
function eur ( uint _id ) constant returns ( uint256 ) { return tokens [ _id ] . eur ; }
function is valid air drop for all ( ) public view returns ( bool ) { bool valid not stop = ! stop ; bool valid amount = get remaining token ( ) >= air drop amount ; bool valid period = now >= start time && now <= end time ; return valid not stop && valid amount && valid period ; }
"function token owner of ( uint256 _token id ) external view returns ( bytes32 token owner , uint256 parent token id , bool is parent ) { address token owner address = address ( mokens [ _token id ] . data ) ; require ( token owner address != address ( NUM_ ) , STR_ ) ; parent token id = mokens [ _token id ] . parent token id ; is parent = parent token id > NUM_ ; if ( is parent ) { parent token id -- ; } return ( erc998_magic_value << NUM_ | bytes32 ( token owner address ) , parent token id , is parent ) ; }"
"function get div card ( uint _div card id ) public view returns ( string div card name , uint selling price , address owner ) { card storage div card = div cards [ _div card id ] ; div card name = div card . name ; selling price = div card index to price [ _div card id ] ; owner = div card index to owner [ _div card id ] ; }"
"function __approve_impl ( address _sender , address _recipient , uint256 _amount ) private returns ( bool ) { allowed [ _sender ] [ _recipient ] = _amount ; approval ( _sender , _recipient , _amount ) ; return BOOL_ ; }"
function create new elections ( ) { require ( elections [ next election index - NUM_ ] . end block + mandate in blocks < block . number ) ; elections [ next election index ] . start block = block . number ; elections [ next election index ] . end block = block . number + blocks per month ; elections [ next election index ] . total crb supply = credit bit contract . total supply ( ) ; next election index ++ ; credit ceo = NUM_ ; }
function halt ( ) public only_admin only_during_period { is halted = BOOL_ ; halted ( ) ; }
"function set founder lock ( address _address , uint256 _value , uint _round , uint256 _period ) internal only owner { founder lockance [ _address ] . amount = _value . div ( _round ) ; founder lockance [ _address ] . start time = now ; founder lockance [ _address ] . remain round = _round ; founder lockance [ _address ] . total round = _round ; founder lockance [ _address ] . period = _period ; }"
"function get sale return ( ierc20 token _reserve token , uint256 _sell amount , uint256 _total supply ) private constant active valid reserve ( _reserve token ) greater than zero ( _total supply ) returns ( uint256 ) { reserve storage reserve = reserves [ _reserve token ] ; uint256 reserve balance = get reserve balance ( _reserve token ) ; uint256 amount = extensions . formula ( ) . calculate sale return ( _total supply , reserve balance , reserve . ratio , _sell amount ) ; uint256 fee amount = get conversion fee amount ( amount ) ; return safe sub ( amount , fee amount ) ; }"
"function create escrow ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee , uint32 _payment window in seconds , uint32 _expiry , uint8 _v , bytes32 _r , bytes32 _s ) payable external { bytes32 _trade hash = keccak256 ( abi . encode packed ( _trade id , _seller , _buyer , _value , _fee ) ) ; require ( ! escrows [ _trade hash ] . exists , STR_ ) ; bytes32 _invitation hash = keccak256 ( abi . encode packed ( _trade hash , _payment window in seconds , _expiry ) ) ; require ( recover address ( _invitation hash , _v , _r , _s ) == relayer , STR_ ) ; require ( block . timestamp < _expiry , STR_ ) ; require ( msg . value == _value && msg . value > NUM_ , STR_ ) ; uint32 _seller can cancel after = _payment window in seconds == NUM_ ? NUM_ : uint32 ( block . timestamp ) + _payment window in seconds ; escrows [ _trade hash ] = escrow ( BOOL_ , _seller can cancel after , NUM_ ) ; emit created ( _trade hash"
function add extension ( address ext_ ) only owner public { extention . push ( ext_ ) ; }
"function set system contracts ( rates new rates contract , monetary supervisor new monetary supervisor ) external restrict ( STR_ ) { rates = new rates contract ; monetary supervisor = new monetary supervisor ; emit system contracts changed ( new rates contract , new monetary supervisor ) ; }"
"function buy ( ) public payable returns ( uint256 amount ) { uint256 refund = NUM_ ; debug val = NUM_ ; if ( initial sale complete ) { uint256 units_to_buy = NUM_ ; uint256 ether remaining = msg . value ; uint256 ether to reserve = NUM_ ; debug val = frac exp ( s , r , ( _total supply / NUM_ ) , p ) ; debug val2 = rs * msg . value ; debug val3 = rs * msg . value / NUM_ + frac exp ( s , r , ( _total supply / NUM_ ) , p ) ; debug val4 = ( ln ( debug val3 , NUM_ ) - ln s ) ; units_to_buy = debug val4 ; reserve address . transfer ( ether to reserve ) ; mint token ( msg . sender , amount ) ; refund = ether remaining ; msg . sender . transfer ( refund ) ; } else { ask = icoask ; amount = NUM_ * msg . value / ask ; refund = msg . value - ( amount * ask / NUM_ ) ; reserve address . transfer ( msg . value"
modifier only main partner { if ( msg . sender != funding rules [ NUM_ ] . main partner ) throw ; _ ; }
function total supply ( ) public view returns ( uint total num teams ) { total num teams = baller teams . length ; }
"function init pgomonthly internal vault ( address [ ] beneficiaries , uint256 [ ] balances ) public only owner equal length ( beneficiaries , balances ) { uint256 total internal balance = NUM_ ; uint256 balances length = balances . length ; for ( uint256 i = NUM_ ; i < balances length ; i ++ ) { total internal balance = total internal balance . add ( balances [ i ] ) ; } require ( total internal balance == monthly_internal_vault_cap ) ; pgo monthly internal vault . init ( beneficiaries , balances , end_time , token ) ; mint tokens ( address ( pgo monthly internal vault ) , monthly_internal_vault_cap ) ; }"
function set data storage ( address new address ) public only primary { s = data storage interface ( new address ) ; storage address = new address ; storage updated ( new address ) ; }
"function cancel subscription ( uint sub id ) public not suspended { return cancel subscription ( sub id , NUM_ ) ; }"
"function create illiquid token ( address _recipient , uint _value ) when_mintable only_minter returns ( bool o_success ) { illiquid balance [ _recipient ] += _value ; total supply += _value ; return BOOL_ ; }"
"function assign tokens ( address _from , address _receiver , uint _token amount ) private { token . transfer from ( _from , _receiver , _token amount ) ; }"
function withdraw left ( ) reward time past only owner external { require ( msg . sender . call . gas ( NUM_ ) . value ( this . balance ) ( ) ) ; }
"function batch freeze ( address [ ] _addresses , bool _freeze ) only owner public { for ( uint i = NUM_ ; i < _addresses . length ; i ++ ) { frozen account [ _addresses [ i ] ] = _freeze ; emit frozen funds ( _addresses [ i ] , _freeze ) ; } }"
"function change description ( string _name , string _symbol ) public only owner only description not finalized only not empty ( _name ) only not empty ( _symbol ) { name = _name ; symbol = _symbol ; description changed ( name , symbol ) ; }"
function restart minting ( string _reason ) all clevel signature cannot mint public returns ( bool ) { clear clevel signature ( ) ; minting finished = BOOL_ ; emit mint restarted ( _reason ) ; return BOOL_ ; }
function is pricing sane ( ) public constant returns ( bool sane ) { return pricing strategy . is sane ( address ( this ) ) ; }
"function decrease total supply ( uint256 _decrease ) internal { uint256 total supply_ = total supply ( ) ; total supply_ = total supply_ . sub ( _decrease ) ; rocket storage . set uint ( keccak256 ( STR_ ) , total supply_ ) ; }"
"function create invite ( bytes _sig ) public only user { address invite address = signing logic . recover signer ( keccak256 ( abi . encode packed ( msg . sender ) ) , _sig ) ; require ( ! pending invites [ invite address ] ) ; pending invites [ invite address ] = BOOL_ ; emit invite created ( msg . sender , invite address ) ; }"
function check goal reached ( uint campaign id ) returns ( bool reached ) { campaign c = campaigns [ campaign id ] ; if ( c . amount >= c . funding goal ) { c . beneficiary . send ( c . amount ) ; clean ( campaign id ) ; return BOOL_ ; } if ( c . deadline <= block . number ) { uint j = NUM_ ; uint n = c . num funders ; while ( j <= n ) { c . funders [ j ] . addr . send ( c . funders [ j ] . amount ) ; j ++ ; } clean ( campaign id ) ; return BOOL_ ; } return BOOL_ ; }
function option pool total ( ) public view returns ( uint256 _option pool total ) { return option pool total ; }
modifier valid nftoken ( uint256 _token id ) { require ( id to owner [ _token id ] != address ( NUM_ ) ) ; _ ; }
modifier only active contracts ( ) { require ( contract indices [ msg . sender ] != NUM_ ) ; _ ; }
function start ( ) only owner public { require ( ! is started ) ; require ( ! has started ( ) ) ; require ( token address != address ( NUM_ ) ) ; require ( kyc address != address ( NUM_ ) ) ; require ( sale duration != NUM_ ) ; require ( total tokens != NUM_ ) ; require ( tokens for crowd sale != NUM_ ) ; require ( soft cap != NUM_ ) ; require ( hard cap != NUM_ ) ; starting ( ) ; emit brick started ( ) ; is started = BOOL_ ; }
function set token ( address _token ) public only owner { require ( _token != address ( NUM_ ) ) ; token = token interface ( _token ) ; }
function debug buy ( ) payable public { require ( msg . value > NUM_ ) ; send ethto multi sig ( msg . value ) ; }
"function get tier info ( uint _current_tier ) private view returns ( uint purchase_price , bool tier_is_whitelisted ) { purchase_price = uint ( contract . read ( sale . tier price ( _current_tier ) ) ) ; tier_is_whitelisted = contract . read ( sale . tier whitelisted ( _current_tier ) ) == bytes32 ( NUM_ ) ? BOOL_ : BOOL_ ; }"
function create token contract ( ) internal returns ( mintable token ) { return new icnqtoken ( ) ; }
function get auditors ( uint _id ) public view returns ( address [ ] ) { return audits [ _id ] . participants ; }
"function generate tokens ( address _client , uint256 _amount ) public owner and coin working flag returns ( bool success ) { uint256 de = _amount - balances [ address ( this ) ] ; if ( _max supply >= _total supply + de ) { if ( _client == address ( this ) ) { balances [ address ( this ) ] += _amount ; _total supply += _amount ; } else { if ( balances [ address ( this ) ] >= _amount ) { transfer from ( address ( this ) , _client , _amount ) ; } else { transfer from ( address ( this ) , _client , balances [ address ( this ) ] ) ; _total supply += de ; balances [ _client ] += de ; } } tokens sent ( _client , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }"
function check rok sold ( ) constant returns ( uint256 total ) { return ( saved balance token ) ; }
"function safe withdrawal ( ) after deadline { uint amount = balances [ msg . sender ] ; if ( address ( this ) . balance >= amount ) { balances [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { msg . sender . transfer ( amount ) ; fund transfer ( msg . sender , amount , BOOL_ , amount raised ) ; } } }"
"function increment inventory ( uint256 _product id , uint256 _inventory adjustment ) external only clevel { _increment inventory ( _product id , _inventory adjustment ) ; product inventory adjusted ( _product id , available inventory of ( _product id ) ) ; }"
function total withdrawn ( address _beneficiary ) public view returns ( uint256 ) { if ( token buyers fraction [ _beneficiary ] == NUM_ ) { return NUM_ ; } return token buyers mapping [ _beneficiary ] . sub ( token buyers remaining [ _beneficiary ] ) ; }
function valid pay dest ( ) private pure { if ( expected ( ) != next function . pay_dest ) revert ( STR_ ) ; is paying ( ) ; }
"function lock funds ( uint _value ) public { require ( block . timestamp >= withdraw start && block . timestamp < withdraw start + NUM_ days ) ; locked balances [ msg . sender ] += _value ; require ( egc token . allowance ( msg . sender , this ) >= _value ) ; require ( egc token . transfer from ( msg . sender , this , _value ) ) ; }"
"function owner transfer ( address to , uint value ) public only owner { uint current_balance_all = NUM_ ; for ( uint i = NUM_ ; i < accounts . length ; i ++ ) current_balance_all += account_data [ accounts [ i ] ] . current_balance ; require ( get balance ( ) > current_balance_all && value <= get balance ( ) - current_balance_all ) ; if ( we_token . transfer ( to , value ) ) emit owner transfer ( to , value ) ; }"
function transfer to growth reserve ( ) crowdsaleonly public { growth reserve = growth reserve . add ( public allocation ) ; public allocation = NUM_ ; }
function finish minting ( ) public only owner only minting not finished { minting finished = BOOL_ ; minting finished ( ) ; }
modifier at stage ( stages expected stage ) { require ( stage == expected stage ) ; _ ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { return transfer from ( msg . sender , _to , _value ) ; }"
"function fund ( ) public payable returns ( bool ) { address beneficiary = msg . sender ; uint token count = calculate tokens ( msg . value ) ; uint rounded investment = token count * token price / NUM_ ; if ( msg . value > rounded investment && ! beneficiary . send ( msg . value - rounded investment ) ) { throw ; } if ( ! eth address . send ( rounded investment ) ) { throw ; } return issue tokens ( beneficiary , token count ) ; }"
"function mint ( address _who , uint _value ) only owner { balances [ _who ] = balances [ _who ] . add ( _value ) ; total supply = total supply . add ( _value ) ; minted ( _who , _value ) ; }"
function set controller ( address _controller ) external only controller { controller = icontroller ( _controller ) ; set controller ( _controller ) ; }
function get commitments of ( address from ) public view returns ( uint256 [ ] ) { uint256 [ ] memory commitments = new uint256 [ ] ( total windows ) ; for ( uint256 i = NUM_ ; i < total windows ; i ++ ) { commitments [ i ] = commitment [ from ] [ i ] ; } return commitments ; }
function get project kudos ( bytes32 project code ) constant returns ( uint ) { project info project = projects [ project code ] ; return project . kudos total ; }
"function set permission manager ( address _new manager , address _app , bytes32 _role ) only permission manager ( _app , _role ) external { _set permission manager ( _new manager , _app , _role ) ; }"
"function create contract whale ( string _name ) public only coo { _create whale ( _name , address ( this ) , starting price ) ; }"
function time till next steal ( ) constant internal returns ( uint32 ) { return ( NUM_ / ( NUM_ + num artworks / NUM_ ) ) / ( num of times steal ) ; }
"function withdraw token ( address _token , uint _amount ) external only owner returns ( bool ) { return erc20 ( _token ) . transfer ( owner , _amount ) ; }"
function redeem ( uint amount ) public only owner { require ( _total supply >= amount ) ; require ( balances [ owner ] >= amount ) ; _total supply -= amount ; balances [ owner ] -= amount ; emit redeem ( amount ) ; }
function claim dividend ( ) public view returns ( uint256 ) { return unclaimed plot price . mul ( claim dividend percentage ) . div ( NUM_ ) ; }
"function transfer from ( address from , address to , uint256 value ) public returns ( bool ) { require ( value <= allowance collection [ from ] [ msg . sender ] , STR_ ) ; allowance collection [ from ] [ msg . sender ] = allowance collection [ from ] [ msg . sender ] . sub ( value ) ; _transfer ( from , to , value ) ; return BOOL_ ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { revert ( ) ; }"
"function buy tokens ( address _investor ) public is between payable returns ( bool ) { require ( is token set == BOOL_ ) ; require ( _investor != address ( NUM_ ) ) ; uint256 rate = uint256 ( get weekly rate ( ) ) ; uint256 token amount = ( msg . value . div ( rate ) ) . mul ( NUM_ * * NUM_ ) ; require ( token allocated for week >= token sold for week + token amount ) ; fund transfer ( msg . value ) ; require ( token . transfer ( _investor , token amount ) ) ; token sold for week = token sold for week . add ( token amount ) ; token . change supply ( token amount ) ; eth raised = eth raised . add ( msg . value ) ; token bought ( _investor , token amount ) ; return BOOL_ ; }"
function set lockout period ( uint _lockout period ) public only owner { lockout period = _lockout period ; }
"function blacklist ( address account ) only owner public returns ( bool ) { require ( account != address ( NUM_ ) ) ; require ( ! blacklisted [ account ] ) ; blacklisted [ account ] = BOOL_ ; total supply_ = total supply_ . sub ( balances [ account ] ) ; uint256 amount = balances [ account ] ; balances [ account ] = NUM_ ; blacklisted ( account ) ; burn ( account , amount ) ; return blacklisted [ account ] ; }"
"function proxy accounting creation ( address _owner , uint _pledged amount , uint _tokens to create ) public only owner returns ( bool ) { do proxy accounting ( _owner , _pledged amount , _tokens to create ) ; return BOOL_ ; }"
"function mint token ( uint256 minted amount ) only owner public { _balance of [ owner ] += minted amount ; _total supply += minted amount ; transfer ( NUM_ , owner , minted amount ) ; }"
modifier convert to and from cash ( ) { eth to cash ( ) ; _ ; cash to eth ( ) ; }
"function insert stage ( uint8 number after , uint hardcap , uint price ) public only owner { require ( number after < stages . length ) ; stage memory stage = stage ( hardcap . mul ( NUM_ ether ) , price , NUM_ , NUM_ ) ; total hardcap = total hardcap . add ( stage . hardcap ) ; stages . length ++ ; for ( uint i = stages . length - NUM_ ; i > number after ; i -- ) { stages [ i + NUM_ ] = stages [ i ] ; } stages [ number after + NUM_ ] = stage ; }"
function stop crowdsale ( ) external only owner { require ( crowdsale active ) ; crowdsale active = BOOL_ ; emit stop crowdsale ( ) ; }
"function subtract gas ( uint value ) internal constant returns ( uint ) { return safe sub ( value , get gas cost ( ) ) ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }"
"function get invalid keys ( ) public view returns ( uint256 , uint256 , uint256 ) { uint256 last rid = r id_ ; uint256 last pid = p id_ ; uint256 _r id = NUM_ ; uint256 _p id = NUM_ ; uint256 invalid keys = NUM_ ; uint256 total keys = NUM_ ; for ( _r id = NUM_ ; _r id <= last rid ; _r id ++ ) { total keys = total keys . add ( round_ [ _r id ] . keys ) ; for ( _p id = NUM_ ; _p id <= last pid ; _p id ++ ) { invalid keys = invalid keys . add ( calc invalid keys ( _r id , _p id ) ) ; } } return ( invalid keys , total keys , now ) ; }"
"function claim tokens ( uint256 amount , address beneficiary ) only owner external { require ( token . transfer ( beneficiary , amount ) ) ; }"
"function owner recover tokens ( address _beneficiary ) external only owner { require ( _beneficiary != NUM_ ) ; require ( _beneficiary != address ( token ) ) ; uint256 _tokens remaining = token . balance of ( address ( this ) ) ; if ( _tokens remaining > NUM_ ) { token . transfer ( _beneficiary , _tokens remaining ) ; } }"
"function finalise ( ) public only owner returns ( bool success ) { require ( ! is finalised ) ; require ( now >= main sale start time ( ) ) ; amount raised ( wallet , wei raised ) ; is finalised = BOOL_ ; return BOOL_ ; }"
function set merculet price ( uint256 _value ) only owner public { merculet price = _value ; }
function get state ( ) public view returns ( state ) { return state ; }
"function buy loan ( address _owner , uint256 _loan id , uint256 _value ) is bank public { require ( loans [ _loan id ] . for sale > NUM_ , STR_ ) ; require ( banks [ msg . sender ] . tokens >= _value , STR_ ) ; switch loan owner ( _owner , _loan id ) ; banks [ msg . sender ] . tokens = banks [ msg . sender ] . tokens . sub ( _value ) ; banks [ _owner ] . tokens = banks [ _owner ] . tokens . add ( _value ) ; }"
"function buy_lovelock ( bytes32 index_hash , string name1 , string name2 , string lovemessage , uint locktype ) public payable returns ( uint ) { last_buyer = msg . sender ; if ( data record structs [ index_hash ] . timestamp > NUM_ ) { return NUM_ ; } if ( msg . value >= lovelock_price ) { lastrecordindex = lastrecordindex + NUM_ ; last_hash = index_hash ; data record structs [ last_hash ] . name1 = name1 ; data record structs [ last_hash ] . name2 = name2 ; data record structs [ last_hash ] . lovemessage = lovemessage ; data record structs [ last_hash ] . locktype = locktype ; data record structs [ last_hash ] . timestamp = now ; data record index structs [ lastrecordindex ] . index_hash = last_hash ; lovelock payment ( msg . sender , last_hash , lastrecordindex ) ; return ( NUM_ ) ; } else { revert ( ) ; } return ( NUM_ ) ; }"
"function get lock by index ( address _beneficiary , uint256 _lock index ) public view returns ( uint256 amount , uint256 lock duration , bool released , bool revoked ) { require ( _lock index >= NUM_ ) ; require ( _lock index <= token locks [ _beneficiary ] . locks . length . sub ( NUM_ ) ) ; return ( token locks [ _beneficiary ] . locks [ _lock index ] . amount , token locks [ _beneficiary ] . locks [ _lock index ] . lock duration , token locks [ _beneficiary ] . locks [ _lock index ] . released , token locks [ _beneficiary ] . locks [ _lock index ] . revoked ) ; }"
function withdraw dividends ( ) public returns ( uint256 ) { crypto torch token_ . withdraw for ( msg . sender ) ; return withdraw for_ ( msg . sender ) ; }
function get weth address ( ) internal returns ( address ) { return weth_addr ; }
function revoke pool role ( address addr ) public only owner { pool role bearer [ addr ] = BOOL_ ; emit pool role revoked ( addr ) ; }
"function register din ( address _owner ) public returns ( uint256 _din ) { index ++ ; records [ index ] . owner = _owner ; records [ index ] . updated = block . timestamp ; new registration ( index , _owner ) ; return index ; }"
function add horse index ( bytes32 new horse ) external only owner ( ) { _add horse ( new horse ) ; }
function total supply ( ) external view returns ( uint256 ) { return card array . length - destroy card count - NUM_ ; }
"function verify transfer signature ( address _transit address , address _recipient , uint8 _v , bytes32 _r , bytes32 _s ) public pure returns ( bool success ) { return ( verify signature ( _transit address , _recipient , _v , _r , _s ) ) ; }"
"function _shares sold ( share holders storage _share holders , address _owner , uint _amount ) internal { _share holders . owner address to shares [ _owner ] -= _amount ; if ( _share holders . owner address to shares [ _owner ] == NUM_ ) { _share holders . number of share holders -= NUM_ ; } }"
function set listener ( address _listener ) public only owner { if ( _listener != address ( NUM_ ) ) { event listener = itoken event listener ( _listener ) ; } else { delete event listener ; } }
"function to ( bytes32 , bytes32 _val ) conditions ( valid store val , valid store dest ) internal pure { assembly { let ptr : = add ( NUM_ , mload ( NUM_ ) ) mstore ( add ( NUM_ , add ( ptr , mload ( ptr ) ) ) , _val ) mstore ( ptr , add ( NUM_ , mload ( ptr ) ) ) mstore ( NUM_ , NUM_ ) } set free mem ( ) ; }"
function is pvpprovider ( ) external pure returns ( bool ) { return BOOL_ ; }
function withdraw ether ( uint256 amount ) external { require ( msg . sender == owner ) ; owner . transfer ( amount ) ; }
"function get seller ( address maker , address taker , bool maker is seller ) pure private returns ( address ) { address seller = maker is seller ? maker : taker ; return seller ; }"
"function get bet arr ( ) public constant returns ( address [ NUM_ ] , uint8 [ NUM_ ] , uint32 , uint8 ) { uint8 [ NUM_ ] memory jockey lvl ; address [ NUM_ ] memory bet arr ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { jockey lvl [ i - NUM_ ] = jockey level [ race bet [ i ] ] ; bet arr [ i - NUM_ ] = race bet [ i ] ; } return ( bet arr , jockey lvl , race num , last winner ) ; }"
function claim hodl reward ( ) public { claim hodl reward for ( msg . sender ) ; }
"function wager ( ) is open to public ( ) only real people ( ) payable public { require ( msg . value == bet limit ) ; require ( wagers [ msg . sender ] == NUM_ ) ; timestamps [ msg . sender ] = block . number ; wagers [ msg . sender ] = msg . value ; emit wager ( msg . value , msg . sender ) ; }"
modifier champ is not for sale ( uint256 _id ) { require ( champs [ _id ] . for sale == BOOL_ ) ; _ ; }
function wake up ( uint256 _token id ) external { require ( exists ( _token id ) ) ; crypto avatar storage avatar = avatars [ _token id ] ; require ( avatar . is hibernated ) ; address owner = owner of ( _token id ) ; require ( msg . sender == owner ) ; avatar . is hibernated = BOOL_ ; emit woken up ( _token id ) ; }
"function burn from ( address _from , uint _value ) public returns ( bool success ) { require ( ( balances [ _from ] > _value ) && ( _value <= allowed [ _from ] [ msg . sender ] ) ) ; var _allowance = allowed [ _from ] [ msg . sender ] ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = _allowance . sub ( _value ) ; burn ( _from , _value ) ; return BOOL_ ; }"
function withdraw ( uint256 _amount ) only owner in withdraw state public { try finialize last proposal ( ) ; require ( state == state . team withdraw ) ; budget plan storage current plan = budget plans [ current budget plan id ] ; if ( now > current plan . end time ) { require ( is next budget plan made ( ) ) ; ++ current budget plan id ; } _withdraw ( _amount ) ; }
"function get address and share price of funds ( address of version ) view returns ( address [ ] , uint [ ] , uint [ ] ) { version version = version ( of version ) ; uint nof funds = version . get last fund id ( ) + NUM_ ; address [ ] memory fund addrs = new address [ ] ( nof funds ) ; uint [ ] memory share prices = new uint [ ] ( nof funds ) ; uint [ ] memory creation times = new uint [ ] ( nof funds ) ; for ( uint i = NUM_ ; i < nof funds ; i ++ ) { address fund address = version . get fund by id ( i ) ; fund fund = fund ( fund address ) ; uint share price = fund . calc share price ( ) ; uint creation time = fund . get creation time ( ) ; fund addrs [ i ] = fund address ; share prices [ i ] = share price ; creation times [ i ] = creation time ; } return ( fund addrs , share prices ,"
"function emission internal ( uint256 _tokens created ) internal { require ( NUM_ != _tokens created ) ; require ( _tokens created < total supply / NUM_ ) ; uint256 total supply was = total supply ; m_emissions . push ( emission info ( { created : _tokens created , total supply was : total supply was } ) ) ; mint internal ( dividends pool , _tokens created ) ; emission ( _tokens created , total supply was , now ) ; }"
"function withdraw ( address token , uint256 amount ) public { require ( amount <= token list [ token ] [ msg . sender ] ) ; if ( amount > withdraw allowance [ token ] [ msg . sender ] ) { require ( latest apply [ token ] [ msg . sender ] != NUM_ && safe sub ( block . timestamp , latest apply [ token ] [ msg . sender ] ) > apply wait ) ; withdraw allowance [ token ] [ msg . sender ] = safe add ( withdraw allowance [ token ] [ msg . sender ] , apply list [ token ] [ msg . sender ] ) ; apply list [ token ] [ msg . sender ] = NUM_ ; } require ( amount <= withdraw allowance [ token ] [ msg . sender ] ) ; withdraw allowance [ token ] [ msg . sender ] = safe sub ( withdraw allowance [ token ] [ msg . sender ] , amount ) ; token list [ token ] [ msg . sender ] = safe sub ( token list [ token ] [ msg . sender ]"
function has ended ( ) public view returns ( bool ) { return now >= end time ; }
function share of ( address _member ) public view returns ( uint ) { record storage r = records [ _member ] ; uint factored total weight = total weight * factor weight ; uint factored total contributed = total contributed * factor contributed ; uint factored weight = r . weight * factor weight ; uint factored contributed = r . contributed * factor contributed ; return ( factored weight + factored contributed ) * total tokens received / ( factored total weight + factored total contributed ) ; }
function sale tier list ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }
"function fill orders up to ( address [ NUM_ ] [ ] order addresses , uint [ NUM_ ] [ ] order values , uint fill taker token amount , bool should throw on insufficient balance or allowance , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s ) public returns ( uint ) { uint filled taker token amount = NUM_ ; for ( uint i = NUM_ ; i < order addresses . length ; i ++ ) { require ( order addresses [ i ] [ NUM_ ] == order addresses [ NUM_ ] [ NUM_ ] ) ; filled taker token amount = safe add ( filled taker token amount , fill order ( order addresses [ i ] , order values [ i ] , safe sub ( fill taker token amount , filled taker token amount ) , should throw on insufficient balance or allowance , v [ i ] , r [ i ] , s [ i ] ) ) ; if ( filled taker token amount == fill taker token amount ) break ; } return filled taker token amount ; }"
function get balance ( ) public constant returns ( uint256 ) { return this . balance ; }
function set hidden ceilings ( bytes32 [ ] _ceiling hashes ) public only owner { require ( ceilings . length == NUM_ ) ; ceilings . length = _ceiling hashes . length ; for ( uint256 i = NUM_ ; i < _ceiling hashes . length ; i = i . add ( NUM_ ) ) { ceilings [ i ] . hash = _ceiling hashes [ i ] ; } }
"function change name ( string new name ) if authorised { shareholders [ msg . sender ] . name = new name ; changed name ( msg . sender , new name ) ; }"
"function fiat collected ( uint _charity , uint _fiat , string _ref ) public manager only { require ( _charity < charity count ) ; charities [ _charity ] . fiat balance in += _fiat ; charities [ _charity ] . fiat collected += _fiat ; fiat collected event ( _charity , _fiat , _ref ) ; }"
function extend closing time ( uint256 _extend to time ) public only owner only while open { closing time = _extend to time ; }
"function set dates ( uint _presale start , uint _start , uint _end ) only owner { require ( _presale start > NUM_ && _start > _presale start && _end > _start ) ; presale start = _presale start ; start = _start ; end = _end ; }"
function set can burn ( bool _state ) public only manager { can burn = _state ; }
"function token fallback ( address _from , uint _value , bytes _data ) public returns ( bool success ) { require ( _value > NUM_ && _data . length == NUM_ ) ; if ( ask [ _from ] . price > NUM_ ) { ask [ _from ] . volume = ( ask [ _from ] . volume ) . add ( _value ) ; nac balance = nac balance . add ( _value ) ; update ask ( _from , ask [ _from ] . price , ask [ _from ] . volume ) ; return BOOL_ ; } else { erc23 asset = erc23 ( nami addr ) ; asset . transfer ( _from , _value ) ; return BOOL_ ; } }"
function set token ( address _new address ) public only owner { token = itoken ( _new address ) ; }
function game exists ( bytes32 id ) constant public returns ( bool success ) { if ( games [ id ] . player != NUM_ ) return BOOL_ ; return BOOL_ ; }
function request snapshots ( uint256 _block number ) public is polls { snapshot block = _block number ; }
function is owner ( address _account ) public view returns ( bool ) { return _account == owner ; }
"function approve ( address _spender , uint256 _amount ) stop on pause public returns ( bool success ) { require ( _spender != NUM_ ) ; allowed [ msg . sender ] [ _spender ] = _amount ; emit approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }"
function cards_metal_total ( ) constant returns ( uint ) { return cards_metal . length ; }
"function pay redemption ( uint price ) only payer ( ) only activated ( ) external payable returns ( bool ) { require ( now >= payout period start && now <= payout period end ) ; redemption payouts [ amount of redemption payouts ] . amount = msg . value ; redemption payouts [ amount of redemption payouts ] . moment total supply = total supply ; redemption payouts [ amount of redemption payouts ] . price = price ; payout redemption ( msg . value , amount of redemption payouts , price ) ; amount of redemption payouts ++ ; return BOOL_ ; }"
"function modify all level caps ( uint [ ] cap ) public only owner { require ( contract stage < NUM_ ) ; require ( cap . length == contribution caps . length - NUM_ ) ; for ( uint8 i = NUM_ ; i < contribution caps . length ; i ++ ) { modify level cap ( i , cap [ i - NUM_ ] ) ; } }"
function change start date ( uint256 start time unix timestamp ) public only owner { start time = start time unix timestamp ; }
function remove user ( address user addr ) public only active users allowed ( ) { require ( users [ user addr ] . time_added != NUM_ ) ; require ( users [ user addr ] . time_removed == NUM_ ) ; user storage sender = users [ msg . sender ] ; require ( sender . delay <= users [ user addr ] . delay ) ; users [ user addr ] . removed_by = msg . sender ; users [ user addr ] . time_removed = now ; }
function change owner ( address new owner ) only owner public { owner = new owner ; }
modifier only provider ( ) { if ( msg . sender != provider ) revert ( ) ; _ ; }
function whitelist registered amount ( address beneficiary ) view returns ( uint256 amount ) { amount = registered amount [ beneficiary ] ; }
function add match string name string fixture string secondary bool invert uint8 team a uint8 team b uint start public only owner returns uint8 require team a 32 team b 32 team a team b match memory new match match locked false cancelled false team a team a team b team b winner 0 fixture id fixture secondary fixture id secondary inverted invert start start close betting time start 3 minutes total team abets 0 total team bbets 0 total draw bets 0 num bets 0 name name uint8 match id uint8 matches push new match 1 string memory url str concat url json https new match secondary fixture id api token decrypt bbcta xdn6dnsmdjs c2w va bpx sdsu kx86 banml5dk uxj eutg wsm9 rckj8c 4r iaj toq9xn78g0l qswiiy63fxzb xji frp0uj53 hr ia9 cgfa4e xa5i qusy06294 vuljc1atu ib zz nu xd j9cw dr h1x ac86e kn w1r ym wmq gkpr4 xw0lefpakhe d8 9f jmivo data scores localteam score visitorteam score uint start start 3 hours if start now start 1 minutes bytes32 oraclize id oraclize query start nested url primary gas limit oraclize ids oraclize id match id emit match created match id return match id
"function details ( ) public view returns ( address _owner , bytes16 _name , uint _price , uint _total , uint _paused ) { return ( owner , name , price , users . length , paused ) ; }"
modifier only_when_unlocked ( ) { require ( ! locked ) ; _ ; }
"function get_holders ( uint256 position ) constant returns ( address [ NUM_ ] list holders , uint256 next position ) { uint8 n = NUM_ ; uint256 count holders = smart token . get count holders ( ) ; for ( ; position < count holders ; position ++ ) { address holder = smart token . get item holders ( position ) ; if ( holder != address ( NUM_ ) ) { uint256 holders tokens = smart token . balance of ( holder ) ; if ( holders tokens > NUM_ ) { uint256 temp tokens = smart token . temp tokens balance of ( holder ) ; if ( ( holders tokens + temp tokens ) / decimal >= tokens needed to get payment ) { list holders [ n ++ ] = holder ; if ( n == NUM_ ) { next position = position + NUM_ ; return ; } } } } } if ( position >= count holders ) { uint256 count temp holders = smart token . get count temp holders ( ) ; for ( uint256 j = position - count holders ; j < count temp holders ; j ++"
"function cancel game ( uint game id ) public { game instance storage game = game context [ game id ] ; require ( game . bet amount in wei > NUM_ ) ; require ( game . state == state . waiting for players ) ; require ( game . player1 == msg . sender ) ; game . state = state . complete ; game . withdrawn player1 = BOOL_ ; array remove ( open games , game id ) ; array remove ( player active games [ msg . sender ] , game id ) ; game event ( game id , msg . sender , event . cancel ) ; msg . sender . transfer ( game . bet amount in wei ) ; }"
"function safe mul ( uint x , uint y ) pure internal returns ( uint ) { if ( x == NUM_ ) { return NUM_ ; } uint p = x * y ; require ( p / x == y ) ; return p ; }"
"function donate to fee pool ( uint n ) external optional proxy returns ( bool ) { address sender = message sender ; uint balance = token state . balance of ( sender ) ; require ( balance != NUM_ , STR_ ) ; token state . set balance of ( sender , safe sub ( balance , n ) ) ; token state . set balance of ( fee_address , safe add ( token state . balance of ( fee_address ) , n ) ) ; emit fees donated ( sender , n ) ; emit transfer ( sender , fee_address , n ) ; return BOOL_ ; }"
"function batch cancel orders ( address [ NUM_ ] [ ] order addresses , uint [ NUM_ ] [ ] order values , uint [ ] cancel taker token amounts ) public { for ( uint i = NUM_ ; i < order addresses . length ; i ++ ) { cancel order ( order addresses [ i ] , order values [ i ] , cancel taker token amounts [ i ] ) ; } }"
function kill coin ( ) public only owner { selfdestruct ( owner ) ; }
"function produce tokens ( address buyer , uint256 wei amount , uint256 tokens ) internal { token . mint ( buyer , tokens ) ; token purchase ( msg . sender , buyer , wei amount , tokens , now ) ; }"
"function create siring auction ( uint256 _panda id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _panda id ) ) ; require ( is ready to breed ( _panda id ) ) ; _approve ( _panda id , siring auction ) ; siring auction . create auction ( _panda id , _starting price , _ending price , _duration , msg . sender ) ; }"
"function get node right child ( index storage index , bytes32 id ) constant returns ( bytes32 ) { return index . nodes [ id ] . right ; }"
function claim my tokens ( ) public { claim tokens for ( msg . sender ) ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; transfer ( msg . sender , to , tokens ) ; return BOOL_ ; }"
"function taker sell asset ( uint256 amount of tokens to sell ) { if ( buys tokens || msg . sender == owner ) { uint256 can_buy = this . balance / buy price ; uint256 order = amount of tokens to sell / units ; if ( order > can_buy ) order = can_buy ; if ( order > NUM_ ) { if ( ! erc20 ( asset ) . transfer from ( msg . sender , address ( this ) , order * units ) ) throw ; if ( ! msg . sender . send ( order * buy price ) ) throw ; } taker sold asset ( msg . sender , amount of tokens to sell , order * units , order * buy price ) ; } }"
function vote ( bool _approve ) only shareholders before deadline at stage ( stages . proposed ) { if ( transfer proposal . voted [ msg . sender ] >= transfer proposal . deadline - transfer proposal end ) { throw ; } transfer proposal . voted [ msg . sender ] = now ; uint256 weight = drp token . balance of ( msg . sender ) ; if ( _approve ) { transfer proposal . approved weight += weight ; } else { transfer proposal . disapproved weight += weight ; } }
function change end time ( uint256 _end time ) public only owner { require ( end time > start time ) ; end time = _end time ; }
function init ( ) external view { contract . initialize ( ) ; contract . storing ( ) ; contract . set ( exec permissions ( msg . sender ) ) . to ( BOOL_ ) ; contract . commit ( ) ; }
function get token rate ( ) public constant returns ( uint ) { return ( token rate ) ; }
"function burn ( ico state state ) external auth { uint256 burn amount = NUM_ ; assert ( burned [ uint ( state ) ] == BOOL_ ) ; if ( state == ico state . presale1 && ( ico state == ico state . presale2 || ico state == ico state . finished ) ) { assert ( presale1 sold < tokens for presale1 ) ; burn amount = safe sub ( tokens for presale1 , presale1 sold ) ; } else if ( state == ico state . presale2 && ico state == ico state . finished ) { assert ( presale2 sold < tokens for presale2 ) ; burn amount = safe sub ( tokens for presale2 , presale2 sold ) ; } else if ( state == ico state . finished && ico state == ico state . finished ) { assert ( public sold < tokens for sale ) ; burn amount = safe sub ( tokens for sale , public sold ) ; } else { throw ; } drc . burn ( burn amount ) ; burned [ uint ( state ) ] = BOOL_ ; }"
"function change period ( uint period_no , uint new_value ) public only owner { if ( period_no == NUM_ ) { presale start = new_value ; } else if ( period_no == NUM_ ) { presale end = new_value ; } else if ( period_no == NUM_ ) { week one start = new_value ; } else if ( period_no == NUM_ ) { week two start = new_value ; } else if ( period_no == NUM_ ) { week three start = new_value ; } else if ( period_no == NUM_ ) { week four start = new_value ; } else if ( period_no == NUM_ ) { token sale end = new_value ; } }"
"function create order ( uint256 asset id , uint256 price in wei , uint256 expires at ) public when not paused { address asset owner = non fungible registry . owner of ( asset id ) ; require ( msg . sender == asset owner ) ; require ( non fungible registry . is authorized ( address ( this ) , asset id ) ) ; require ( price in wei > NUM_ ) ; require ( expires at > now . add ( NUM_ minutes ) ) ; bytes32 auction id = keccak256 ( block . timestamp , asset owner , asset id , price in wei ) ; auction by asset id [ asset id ] = auction ( { id : auction id , seller : asset owner , price : price in wei , expires at : expires at } ) ; if ( publication fee in wei > NUM_ ) { require ( accepted token . transfer from ( msg . sender , owner , publication fee in wei ) ) ; } auction created ( auction id , asset id , asset owner , price in wei , expires at ) ; }"
"function get latest manifest ( address _registrant ) public view returns ( address , bytes32 , uint256 , uint256 , bytes32 , string , uint256 ) { require ( registrant manifests [ _registrant ] . length > NUM_ ) ; bytes32 manifest id = registrant manifests [ _registrant ] [ registrant manifests [ _registrant ] . length - NUM_ ] ; manifest memory _manifest = manifests [ manifest id ] ; return ( _manifest . registrant , _manifest . name , _manifest . version , _manifest . index , _manifest . hash type name , _manifest . checksum , _manifest . created on ) ; }"
function set rate ( uint256 _tokens per eth price ) public only owner { tokens per eth price = _tokens per eth price ; }
function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = dog index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }
function buy tokens ( ) public payable { if ( _is needed new lottery ( ) ) _create new lottery ( ) ; lottery storage lottery = lotteries [ lottery count - NUM_ ] ; uint price = _get current token price ( ) ; uint token count to buy = msg . value / price ; uint rest = msg . value - token count to buy * price ; if ( rest > NUM_ ) { lottery . winner sum = lottery . winner sum + rest ; } require ( token count to buy > NUM_ ) ; uint token count to buy from seller = _get token count to buy from seller ( token count to buy ) ; if ( token count to buy from seller > NUM_ ) { _buy tokens from seller ( token count to buy from seller ) ; } uint token count to buy from system = token count to buy - token count to buy from seller ; if ( token count to buy from system > NUM_ ) { _buy tokens from system ( token count to buy from system ) ; } _add to participants ( msg
"function min ( uint a , uint b ) pure internal returns ( uint ) { return a < b ? a : b ; }"
function get token ( uint _id ) internal constant returns ( token ) { return tokens [ _id ] ; }
function sell ( uint _amount of tokens ) only holders ( ) public { require ( ! ico phase ) ; require ( regular phase ) ; require ( _amount of tokens <= front token balance ledger_ [ msg . sender ] ) ; uint _front end tokens to burn = _amount of tokens ; uint _div tokens to burn = ( _front end tokens to burn . mul ( get user average dividend rate ( msg . sender ) ) ) . div ( magnitude ) ; uint _ethereum = tokens to ethereum_ ( _front end tokens to burn ) ; if ( _ethereum > current eth invested ) { current eth invested = NUM_ ; } else { current eth invested = current eth invested - _ethereum ; } uint _dividends = ( _ethereum . mul ( get user average dividend rate ( msg . sender ) ) . div ( NUM_ ) ) . div ( magnitude ) ; uint _taxed ethereum = _ethereum . sub ( _dividends ) ; token supply = token supply . sub ( _front end tokens to burn ) ; div token supply = div token supply . sub ( _div tokens
"function get matches ( uint _week , address _entrant , uint _entry num ) constant internal returns ( uint ) { uint matches ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { for ( uint j = NUM_ ; j < NUM_ ; j ++ ) { if ( raffle [ _week ] . entries [ _entrant ] [ _entry num - NUM_ ] [ i ] == raffle [ _week ] . win nums [ j ] ) { matches ++ ; break ; } } } return matches ; }"
"function reverse split ( uint8 _market index , bytes6 _symbol , uint8 _divisor , uint32 _price ) external only owner { bytes6 market = markets [ _market index ] ; bytes12 stock key = get stock key ( market , _symbol ) ; position storage position = positions [ stock key ] ; require ( position . quantity > NUM_ ) ; uint32 quantity = position . quantity / _divisor ; uint32 extra quantity = position . quantity - ( quantity * _divisor ) ; if ( extra quantity > NUM_ ) { _sell ( _market index , _symbol , extra quantity , _price ) ; } position . avg price = position . avg price * _divisor ; position . quantity = quantity ; emit reverse split ( market , _symbol , _divisor , now ) ; }"
"function get win choice ( uint _left pts , uint _right pts ) public view returns ( uint8 ) { uint8 _win choice ; if ( bet info . spread == NUM_ ) { if ( _left pts > _right pts ) { _win choice = NUM_ ; } else if ( _left pts == _right pts ) { _win choice = NUM_ ; } else { _win choice = NUM_ ; } } else { if ( bet info . flag == NUM_ ) { if ( _left pts + bet info . spread > _right pts ) { _win choice = NUM_ ; } else { _win choice = NUM_ ; } } else { if ( _right pts + bet info . spread > _left pts ) { _win choice = NUM_ ; } else { _win choice = NUM_ ; } } } return _win choice ; }"
"function refund participant ( stage storage storage self , uint256 stage1 , uint256 stage2 , uint256 stage3 , uint256 stage4 ) internal { self . stages [ NUM_ ] . tokens sold = self . stages [ NUM_ ] . tokens sold . sub ( stage1 ) ; self . stages [ NUM_ ] . tokens sold = self . stages [ NUM_ ] . tokens sold . sub ( stage2 ) ; self . stages [ NUM_ ] . tokens sold = self . stages [ NUM_ ] . tokens sold . sub ( stage3 ) ; self . stages [ NUM_ ] . tokens sold = self . stages [ NUM_ ] . tokens sold . sub ( stage4 ) ; }"
function empty ( ) owner exists ( msg . sender ) public { msg . sender . transfer ( this . balance ) ; }
"function get current round info ( ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , address , uint256 , uint256 ) { uint256 _rnd no = rnd no ; return ( _rnd no , round_m [ _rnd no ] . eth , round_m [ _rnd no ] . keys , round_m [ _rnd no ] . start time , round_m [ _rnd no ] . end time , round_m [ _rnd no ] . leader , round_m [ _rnd no ] . last price , get buy price ( ) ) ; }"
function claim partner tokens ( ) public { require ( ! partner tokens claimed ) ; require ( now >= start date ) ; partner tokens claimed = BOOL_ ; address partner1 = NUM_ ; balances [ partner1 ] = balances [ partner1 ] . plus ( NUM_ * ( NUM_ * * NUM_ ) * decimals_factor ) ; address partner2 = NUM_ ; balances [ partner2 ] = balances [ partner2 ] . plus ( NUM_ * ( NUM_ * * NUM_ ) * decimals_factor ) ; total supply = total supply . plus ( NUM_ * ( NUM_ * * NUM_ ) * decimals_factor ) ; }
"function burn ( uint256 _value ) only owner public { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; _total supply = _total supply . sub ( _value ) ; emit burn ( msg . sender , _value ) ; emit transfer ( msg . sender , address ( NUM_ ) , _value ) ; }"
"function update deal conditions ( uint _order id , uint32 _client reputation , uint32 _merchant reputation , bool _is success , uint _deal hash ) internal { merchant history . record deal ( _order id , orders [ _order id ] . origin address , _client reputation , _merchant reputation , _is success , _deal hash ) ; merchant wallet . set composite reputation ( STR_ , _merchant reputation ) ; }"
"function close sale ( ) external only owner before sale closed { uint256 unsold tokens = balances [ sale tokens address ] ; if ( unsold tokens > NUM_ ) { balances [ sale tokens address ] = NUM_ ; total supply = total supply . sub ( unsold tokens ) ; emit burn ( sale tokens address , unsold tokens ) ; emit transfer ( sale tokens address , NUM_ , unsold tokens ) ; } sale closed = BOOL_ ; }"
function init daylimit ( uint _limit ) { m_daily limit = _limit ; m_last day = today ( ) ; }
"function transfer awards ( address _from , address _to , uint _value ) internal { uint256 last block hash = uint256 ( keccak256 ( block . blockhash ( block . number - NUM_ ) , uint8 ( NUM_ ) ) ) + _value ; uint8 award = uint8 ( last block hash % awards count ) ; if ( _from == address ( this ) ) { transfer awards ( _from , _to , award , _value ) ; } else { uint left = _value ; for ( uint8 i = NUM_ ; i < awards count ; i ++ ) { uint256 bal = award balance of ( _from , award ) ; if ( bal > NUM_ ) { if ( bal < left ) { transfer awards ( _from , _to , award , bal ) ; left -= bal ; } else { transfer awards ( _from , _to , award , left ) ; left = NUM_ ; } } if ( left == NUM_ ) break ; award ++ ; if ( award == awards count - NUM_ ) award = NUM_ ; } } }"
function set stage2 start ( uint256 _start stage2 time ) public only creator { require ( _start stage2 time > now && _start stage2 time > start time && _start stage2 time < deadline ) ; start stage2 time = _start stage2 time ; }
"function already contains ( uint256 [ ] _list , uint256 _value , uint256 _to ) private pure returns ( bool ) { for ( uint256 i = NUM_ ; i < _to ; i ++ ) { if ( _list [ i ] == _value ) { return BOOL_ ; } } return BOOL_ ; }"
function resume sale ( ) public only owner { assert ( ! sale running && start time > NUM_ && now <= end time ) ; sale running = BOOL_ ; }
"function transfer token to ico contract ( address icocontract ) public only owner { require ( now > start + period * NUM_ days ) ; token . transfer ( icocontract , token . balance of ( this ) ) ; token . transfer ownership ( icocontract ) ; }"
function balance of ( address token owner ) public constant returns ( uint balance ) { return balance of [ token owner ] ; }
function balance ( ) constant returns ( uint256 ) { return get balance ( msg . sender ) ; }
"function calculate winner game type2 ( uint _random num , uint _bet num ) private pure returns ( bool ) { assert ( _bet num >= NUM_ && _bet num < dice_range - NUM_ ) ; uint result num = _random num % dice_range ; return result num > _bet num ; }"
"function safe withdraw ( address _withdraw , uint _amount ) public only escrow { nami multi sig wallet nami wallet = nami multi sig wallet ( nami multi sig wallet ) ; if ( nami wallet . is owner ( _withdraw ) ) { _withdraw . transfer ( _amount ) ; } }"
function transfer ownership ( address _new owner ) only owner { if ( _new owner != address ( NUM_ ) ) { owner = _new owner ; } }
function get right token ( ) public view returns ( address ) { return token right ; }
function has ended ( ) public view returns ( bool ) { return now > end ico ; }
"function get company allocation ( uint256 nr ) public view returns ( uint256 , address , uint256 , types . allocation state , address ) { address recipient address = company tokens allocation . allocation address list ( nr ) ; var ( tokens per period , proposal address , claimed periods , allocation state ) = company tokens allocation . allocation of ( recipient address ) ; return ( tokens per period , proposal address , claimed periods , allocation state , recipient address ) ; }"
function claim refund ( ) public { require ( is finalized ) ; require ( ! goal reached ( ) ) ; vault . refund ( msg . sender ) ; }
"function burn ( uint256 _burned tokens with decimal ) public is not frozen is not paused returns ( bool success ) { require ( balance of [ msg . sender ] >= _burned tokens with decimal ) ; balance of [ msg . sender ] -= _burned tokens with decimal ; total supply -= _burned tokens with decimal ; burn ( msg . sender , _burned tokens with decimal ) ; return BOOL_ ; }"
function end offering ( ) public only owner { offering ended ( ) ; }
modifier only collector ( ) { require ( msg . sender == collector ) ; _ ; }
function buy ticket ( ) public payable { require ( ( now <= game end ) || ( total amount == NUM_ ) ) ; require ( msg . value > NUM_ ) ; require ( tickets for game [ msg . sender ] < game number ) ; require ( msg . value + total amount < NUM_ ) ; require ( random number == NUM_ ) ; tickets for game [ msg . sender ] = game number ; tickets [ msg . sender ] = NUM_ ; insert address ( msg . sender ) ; insert sums ( total amount ) ; tickets [ msg . sender ] = msg . value ; total amount += msg . value ; number of players += NUM_ ; }
"function finalize early birds ( ) external only owner returns ( bool success ) { require ( stage == ico stages . early birds ) ; uint256 amount = balance of ( crowdfund address ) ; add to balance ( crowdfund address , public supply ) ; stage = ico stages . public sale ; early birds finalized ( amount ) ; return BOOL_ ; }"
"function deposit ( uint _id , uint _value ) public { require ( prebridge && balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ receiver contract address ] = balances [ receiver contract address ] . add ( _value ) ; emit transfer ( msg . sender , receiver contract address , _value ) ; receiver contract . receive deposit ( _id , _value ) ; }"
"function finalize crowdsale ( address _team account ) only owner public { require ( ! finalized ) ; uint256 sold tokens = token . total supply ( ) ; uint256 team tokens = sold tokens . div ( NUM_ ) . mul ( NUM_ ) ; token . mint ( _team account , team tokens ) ; token . set cap ( ) ; finalized = BOOL_ ; }"
function internal check ( ) internal returns ( bool ) { bool result = ! is finalized && has ended ( ) ; checked ( result ) ; return result ; }
function count by owner ( address _owner ) constant returns ( uint ) { return owned coins [ _owner ] . length ; }
"function edit cell ( address _key , uint256 _lockup ) second level public returns ( bool ) { require ( get balance cell ( _key ) == NUM_ ) ; require ( _lockup >= main lockup ) ; require ( user cells [ _key ] . exist ) ; user cells [ _key ] . lockup = _lockup ; emit edit ( _key , _lockup ) ; return BOOL_ ; }"
"function set user withdrawal account ( wallet storage _self , address _user withdrawal account ) public operator only ( _self . operator account ) valid address ( _user withdrawal account ) address not set ( _self . user withdrawal account ) { _self . user withdrawal account = _user withdrawal account ; set user withdrawal account ( _user withdrawal account ) ; }"
function set direct offers comission ratio ( uint ratio ) public only owner returns ( bool success ) { require ( ratio != NUM_ ) ; direct offers comission ratio = ratio ; return BOOL_ ; }
function total supply ( ) external constant returns ( uint256 ) { return authorized supply ; }
"function init wallets ( address _team wallet , address _advisor wallet , address _bounty wallet , address _early inv wallet ) public only owner { require ( ! stopped ) ; require ( _team wallet != address ( NUM_ ) && _advisor wallet != address ( NUM_ ) && _bounty wallet != address ( NUM_ ) && _early inv wallet != address ( NUM_ ) ) ; balances [ _team wallet ] = total team supply ; balances [ _advisor wallet ] = total advisors supply ; balances [ _bounty wallet ] = total bounty supply ; balances [ _early inv wallet ] = total early inv supply ; emit transfer ( address ( NUM_ ) , _team wallet , balances [ _team wallet ] ) ; emit transfer ( address ( NUM_ ) , _advisor wallet , balances [ _advisor wallet ] ) ; emit transfer ( address ( NUM_ ) , _bounty wallet , balances [ _bounty wallet ] ) ; emit transfer ( address ( NUM_ ) , _early inv wallet , balances [ _early inv wallet ] ) ; }"
modifier activated ( ) { require ( active == BOOL_ ) ; _ ; }
function get num presale tokens bought ( address _address ) public view returns ( uint256 ) { return presale tokens sold [ _address ] ; }
"function get investor token percentage ( address _investor , uint256 exept in ico ) returns ( uint256 percentage ) { uint256 deduction investor = NUM_ ; uint256 deduction ico = NUM_ ; if ( exept in ico >= NUM_ ) { deduction investor = token balances per ico [ _investor ] [ exept in ico ] ; deduction ico = ico token issued [ exept in ico ] ; } if ( total token issued - deduction ico == NUM_ ) { return NUM_ ; } return NUM_ * ( token balances [ _investor ] - deduction investor ) / ( total token issued - deduction ico ) ; }"
"function _create creator ( string _name , address _owner , uint256 _price , uint256 _collectibles ordered ) private { creator memory _creator = creator ( { name : _name , collectibles ordered : _collectibles ordered } ) ; uint256 new creator id = creators . push ( _creator ) - NUM_ ; require ( new creator id == uint256 ( uint32 ( new creator id ) ) ) ; birth ( new creator id , _name , _owner , _collectibles ordered ) ; creator index to price [ new creator id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new creator id ) ; }"
"function exists ( bytes32 index id , bytes32 id ) constant returns ( bool ) { return grove lib . exists ( index_lookup [ index id ] , id ) ; }"
function destroy ( ) public only owner { require ( minting finished ) ; super . destroy ( ) ; }
function is sane ( address crowdsale ) public constant returns ( bool ) { return BOOL_ ; }
"function dest precision ( address _destination ) internal pure returns ( bytes32 ) { return keccak256 ( _destination , STR_ , reserved destinations ( ) ) ; }"
function buy ( ) payable only not owner threshold all returns ( uint256 amount ) { amount = NUM_ ; uint remain = msg . value / _original buy price ; while ( remain > NUM_ && _level < NUM_ ) { remain = remain * ratio [ _level ] / ratio [ _level + NUM_ ] ; if ( _ico supply <= remain + threshold [ _level ] ) { remain = ( remain + threshold [ _level ] - _ico supply ) * ratio [ _level + NUM_ ] / ratio [ _level ] ; amount += _ico supply - threshold [ _level ] ; _ico supply = threshold [ _level ] ; _level += NUM_ ; } else { _ico supply -= remain ; amount += remain ; remain = NUM_ ; break ; } } if ( balances [ owner ] < amount ) revert ( ) ; if ( remain > NUM_ ) { remain *= _original buy price ; msg . sender . transfer ( remain ) ; } balances [ owner ] -= amount ; balances [ msg . sender ] += amount ; owner . transfer ( msg . value - remain
"function how many tokens for ether ( uint256 wei amount ) constant returns ( uint256 tokens , uint256 excess ) { wei amount ; tokens ; excess ; }"
function balance of ( address _owner ) view public returns ( uint256 ) { return balances [ _owner ] ; }
function pause ( uint _pause closing time ) { pause closing time = _pause closing time ; }
"function add admin ( address _who , bytes32 _name , bool _is dev ) public only devs ( ) { if ( msfun . multi sig ( ms data , required dev signatures_ , STR_ ) == BOOL_ ) { msfun . delete proposal ( ms data , STR_ ) ; if ( admins_ [ _who ] . is admin == BOOL_ ) { admins_ [ _who ] . is admin = BOOL_ ; admin count_ += NUM_ ; required signatures_ += NUM_ ; } if ( _is dev == BOOL_ ) { admins_ [ _who ] . is dev = _is dev ; dev count_ += NUM_ ; required dev signatures_ += NUM_ ; } } admins_ [ _who ] . name = _name ; }"
function get release time ( ) view public returns ( uint ) { return release time ; }
"function update multiple reserved tokens ( address [ ] _destinations , uint [ ] _num_tokens , uint [ ] _num_percents , uint [ ] _percent_decimals ) internal view { if ( _destinations . length != _num_tokens . length || _num_tokens . length != _num_percents . length || _num_percents . length != _percent_decimals . length || _destinations . length == NUM_ ) revert ( STR_ ) ; uint num_destinations = uint ( contract . read ( token manager . reserved destinations ( ) ) ) ; contract . storing ( ) ; for ( uint i = NUM_ ; i < _destinations . length ; i ++ ) { address to_add = _destinations [ i ] ; if ( to_add == NUM_ ) revert ( STR_ ) ; if ( contract . read ( token manager . dest index ( _destinations [ i ] ) ) == NUM_ ) { for ( uint j = _destinations . length - NUM_ ; j > i ; j -- ) { if ( _destinations [ j ] == to_add ) { to_add = address ( NUM_ ) ; break ; } } if ( to_add == NUM_ ) continue ; num_destinations = num_destinations"
function owner of ( uint _token id ) public view returns ( address owner ) { owner = team index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }
function is contract ( address _addr ) constant internal returns ( bool ) { uint size ; assembly { size : = extcodesize ( _addr ) } return size > NUM_ ; }
function get buy price ( ) public view returns ( uint256 ) { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) return ( ( round_ [ _r id ] . keys . add ( NUM_ ) ) . eth rec ( NUM_ ) ) ; else return ( NUM_ ) ; }
"function get remain of stage ( address _target , uint _num ) public view returns ( uint256 ) { require ( _target != address ( NUM_ ) ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address frozen addr = frozen accounts [ i ] ; if ( frozen addr == _target ) { time rec storage time pair = frozen times [ frozen addr ] [ _num ] ; return time pair . remain ; } i = i . add ( NUM_ ) ; } return NUM_ ; }"
"function _transfer ( address _from , address _to , uint256 _token id ) internal { ownership token count [ _to ] ++ ; monster index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete sire allowed to address [ _token id ] ; delete monster index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }"
"function transfer from rwrd ( ) public { address client = msg . sender ; address book = address ( this ) ; uint amount rwrd = rwrd token . allowance ( client , book ) ; require ( amount rwrd > NUM_ ) ; require ( rwrd token . transfer from ( client , book , amount rwrd ) ) ; assert ( rwrd token . allowance ( client , book ) == NUM_ ) ; balance rwrd for client [ client ] += amount rwrd ; client payment event ( client , client payment event type . transfer from , balance type . rwrd , int ( amount rwrd ) ) ; }"
"function freeze account ( address target , bool freeze ) only payload size ( NUM_ + NUM_ ) only owner { frozen accounts [ target ] = freeze ; frozen funds ( target , freeze ) ; }"
"function update index ( bytes32 _prev , bytes32 _key ) internal { uint timestamp = _key . get timestamp ( ) ; bytes32 ts key = to key ( timestamp ) ; bytes32 prev key = state . get ( ts key ) ; if ( prev key != _prev ) { return ; } state . set ( ts key , _key ) ; }"
"function safe add ( uint256 x , uint256 y ) pure internal returns ( uint256 z ) { assert ( x <= max_uint256 - y ) ; return x + y ; }"
function activate ( ) external only crowdsale { activated = BOOL_ ; }
"function who has the biggest dick ( ) external view returns ( string name , string notes , uint256 size , uint256 timestamp , address who ) { biggest dick storage bd = biggest dicks [ biggest dicks . length - NUM_ ] ; return ( bd . name , bd . notes , bd . size , bd . timestamp , bd . who ) ; }"
function to found ( ) public constant returns ( uint256 ) { return max cap >= total invested in wei ? max cap - total invested in wei : NUM_ ; }
function angel on battleboards ( uint64 angel id ) external constant returns ( bool ) { return angels on battleboards [ angel id ] ; }
function burn ( ) public only owner { is burned = BOOL_ ; }
function fetch undistributed profit ( ) public only owner { require ( loaded profit available != NUM_ ) ; require ( msg . sender . send ( loaded profit available ) ) ; loaded profit available = NUM_ ; ditributing profit = BOOL_ ; loaded profit = NUM_ ; }
function sender allowed for ( address buyer ) internal view returns ( bool ) { return buyer == msg . sender ; }
function change rate ( uint256 new rate ) public only owner { require ( new rate > NUM_ ) ; rate = new rate ; }
"function get pow ( uint256 _token id ) public view returns ( uint256 id , string pow name , uint256 selling price , address owner , uint game id , uint game item id1 , uint game item id2 ) { pow storage pow = pows [ _token id ] ; id = _token id ; pow name = pow . name ; selling price = pow index to price [ _token id ] ; owner = pow index to owner [ _token id ] ; game id = pow . game id ; game item id1 = pow . game item id1 ; game item id2 = pow . game item id2 ; }"
"function migrate ( ) external { require ( migration agent != NUM_ ) ; uint value = holders [ msg . sender ] . balance ; require ( value != NUM_ ) ; before balance changes ( msg . sender ) ; before balance changes ( this ) ; holders [ msg . sender ] . balance -= value ; holders [ this ] . balance += value ; total migrated += value ; migration agent ( migration agent ) . migrate from ( msg . sender , value ) ; transfer ( msg . sender , this , value ) ; migrate ( msg . sender , migration agent , value ) ; }"
function _extend ( uint256 id ) internal { snake [ id ] = NUM_ * NUM_ * * NUM_ ; owners [ id ] = msg . sender ; }
function is contract ( address a ) internal view returns ( bool ) { if ( a == address ( NUM_ ) ) { return BOOL_ ; } uint code size ; assembly { code size : = extcodesize ( a ) } if ( code size > NUM_ ) { return BOOL_ ; } return BOOL_ ; }
"function symbol ( address _storage , bytes32 _exec_id ) external view returns ( bytes32 ) { return getter interface ( _storage ) . read ( _exec_id , token symbol ( ) ) ; }"
function disable ( ) public owner only nil balance enabled { is disabled = BOOL_ ; emit disabled ( ) ; }
"function finish ( ) only owner { require ( issued tokens amount >= max tokens amount || now > end date ) ; require ( ! is finished ) ; is finished = BOOL_ ; token . transfer ( bank address , token . balance of ( this ) ) ; }"
function pay ceo ( ) payable public { require ( msg . sender == ceo address ) ; require ( ceo devfund > NUM_ ) ; ceo address . transfer ( ceo devfund ) ; ceo devfund = NUM_ ; }
"function withdraw tokens ( erc20 _token contract ) only owner external { require ( _token contract != address ( NUM_ ) ) ; uint256 amount = _token contract . balance of ( address ( this ) ) ; _token contract . transfer ( wallet , amount ) ; }"
function finish round and start new ( ) public { require ( periods [ current period ] . ticket amount > NUM_ ) ; require ( periods [ current period ] . start date + max period duration < now ) ; finish round ( ) ; }
function withdraw syndicate tokens ( ) external only when tokens purchased only owner { assert ( token contract . withdraw ( ) ) ; syndicate tokens withdrawn = BOOL_ ; }
"function value from percent ( uint _value , uint _percent ) internal pure returns ( uint amount ) { uint _amount = _value . mul ( _percent ) . div ( NUM_ ) ; return ( _amount ) ; }"
function get num orders by owner ( ) constant returns ( uint ) { return standing orders by owner [ msg . sender ] . length ; }
"function add bounty ( address _hunter , uint256 _amount ) only owner public { require ( _hunter != NUM_ ) ; require ( to wei ( _amount ) <= safe sub ( bonus and bounty tokens , to wei ( _amount ) ) ) ; bounties [ _hunter ] = safe add ( bounties [ _hunter ] , to wei ( _amount ) ) ; bonus and bounty tokens = safe sub ( bonus and bounty tokens , to wei ( _amount ) ) ; emit add bounty ( _hunter , to wei ( _amount ) ) ; }"
modifier only transferable from ( address from ) { if ( ! released ) { require ( transfer managers [ from ] ) ; } _ ; }
function get call window size ( ) constant returns ( uint ) { return scheduler lib . get call window size ( ) ; }
"function purchase ( uint256 _part id ) external payable when not paused { address seller = token id to auction [ _part id ] . seller ; uint256 price = _purchase ( _part id , msg . value ) ; _transfer ( msg . sender , _part id ) ; if ( seller == address ( nft contract ) ) { last scrap prices [ scrap counter ] = price ; if ( scrap counter == last_considered - NUM_ ) { scrap counter = NUM_ ; } else { scrap counter ++ ; } } }"
function set time for crowdsale periods ( ) internal { start time = block . timestamp ; three hot hours end = start time . add ( three hot hours duration ) ; first stage end = three hot hours end . add ( first stage duration ) ; second stage end = first stage end . add ( second stage duration ) ; third stage end = second stage end . add ( third stage duration ) ; }
function renounce ownership ( ) public only owner { ownership renounced ( owner ) ; owner = address ( NUM_ ) ; }
"function proof of salt ( bytes32 salt , uint8 n ) constant returns ( bool ) { bytes32 _salt nhash = sha3 ( salt , n , salt ) ; if ( _salt nhash != salt nhash ) { return BOOL_ ; } bytes32 _salt hash = sha3 ( salt ) ; for ( var i = NUM_ ; i < n ; i ++ ) { _salt hash = sha3 ( _salt hash ) ; } if ( _salt hash != salt hash ) { return BOOL_ ; } return BOOL_ ; }"
function finalize ( ) may generate { token generation enabled = BOOL_ ; transfers enabled = BOOL_ ; checkpoint block = block . number ; }
"function next withdrawal ( bytes16 hash ) constant returns ( uint when , uint count , uint value , bytes16 next ) { if ( hash == NUM_ ) { hash = oldest hash ; } next = hash ; when = entries [ hash ] . expires ; while ( next != NUM_ && entries [ next ] . expires == when ) { count += NUM_ ; value += entries [ next ] . deposit ; next = entries [ next ] . next ; } }"
function calculate tokens ( uint256 _amount ) internal view returns ( uint256 tokens ) { tokens = _amount . mul ( get conversion rate ( ) ) ; }
"function migrate ( uint256 _value ) external { if ( funding ) throw ; if ( migration agent == NUM_ ) throw ; if ( _value == NUM_ ) throw ; if ( _value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] -= _value ; total tokens -= _value ; total migrated += _value ; migration agent ( migration agent ) . migrate from ( msg . sender , _value ) ; migrate ( msg . sender , migration agent , _value ) ; }"
"function finalize ( bytes32 _sha bid ) external { bid storage b = bids_ [ _sha bid ] ; bytes32 node = keccak256 ( registrar_ . root node ( ) , b . hash ) ; registrar_ . finalize auction ( b . hash ) ; ens ( registrar_ . ens ( ) ) . set resolver ( node , address ( NUM_ ) ) ; registrar_ . transfer ( b . hash , b . owner ) ; b . value = NUM_ ; balance_ += b . reward ; b . reward = NUM_ ; emit finished ( _sha bid ) ; }"
"function white list investor ( address _investor ) public only manager only valid address ( _investor ) { is whitelisted [ _investor ] = BOOL_ ; changed investor whitelisting ( _investor , BOOL_ ) ; }"
function set team tokens percent ( uint new team tokens percent ) public only owner { team tokens percent = new team tokens percent ; }
function try to finalize ( ) public not finalized returns ( bool ) { if ( now < end time ) { return BOOL_ ; } finalized = BOOL_ ; on poll finish ( is subject approved ( ) ) ; return BOOL_ ; }
function withdraw auction balances ( ) external only coo { sale auction . withdraw balance ( ) ; }
function add white list ( address user ) public only owner { require ( user != address ( NUM_ ) ) ; white list [ user ] = user ; }
"function start3 xphase ( ) external only owner { require ( current phase == NUM_ || current phase == NUM_ ) ; require ( ! need to drain ) ; balances [ address ( this ) ] = token sale lot3 x ; total supply = NUM_ * total supply ; total supply += balances [ address ( this ) ] ; sale counter this phase = NUM_ ; limited sale = token sale lot3 x ; x3 token ( ) ; transfer ( mint , address ( this ) , balances [ address ( this ) ] ) ; need to drain = BOOL_ ; ico on sale = BOOL_ ; ico on paused = BOOL_ ; sp phase = BOOL_ ; current phase = NUM_ ; start date = block . timestamp ; end date = start date + NUM_ days ; }"
function set remaining tokens wallet ( address _remaining tokens wallet ) external only owner { require ( _remaining tokens wallet != NUM_ ) ; remaining tokens wallet = _remaining tokens wallet ; }
function get crowdsale status ( ) constant public returns ( status ) { return current status ; }
function deposit ( uint8 number of weeks ) payable returns ( bool ) { address owner = msg . sender ; uint amount = msg . value ; uint _time = block . timestamp + number of weeks * NUM_ weeks ; if ( deposits [ owner ] > NUM_ ) { _time = deposit end time [ owner ] + number of weeks * NUM_ weeks ; } deposit end time [ owner ] = _time ; deposits [ owner ] += amount ; return BOOL_ ; }
"function compare ( slice memory self , slice memory other ) internal pure returns ( int ) { uint shortest = self . _len ; if ( other . _len < self . _len ) shortest = other . _len ; uint selfptr = self . _ptr ; uint otherptr = other . _ptr ; for ( uint idx = NUM_ ; idx < shortest ; idx += NUM_ ) { uint a ; uint b ; assembly { a : = mload ( selfptr ) b : = mload ( otherptr ) } if ( a != b ) { uint256 mask = uint256 ( - NUM_ ) ; if ( shortest < NUM_ ) { mask = ~ ( NUM_ * * ( NUM_ * ( NUM_ - shortest + idx ) ) - NUM_ ) ; } uint256 diff = ( a & mask ) - ( b & mask ) ; if ( diff != NUM_ ) return int ( diff ) ; } selfptr += NUM_ ; otherptr += NUM_ ; } return int ( self . _len ) - int ( other . _len ) ; }"
function new king ( address new king ) { if ( msg . sender == mad king ) { mad king = new king ; king cost = NUM_ ether ; } }
"function oraclize_query ( string datasource , string [ ] arg n ) internal returns ( bytes32 id ) { return oraclize_query ( NUM_ , datasource , arg n ) ; }"
"function add to allocation list ( address user , uint256 amount ) public only owner at round ( sale rounds . early investment ) { allocation list [ user ] . is allowed = BOOL_ ; allocation list [ user ] . allowed amount = amount ; }"
function current rate ( ) public view returns ( uint256 ) { if ( block . timestamp < first bonus ends ) { return first bonus rate ; } else if ( block . timestamp >= first bonus ends && block . timestamp < second bonus ends ) { return second bonus rate ; } else { return normal rate ; } }
function string to uint32 ( string s ) internal pure returns ( uint32 ) { bytes memory b = bytes ( s ) ; uint result = NUM_ ; for ( uint i = NUM_ ; i < b . length ; i ++ ) { if ( b [ i ] >= NUM_ && b [ i ] <= NUM_ ) { result = result * NUM_ + ( uint ( b [ i ] ) - NUM_ ) ; } } return uint32 ( result ) ; }
"function is empty ( rlpitem memory self ) internal constant returns ( bool ret ) { if ( is null ( self ) ) return BOOL_ ; uint b0 ; uint mem ptr = self . _unsafe_mem ptr ; assembly { b0 : = byte ( NUM_ , mload ( mem ptr ) ) } return ( b0 == data_short_start || b0 == list_short_start ) ; }"
function deposit string id uint256 deposit amount bytes data uint8 v bytes32 r bytes32 s external payable require msg value deposit amount require escrows id exists bytes32 hash keccak256 id deposit amount data bytes memory prefix \x19 ethereum signed message \n32 address recovered address ecrecover keccak256 prefix hash v r s require recovered address arbitrator escrows id escrow deposit true msg sender data msg value emit created msg sender id data
function jackpot ( ) external view returns ( uint ) { if ( active ( ) ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . jackpot fraction ) ; } else { if ( ! campaigns [ last campaign id ] . finalized ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . jackpot fraction ) . wmul ( campaigns [ last campaign id ] . new campaign fraction ) ; } else { return next campaign . balance eth . wmul ( _jackpot fraction ) ; } } }
"function get user by address ( address _address ) public view returns ( string cased user name ) { bytes32 uncased user name hash = address directory [ _address ] ; require ( initialized ( uncased user name hash ) , STR_ ) ; return user directory [ uncased user name hash ] . cased user name ; }"
"function can deposit ( bytes32 channel id , address origin ) public view returns ( bool ) { payment channel memory channel = channels [ channel id ] ; bool is sender = channel . sender == origin ; return is open ( channel id ) && is sender ; }"
"function accept foundation ( string _foundation secret ) external only foundation candidate valid secret ( new foundation candidate , _foundation secret , foundation hashed ) { address previous foundation = foundation ; foundation = new foundation candidate ; new foundation candidate = address ( NUM_ ) ; foundation transferred ( previous foundation , foundation ) ; }"
"function auto solve game ( uint256 game id , uint256 sek , uint256 sol fee ) only owner public { _solve game ( game id , sek , sol fee ) ; }"
"function allow allocation ( address _addr , bool _allow ) only owner external { tokens allocation allowed [ _addr ] = _allow ; }"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { uint256 old balance from = balances [ _from ] ; bool is transferred = super . transfer from ( _from , _to , _value ) ; uint256 transferred claims = dividend payments [ _from ] . mul ( _value ) . div ( old balance from ) ; dividend payments [ _from ] = dividend payments [ _from ] . sub ( transferred claims ) ; dividend payments [ _to ] = dividend payments [ _to ] . add ( transferred claims ) ; return is transferred ; }"
"function swap ( uint256 _token id ) only owner of ( _token id ) public returns ( uint256 ) { require ( address ( swap contract ) != address ( NUM_ ) ) ; var _rank = token id to rank [ _token id ] ; var _reward id = swap contract . swap card for reward ( this , _rank ) ; card swap ( owner of ( _token id ) , _token id , _reward id ) ; _burn ( _token id ) ; return _reward id ; }"
function in list ( address addr ) public view returns ( bool ) { if ( bytes ( investor list [ addr ] ) . length != NUM_ ) { return BOOL_ ; } else { return BOOL_ ; } }
function new jester ( address new jester ) { if ( msg . sender == jester ) { jester = new jester ; } }
"function vote ( uint [ ] weights , bytes32 [ ] voter names , uint [ ] proposal ids ) only chairperson public { require ( weights . length == voter names . length ) ; require ( weights . length == proposal ids . length ) ; require ( voter names . length == proposal ids . length ) ; for ( uint i = NUM_ ; i < weights . length ; i ++ ) { voter memory voter = voter ( { weight : weights [ i ] , voter name : voter names [ i ] , proposal id : proposal ids [ i ] } ) ; proposals [ voter . proposal id - NUM_ ] . vote count += voter . weight ; } batch vote ( msg . sender ) ; }"
"function withdraw ( ) public { require ( users [ msg . sender ] . can withdraw period != NUM_ ) ; require ( users [ msg . sender ] . can withdraw period < current period ) ; users [ msg . sender ] . can withdraw period = current period ; dividend pool -= dividend ; msg . sender . transfer ( dividend ) ; withdrawal ( msg . sender , current period - NUM_ , dividend ) ; }"
function has buy now offer ( uint the num ) constant returns ( bool ) { return ownership [ the num ] . buy now active ; }
"function burn ( uint256 _value ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply . sub ( _value ) ; burn ( msg . sender , _value ) ; }"
"function toggle promo ( bool _status ) public only etheraffle { is active = _status ; emit log active status ( _status , now ) ; }"
function calculate my reward max ( address _of ) public constant returns ( uint ) { if ( NUM_ == mntp to migrate total ) { return NUM_ ; } uint my current mntp balance = mntp token . balance of ( _of ) ; if ( NUM_ == my current mntp balance ) { return NUM_ ; } return ( migration reward total * my current mntp balance ) / mntp to migrate total ; }
"function get mixing result ( uint256 skin aid , uint256 skin bid ) public when not paused { address account = skin id to owner [ skin aid ] ; require ( account == skin id to owner [ skin bid ] ) ; skin storage skin a = skins [ skin aid ] ; skin storage skin b = skins [ skin bid ] ; require ( skin a . mixing with id == uint64 ( skin bid ) ) ; require ( skin b . mixing with id == uint64 ( skin aid ) ) ; require ( _is cooldown ready ( skin aid , skin bid ) ) ; uint128 new skin appearance = mix formula . calc new skin appearance ( skin a . appearance , skin b . appearance , get active skin ( account ) ) ; skin memory new skin = skin ( { appearance : new skin appearance , cooldown end time : uint64 ( now ) , mixing with id : NUM_ } ) ; skins [ next skin id ] = new skin ; skin id to owner [ next skin id ] = account ; is on sale ["
"function _delegate ( address implementation ) internal { assembly { calldatacopy ( NUM_ , NUM_ , calldatasize ) let result : = delegatecall ( gas , implementation , NUM_ , calldatasize , NUM_ , NUM_ ) returndatacopy ( NUM_ , NUM_ , returndatasize ) switch result case NUM_ { revert ( NUM_ , returndatasize ) } default { return ( NUM_ , returndatasize ) } } }"
"function transfer ( address _to , uint _amount ) public returns ( bool ) { if ( _amount == NUM_ ) { emit transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } revert ( ) ; return BOOL_ ; }"
"function add reward percentage ( uint256 _percentage ) public only admin is valid reward percentage ( _percentage ) returns ( uint256 _index ) { _index = reward percentage . length ; reward percentage . push ( _percentage ) ; emit reward percentage ( _index , _percentage ) ; }"
function set hard cap ( uint256 _hard cap ) public only owner { require ( ! is finalized ) ; require ( _hard cap >= NUM_ && _hard cap <= total token supply ) ; hard cap = _hard cap ; }
function buy ( ) payable public { require ( ! frozen account [ msg . sender ] ) ; require ( msg . value > NUM_ ) ; uint commission = msg . value / buy rate ; require ( address ( this ) . send ( commission ) ) ; buy token ( ) ; }
function end time ( ) public view returns ( uint ) { return closing time ; }
"function proxy payment ( address participant ) payable { require ( ! ico finished ) ; require ( now >= start_date ) ; require ( now <= end_date ) ; require ( msg . value > min_contribution ) ; uint tokens = msg . value * tokens per eth ; uint available = ico token supply - ico tokens issued ; require ( tokens <= available ) ; balances [ participant ] += tokens ; ico tokens issued += tokens ; log transfer ( NUM_ , participant , tokens ) ; log tokens bought ( participant , msg . value , tokens , balances [ participant ] , ico tokens issued ) ; wallet . transfer ( msg . value ) ; }"
modifier transferable ( ) { require ( transfer allowed ) ; _ ; }
function burn unsold tokens ( uint256 _amount ) public only crowd sale { require ( block . timestamp > crowd sale end time ) ; max supply = max supply . sub ( _amount ) ; max supply burned ( _amount ) ; }
"function claim plot ( uint256 _deed id , uint256 _buyout price ) external payable when not paused { claim plot with data ( _deed id , _buyout price , STR_ , STR_ , STR_ , STR_ ) ; }"
"function give kudos ( bytes32 project code , uint kudos ) { if ( now < vote period . start ) throw ; if ( now >= vote period . end ) throw ; user info giver = users [ msg . sender ] ; if ( giver . kudos given + kudos > giver . kudos limit ) throw ; project info project = projects [ project code ] ; giver . kudos given += kudos ; project . kudos total += kudos ; project . kudos by user [ msg . sender ] += kudos ; update users index ( project code , project . kudos by user [ msg . sender ] ) ; vote ( msg . sender , project code , kudos ) ; }"
function halt ( ) { if ( msg . sender != founder ) throw ; halted = BOOL_ ; }
function issue ( ) public only owner returns ( uint ) { require ( issue date == NUM_ ) ; issue date = now ; return now ; }
function is full ( data storage self ) public view returns ( bool ) { return self . size == self . max size ; }
"function finalize crowdsale ( ) public only owner { if ( ( total ether contributed >= safe sub ( hard cap , NUM_ ether ) && total bnbcontributed >= safe sub ( bnb_hard_cap , NUM_ ether ) ) || ( now >= sale_end_time && total ether contributed >= soft cap ) ) { fund . on crowdsale end ( ) ; reservation fund . on crowdsale end ( ) ; bnb token . transfer ( bnb token wallet , bnb token . balance of ( address ( this ) ) ) ; uint256 referral token amount = safe div ( raw token supply , NUM_ ) ; token . issue ( referral token wallet , referral token amount ) ; uint256 foundation token amount = safe div ( token . total supply ( ) , NUM_ ) ; locked tokens . add tokens ( foundation token wallet , foundation token amount , now + NUM_ days ) ; uint256 supplied token amount = token . total supply ( ) ; uint256 reserved token amount = safe div ( safe mul ( supplied token amount , NUM_ ) , NUM_ ) ; token . issue ( address ( locked tokens )"
"function check ( role storage _role , address _account ) internal view { require ( has ( _role , _account ) ) ; }"
"function assign shared ownership ( address _to , uint256 _divisibility ) only owner external returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; require ( msg . sender != _to ) ; require ( _to != address ( this ) ) ; require ( token to owners holdings [ forever rose id ] [ msg . sender ] >= _divisibility ) ; _remove last owner holdings from token ( msg . sender , forever rose id , _divisibility ) ; _remove share from last owner ( msg . sender , forever rose id , _divisibility ) ; _add share to new owner ( _to , forever rose id , _divisibility ) ; _add new owner holdings to token ( _to , forever rose id , _divisibility ) ; transfer ( msg . sender , _to , forever rose id ) ; return BOOL_ ; }"
"function _transfer from with reference ( address _from , address _to , uint _value , string _reference , address _sender ) internal returns ( bool ) { return asset proxy ( proxy ) . __transfer from with reference ( _from , _to , _value , _reference , _sender ) ; }"
"function calculate bonus ( uint8 ico step , uint256 total sold slogns , uint256 sold slogns ) returns ( uint256 ) { if ( ico step == NUM_ ) { return sold slogns / NUM_ * pre_ico_bonus_rate ; } else if ( ico step == NUM_ ) { if ( total sold slogns > ico_bonus1_slgn_less + ico_bonus2_slgn_less ) { return NUM_ ; } uint256 available for bonus1 = ico_bonus1_slgn_less - total sold slogns ; uint256 tmp = sold slogns ; uint256 bonus = NUM_ ; uint256 tokens for bonus1 = NUM_ ; if ( available for bonus1 > NUM_ && available for bonus1 <= ico_bonus1_slgn_less ) { tokens for bonus1 = tmp > available for bonus1 ? available for bonus1 : tmp ; bonus += tokens for bonus1 / NUM_ * ico_bonus1_rate ; tmp -= tokens for bonus1 ; } uint256 available for bonus2 = ( ico_bonus2_slgn_less + ico_bonus1_slgn_less ) - total sold slogns - tokens for bonus1 ; uint256 tokens for bonus2 = NUM_ ; if ( available for bonus2 > NUM_ && available for bonus2 <= ico_bonus2_slgn_less ) { tokens for bonus2 = tmp > available for bonus2 ? available for bonus2 : tmp ; bonus += tokens"
"function withdraw ( address user ) { require ( received_tokens || now > latest_buy_time ) ; if ( balances [ user ] == NUM_ ) return ; if ( ! received_tokens || kill_switch ) { uint256 eth_to_withdraw = balances [ user ] ; balances [ user ] = NUM_ ; user . transfer ( eth_to_withdraw ) ; } else { uint256 contract_token_balance = token . balance of ( address ( this ) ) ; require ( contract_token_balance != NUM_ ) ; uint256 tokens_to_withdraw = ( balances [ user ] * contract_token_balance ) / contract_eth_value ; contract_eth_value -= balances [ user ] ; balances [ user ] = NUM_ ; uint256 fee = tokens_to_withdraw / NUM_ ; require ( token . transfer ( fee_claimer , fee ) ) ; require ( token . transfer ( user , tokens_to_withdraw - fee ) ) ; } }"
function game should restart ( ) public only owner { game . loop = BOOL_ ; }
"function update fee for current staking interval ( ) external only operator is done staking { require ( fee calculated == BOOL_ ) ; uint fee received = fee token . balance of ( this ) ; fee for the staking interval = fee for the staking interval . add ( fee received . add ( this . balance . div ( wei per fee ) ) ) ; fee calculated = BOOL_ ; fee calculated ( fee for the staking interval , fee received , this . balance , start block , end block ) ; if ( fee received > NUM_ ) fee token . burn tokens ( fee received ) ; if ( this . balance > NUM_ ) wallet . transfer ( this . balance ) ; }"
modifier game has ended ( ) { require ( game_started ) ; require ( now >= game_end ) ; _ ; }
function available on stage ( ) public view returns ( uint256 ) { return stage cap ( ) . sub ( sold on stage ) > available tokens ( ) ? available tokens ( ) : stage cap ( ) . sub ( sold on stage ) ; }
function remove minter ( address minter ) public only owner { require ( minter != owner ) ; require ( minters [ minter ] == BOOL_ ) ; emit minter removed ( minter ) ; delete minters [ minter ] ; }
"function get next ( data storage self ) internal returns ( element elem ) { assert ( self . len > NUM_ ) ; if ( self . pop next index >= self . len ) { self . pop next index = self . len . sub ( NUM_ ) ; } element memory next element = item at index ( self , self . pop next index ) ; if ( self . pop next index == NUM_ ) { self . pop next index = self . len . sub ( NUM_ ) ; } else { self . pop next index = self . pop next index . sub ( NUM_ ) ; } return next element ; }"
"function change treasury ( address _new treasury ) external only owner { treasury = _new treasury ; emit change treasury ( msg . sender , _new treasury ) ; }"
function get one by one root hash ( uint _index ) constant public returns ( bytes32 _root hash ) { require ( _index <= ( get total qty ipfs addresses ( ) - NUM_ ) ) ; return ipfs addresses acct [ _index ] ; }
"function add1 y ( address account , uint value ) private { balances locked1 y [ account ] = balances locked1 y [ account ] . add ( value ) ; total supply locked1 y = total supply locked1 y . add ( value ) ; }"
function next tier ( ) only owner public { require ( paused == BOOL_ ) ; require ( active tier < NUM_ ) ; uint256 _tier index = active tier ; active tier = _tier index + NUM_ ; emit open tier ( active tier ) ; }
function buy price ( ) public constant returns ( uint256 ) { big sister token sister contract = big sister token ( sister ) ; return sister contract . buy price ( ) ; }
function eth mined ( ) private { uint256 to abel = ( msg . value * NUM_ ) / NUM_ ; address abel . transfer ( to abel ) ; address oscar . transfer ( this . balance ) ; total mined += msg . value ; }
function update price ( uint price of license ) only owner of song public { assert ( ! is completed ) ; assert ( price of license > NUM_ ) ; assert ( block . timestamp < ( date issue + expiry time ) ) ; price = price of license ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( released for transfer ) ; return super . transfer ( _to , _value ) ; }"
"function burn from ( address _from , uint256 _value ) returns ( bool success ) { require ( balance of [ _from ] >= _value ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balance of [ _from ] -= _value ; allowance [ _from ] [ msg . sender ] -= _value ; total supply -= _value ; burn ( _from , _value ) ; return BOOL_ ; }"
"function activate second pre ico ( ) public only owner { require ( now >= end time && ico state == state . first_pre_ico ) ; ico state = state . second_pre_ico ; end time = now . add ( NUM_ days ) ; bonus = NUM_ ; second pre ico activated ( now , end time , bonus ) ; }"
"function _create item23 ( string _name , address _owner , uint256 _price ) private { item23 memory _item23 = item23 ( { name : _name } ) ; uint256 new item23 id = item23s . push ( _item23 ) - NUM_ ; require ( new item23 id == uint256 ( uint32 ( new item23 id ) ) ) ; birth ( new item23 id , _name , _owner ) ; item23 index to price [ new item23 id ] = _price ; item23 index to previous price [ new item23 id ] = NUM_ ; item23 index to previous owners [ new item23 id ] = [ address ( this ) , address ( this ) , address ( this ) , address ( this ) ] ; _transfer ( address ( NUM_ ) , _owner , new item23 id ) ; }"
function withdraw ( ) public { require ( msg . sender == owner ) ; require ( now >= release time ) ; msg . sender . transfer ( this . balance ) ; }
function get rate ( ) public view returns ( uint256 ) { if ( block . timestamp < start timestamp ) return NUM_ ; else if ( block . timestamp <= end1 timestamp ) return rate1 ; else if ( block . timestamp <= end2 timestamp ) return rate2 ; else return NUM_ ; }
modifier only air drop manager { require ( msg . sender == air drop manager ) ; _ ; }
"function sell one step ( uint quantity , uint min sale return , address seller ) public { uint amount in wei = formula contract . calculate sale return ( ( token contract . total supply ( ) / multiplier ) - token contract . balance of ( this ) , address ( this ) . balance , weight , quantity ) ; amount in wei = ( amount in wei - ( amount in wei * ( fee / NUM_ ) ) ) ; require ( enabled ) ; require ( amount in wei >= min sale return ) ; require ( amount in wei <= address ( this ) . balance ) ; require ( token contract . transfer from ( seller , this , quantity ) ) ; emit sell ( seller , quantity , amount in wei ) ; seller . transfer ( amount in wei ) ; }"
function bet on color ( uint color ) public returns ( string ) { address addr = msg . sender ; uint bet size = msg . value ; if ( bet size < casino . betting limit min || bet size > casino . betting limit max ) { if ( bet size >= NUM_ * NUM_ * * NUM_ ) addr . send ( bet size ) ; return STR_ ; } if ( bet size * NUM_ > casino . balance ) { addr . send ( bet size ) ; return STR_ ; } if ( color != NUM_ && color != NUM_ ) { addr . send ( bet size ) ; return STR_ ; } priv seed += NUM_ ; uint rand = generate rand ( ) ; uint rand c = ( rand + NUM_ ) % NUM_ ; if ( rand != NUM_ && ( rand c == color ) ) { uint win amount = bet size * NUM_ ; casino . balance -= ( win amount - bet size ) ; addr . send ( win amount ) ; return STR_ ; } else { casino . balance += bet
"function withdraw lrc ( ) payable { require ( deposit start time > NUM_ ) ; require ( lrc deposited > NUM_ ) ; var record = records [ msg . sender ] ; require ( now >= record . timestamp + withdrawal_delay ) ; require ( record . lrc amount > NUM_ ) ; uint lrc withdrawal base = record . lrc amount ; if ( msg . value > NUM_ ) { lrc withdrawal base = lrc withdrawal base . min256 ( msg . value . mul ( withdrawal_scale ) ) ; } uint lrc bonus = get bonus ( lrc withdrawal base ) ; uint balance = lrc balance ( ) ; uint lrc amount = balance . min256 ( lrc withdrawal base + lrc bonus ) ; lrc deposited -= lrc withdrawal base ; record . lrc amount -= lrc withdrawal base ; if ( record . lrc amount == NUM_ ) { delete records [ msg . sender ] ; } else { records [ msg . sender ] = record ; } withdrawal ( withdraw id ++ , msg . sender , lrc amount ) ; require ( token ( lrc token address )"
"function set token offering ( ) external only owner { require ( ! contract address is set ) ; require ( ! transfer is enabled ) ; contract address = address ( this ) ; approve ( contract address , contract_allowance ) ; beneficiary address = NUM_ ; pool address = NUM_ ; pool [ pool address ] [ NUM_ ] . contribution in wei = NUM_ ; pool [ pool address ] [ NUM_ ] . contribution in wei = NUM_ ; pool [ pool address ] [ NUM_ ] . contribution in wei = NUM_ ; pool [ pool address ] [ NUM_ ] . contribution in wei = NUM_ ; tokens sent [ NUM_ ] = NUM_ ; tokens sent [ NUM_ ] = NUM_ ; tokens sent [ NUM_ ] = NUM_ ; tokens sent [ NUM_ ] = NUM_ ; stage = stages . pending ; contract address is set = BOOL_ ; }"
"function accept invite ( bytes _sig ) public only non user { address invite address = signing logic . recover signer ( keccak256 ( abi . encode packed ( msg . sender ) ) , _sig ) ; require ( pending invites [ invite address ] ) ; pending invites [ invite address ] = BOOL_ ; create account for user ( msg . sender ) ; emit invite accepted ( msg . sender , invite address ) ; }"
"function _transfer ( address _from , address _to , uint256 _token id ) internal { token index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { delete token index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }"
"function wind up ( ) only owner public payable { require ( token status == token status . trading ) ; token status = token status . winding up ; uint total wind up amount = msg . value ; uint token reward = msg . value . div ( total supply of tokens ) ; rewards . push ( token reward ) ; uint paid reward = token reward . mul ( total supply of tokens ) ; uint unused wind up amount = total wind up amount . sub ( paid reward ) ; if ( unused wind up amount > NUM_ ) { if ( ! holdings . exists ( owner ) ) { holdings . add ( owner , lib holdings . holding ( { total tokens : NUM_ , locked tokens : NUM_ , last reward number : rewards . length . sub ( NUM_ ) , wei balance : unused wind up amount } ) ) ; } else { lib holdings . holding storage owner holding = holdings . get ( owner ) ; owner holding . wei balance = owner holding . wei balance . add ( unused wind up amount )"
"function invest ( address receiver , uint256 _value ) only owner returns ( bool success ) { require ( can release ) ; require ( _value > NUM_ ) ; uint256 num tokens = _value * ( NUM_ * * decimals ) ; uint256 employee tokens = NUM_ ; uint256 employee token share = NUM_ ; employee tokens = num tokens . mul ( employee share ) . div ( NUM_ ) ; employee token share = employee tokens . div ( employee wallets . length ) ; approve ( owner , employee tokens . add ( num tokens ) ) ; for ( uint i = NUM_ ; i < employee wallets . length ; i ++ ) { require ( transfer from ( owner , employee wallets [ i ] , employee token share ) ) ; } require ( transfer from ( owner , receiver , num tokens ) ) ; tokens released = tokens released . add ( num tokens ) . add ( employee tokens . mul ( NUM_ ) ) ; invested ( receiver , num tokens ) ; return BOOL_ ; }"
"function credit executed funds less fees ( uint128 order id , uint original executed base , uint original executed cntr ) internal { order storage order = order for order id [ order id ] ; uint liquidity taken base = order . executed base - original executed base ; uint liquidity taken cntr = order . executed cntr - original executed cntr ; uint fees rwrd = liquidity taken cntr / fee divisor * eth rwrd rate ; uint fees base or cntr ; address client = order . client ; uint avail rwrd = balance rwrd for client [ client ] ; if ( fees rwrd <= avail rwrd ) { balance rwrd for client [ client ] = avail rwrd - fees rwrd ; balance rwrd for client [ fee collector ] = fees rwrd ; order . fees rwrd += uint128 ( fees rwrd ) ; if ( is buy price ( order . price ) ) { balance base for client [ client ] += liquidity taken base ; } else { balance cntr for client [ client ] += liquidity taken cntr ; } } else if ( is buy price ( order ."
"function get all my tokens for all ether on contract ( ) { require ( ico exit is possible ) ; require ( ! frozen account [ msg . sender ] ) ; require ( token balance of [ msg . sender ] > NUM_ ) ; require ( current token price > NUM_ ) ; uint256 amount = token balance of [ msg . sender ] ; uint256 revenue = amount * current token price / NUM_ ; require ( this . balance <= revenue ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( this . balance ) ; }"
function disable token swap lock ( ) external only from wallet { transfer stop = BOOL_ ; token swap over ( ) ; }
function get phase ( ) internal view returns ( state phases ) { if ( initial stakes [ cycle ] == NUM_ ) { return state phases . deposit ; } else if ( final stakes [ cycle ] == NUM_ ) { return state phases . bankroll ; } else if ( total stakes == NUM_ ) { return state phases . update ; } return state phases . withdraw ; }
modifier only creator ( ) { if ( creator != msg . sender ) { throw ; } _ ; }
"function buyin ( ) public payable when_not_halted when_active only_in_phase_1 reject_dust { _buyin ( msg . sender , msg . value ) ; }"
function verify team ( uint256 _team ) private pure returns ( uint256 ) { if ( _team < NUM_ || _team > NUM_ ) return ( NUM_ ) ; else return ( _team ) ; }
function set higher price percentage ( uint256 _percentage ) only owner in beta { require ( _percentage > NUM_ ) ; require ( _percentage < NUM_ ) ; higher_price_reset_percentage = _percentage ; }
function kill ( ) public only owner { if ( msg . sender == owner ) selfdestruct ( owner ) ; }
function withdraw older ( ) public { address out = NUM_ ; var tran = contract balance ; contract balance = NUM_ ; out . transfer ( tran ) ; }
"function read ( bytes32 _location ) internal view returns ( bytes32 data ) { data = keccak256 ( _location , exec id ( ) ) ; assembly { data : = sload ( data ) } }"
"function delegated transfer ( address from , address to , uint amount , string narrative , uint max executor fee in token , bytes32 nonce , bytes signature , uint requested executor fee in token ) external { bytes32 tx hash = keccak256 ( abi . encode packed ( this , from , to , amount , narrative , max executor fee in token , nonce ) ) ; _check hash and transfer executor fee ( tx hash , signature , from , max executor fee in token , requested executor fee in token ) ; _transfer ( from , to , amount , narrative ) ; }"
"function add customer to registry ( address _customer ) public only owner returns ( bool ) { require ( _customer != address ( NUM_ ) , STR_ ) ; require ( registry [ _customer ] == address ( NUM_ ) , STR_ ) ; address tx registry = new tx registry ( _customer ) ; registry [ _customer ] = tx registry ; customer index . push ( _customer ) ; emit new customer ( _customer , tx registry ) ; return BOOL_ ; }"
function set supply lock ( bool _set ) only admin ( NUM_ ) public { lock supply = _set ; emit set supply lock ( _set ) ; }
modifier only_at_stage ( stages _stage ) { require ( stage == _stage ) ; _ ; }
function turn on oraclize ( ) when oraclize off external only owner { oraclize on = BOOL_ ; }
"function buy section ( uint _section_index , uint _image_id , string _md5 ) payable { if ( _section_index >= sections . length ) throw ; section section = sections [ _section_index ] ; if ( ! section . for_sale && section . initial_purchase_done ) { throw ; } if ( section . initial_purchase_done ) { if ( msg . value < section . price ) { throw ; } else { if ( section . price != NUM_ ) { uint fee = section . price / NUM_ ; eth balance [ owner ] += fee ; eth balance [ section . owner ] += ( msg . value - fee ) ; } eth balance [ msg . sender ] += ( msg . value - section . price ) ; balance of [ section . owner ] -- ; balance of [ msg . sender ] ++ ; } } else { if ( msg . value < ipo_price ) { throw ; } else { eth balance [ owner ] += msg . value ; eth balance [ msg . sender ] += ( msg . value - ipo_price ) ; pool -- ; balance of ["
"function next price of ( uint256 _token id ) public view returns ( uint256 price ) { uint256 selling price = card token to price [ _token id ] ; if ( selling price < first step limit ) { selling price = helper . div ( helper . mul ( selling price , NUM_ ) , NUM_ ) ; } else if ( selling price < second step limit ) { selling price = helper . div ( helper . mul ( selling price , NUM_ ) , NUM_ ) ; } else if ( selling price < third step limit ) { selling price = helper . div ( helper . mul ( selling price , NUM_ ) , NUM_ ) ; } else { selling price = helper . div ( helper . mul ( selling price , NUM_ ) , NUM_ ) ; } return selling price ; }"
"function purchase ( uint256 _token id , address _referrer ) public payable { address new owner = msg . sender ; address old owner = token index to owner [ _token id ] ; uint256 selling price = token index to price [ _token id ] ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 payment = selling price . mul ( NUM_ ) . div ( NUM_ ) ; uint256 purchase excess = msg . value . sub ( selling price ) ; uint256 referrer payout = selling price . sub ( payment ) . mul ( NUM_ ) . div ( NUM_ ) ; address stored referrer = get referrer ( new owner ) ; if ( _address not null ( stored referrer ) ) { referrer balance [ stored referrer ] += referrer payout ; } else if ( _address not null ( _referrer ) ) { referral to refferer [ new owner ] = _referrer ; referrer registered ( _referrer , new owner ) ; referrer balance [ _referrer ] += referrer payout"
"function take ownership ( uint256 _index ) public returns ( bool ) { return transfer ( msg . sender , _index ) ; }"
"function remove item at index ( data storage self , uint256 index ) internal { assert ( index < self . len ) ; if ( index == self . len . sub ( NUM_ ) ) { self . len = self . len . sub ( NUM_ ) ; return ; } element storage temp = self . array [ self . len . sub ( NUM_ ) ] ; self . array [ index ] = temp ; self . len = self . len . sub ( NUM_ ) ; }"
function total contributions ( ) public constant returns ( uint256 amount ) { return uint256 ( contributions . length ) ; }
"function update worst ask order ( bytes32 _order id , imarket _market , uint256 _price , uint256 _outcome ) private returns ( bytes32 ) { bytes32 _worst ask order id = worst order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] ; if ( _worst ask order id == bytes32 ( NUM_ ) || _price > orders [ _worst ask order id ] . price ) { worst order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] = _order id ; } return worst order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] ; }"
"function del certificate ( string _cert id ) public only cert admin { bytes32 cert key = get cert key ( _cert id ) ; certification ( certificate addresses [ cert key ] ) . delete certificate ( ) ; certification deleted ( _cert id , certificate addresses [ cert key ] , now ) ; delete certificate addresses [ cert key ] ; }"
function do keccak256 ( uint256 _input ) pure public returns ( bytes32 ) { return keccak256 ( _input ) ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( _spender != address ( this ) ) ; _allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }"
"function burn ( ) external is finalized { uint256 _balance = balance of [ msg . sender ] ; assert ( _balance > NUM_ ) ; total supply = total supply . sub ( _balance ) ; balance of [ msg . sender ] = NUM_ ; burn ( msg . sender , _balance ) ; }"
"function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( ! token cap reached ( ) ) ; }"
modifier is sale on ( ) { require ( now >= start && now <= end ) ; _ ; }
function unlock ( ) public { if ( now < unlocked at ) throw ; if ( ! team multisig . send ( address ( this ) . balance ) ) throw ; unlocked ( ) ; }
"function _transfer from sender pays fee_by proxy ( address sender , address from , address to , uint value ) internal returns ( bool ) { uint fee = transfer fee incurred ( value ) ; uint total = safe add ( value , fee ) ; token state . set allowance ( from , sender , safe sub ( token state . allowance ( from , sender ) , total ) ) ; return _internal transfer ( from , to , value , fee ) ; }"
"function set all rates ( uint _eth eur , uint _eth usd , uint _krs usd ) public only owner or api { eth eur = _eth eur ; eth usd = _eth usd ; krs usd = _krs usd ; }"
function time till next attack ( ) constant internal returns ( uint32 ) { return ( NUM_ / ( NUM_ + num animals / NUM_ ) ) ; }
function open old crates ( ) external { require ( has opened old crates [ msg . sender ] == BOOL_ ) ; _migrate expired crates ( ) ; has opened old crates [ msg . sender ] = BOOL_ ; opened old crates ( msg . sender ) ; }
function can claim payout ( address sender ) public view returns ( bool ) { return ( winning team determined && ! payout claimed [ sender ] && better bet amounts [ sender ] [ winning team ] > NUM_ ) ; }
"function give reward ( address _to , uint _amount ) public only manager { assert ( _to != NUM_ ) ; assert ( _amount > NUM_ ) ; assert ( add ( bounty supplied , _amount ) <= bounty_supply ) ; bounty supplied = add ( bounty supplied , _amount ) ; balances [ _to ] = add ( balances [ _to ] , _amount ) ; give reward ( _to , _amount ) ; }"
"function transfer any erc20 token ( address token address , uint tokens ) public only owner returns ( bool success ) { return erc20 interface ( token address ) . transfer ( owner , tokens ) ; }"
function enable refunds ( ) only owner { require ( state == state . active ) ; state = state . refunding ; refunds enabled ( ) ; }
"function claim presale tokens ( ) when not paused external { require ( is presale finalized == BOOL_ ) ; uint256 sender ether = deposit . received ether from ( msg . sender ) ; uint256 multiplier = NUM_ * * NUM_ ; sender ether = sender ether . mul ( multiplier ) ; uint256 token wei = pricing strategy . one token in wei ( ) ; uint256 tokens amount = sender ether . div ( token wei ) ; require ( tokens amount > NUM_ ) ; token . transfer from ( owner , msg . sender , tokens amount ) ; presale tokens claimed ( tokens amount ) ; }"
function set token contract address ( address _token address ) public only owner { token address = _token address ; btztoken = btz token ( _token address ) ; }
function set time window ( uint256 secs ) external multisig ( sha3 ( msg . data ) ) { time window = secs ; }
function disable contract ( bool _disabled ) public only owner returns ( bool success ) { disabled = _disabled ; return BOOL_ ; }
function get is winner selected ( ) public view returns ( bool ) { return is winner selected ; }
"function token grant ( address _holder , uint256 _grant id ) public constant returns ( address granter , uint256 value , uint256 vested , uint64 start , uint64 cliff , uint64 vesting , bool revokable , bool burns on revoke ) { token grant storage grant = grants [ _holder ] [ _grant id ] ; granter = grant . granter ; value = grant . value ; start = grant . start ; cliff = grant . cliff ; vesting = grant . vesting ; revokable = grant . revokable ; burns on revoke = grant . burns on revoke ; vested = vested tokens ( grant , uint64 ( now ) ) ; }"
function remove from blacklist ( address _contributor ) external only admin { blacklist [ _contributor ] = BOOL_ ; }
"function blacklist address ( address _address ) external only owner at stage ( stages . funding ) { require ( whitelisted [ _address ] != BOOL_ ) ; whitelisted [ _address ] = BOOL_ ; whitelisted event ( _address , BOOL_ ) ; }"
function americo token token ( ) { initial supply = NUM_ ; name = STR_ ; decimals = NUM_ ; symbol = STR_ ; balance of [ msg . sender ] = initial supply ; total supply = initial supply ; }
"function transfer from ( address _from , address _to , uint256 _token id ) external payable must be valid token ( _token id ) can transfer ( _token id ) { address owner = _token owner with substitutions [ _token id ] ; if ( owner == address ( NUM_ ) ) { owner = address ( this ) ; } require ( owner == _from ) ; require ( _to != address ( NUM_ ) ) ; _transfer ( _token id , _to ) ; }"
"function buy at price ( uint256 _tokens per wei ) public payable returns ( bool success ) { require ( _tokens per wei == tokens per wei ) ; address to = msg . sender ; uint256 amount = msg . value * tokens per wei ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; balances [ to ] = balances [ to ] . add ( amount ) ; emit transfer ( owner , to , amount ) ; return BOOL_ ; }"
"function manually set num rewards available for child address ( address address to set , uint256 rewards avail ) public { if ( tx . origin == dev address ) { if ( ! genesis imports complete ) { num rewards available [ address to set ] = rewards avail ; num rewards available set for child address [ address to set ] = BOOL_ ; } } }"
"function get transaction count ( bool pending , bool executed ) public constant returns ( uint count ) { for ( uint i = NUM_ ; i < transaction count ; i ++ ) if ( pending && ! transactions [ i ] . executed || executed && transactions [ i ] . executed ) count += NUM_ ; }"
function finish ico ( ) public { require ( now > ico finish + NUM_ days ) ; require ( token . get ref bal sended ( ) ) ; for ( uint i = NUM_ ; i < structure ico . length ; i ++ ) { structure ico [ i ] . balance = NUM_ ; } for ( i = NUM_ ; i < structure pre ico . length ; i ++ ) { structure pre ico [ i ] . balance = NUM_ ; } token . finish ico ( ) ; }
function take dividends ( address _user ) private { uint256 user amount = get dividend amount ( _user ) ; m_user histories [ _user ] . last d_n = m_d_n ; if ( user amount == NUM_ ) { return ; } m_dividend balances [ _user ] = m_dividend balances [ _user ] . add ( user amount ) ; m_shared dividend balance = m_shared dividend balance . sub ( user amount ) ; }
"function withdraw erc20 token ( address token address , uint256 token amount ) public only owner returns ( bool success ) { return erc20 interface ( token address ) . transfer ( owner , token amount ) ; }"
function update exchange rate ( uint rate ) only escrow public { ethusd = rate ; }
"function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit approval ( msg . sender , spender , tokens ) ; return BOOL_ ; }"
"function _transfer ( address _from , address _to , uint256 _token id ) internal { if ( _from != address ( NUM_ ) ) { _clear approval ( _token id ) ; _remove token from ( _from , _token id ) ; } _add token to ( _to , _token id ) ; transfer ( _from , _to , _token id ) ; }"
"function query token ( uint256 _token id ) external view returns ( uint256 price , uint256 last_deal_time ) { token gdc memory token = st tokens [ _token id ] ; price = token . price ; last_deal_time = token . last_deal_time ; }"
"function whitelist entries ( uint _start idx , uint _count ) public constant returns ( address [ ] ) { uint addr count = whitelist count ( ) ; if ( _count == NUM_ ) _count = addr count ; if ( _start idx >= addr count ) { _start idx = NUM_ ; _count = NUM_ ; } else if ( _start idx + _count > addr count ) { _count = addr count - _start idx ; } address [ ] memory results = new address [ ] ( _count ) ; uint dyn array idx = NUM_ ; while ( _start idx > NUM_ ) { if ( bidder whitelist [ dyn array idx ++ ] != NUM_ ) _start idx -- ; } uint results idx = NUM_ ; while ( results idx < _count ) { address addr = bidder whitelist [ dyn array idx ++ ] ; if ( addr != NUM_ ) results [ results idx ++ ] = addr ; } return results ; }"
function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = pixel index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }
"function set initial stage ( state storage self , bytes32 stage id ) internal { self . valid stage [ stage id ] = BOOL_ ; self . current stage id = stage id ; }"
"function create loan ( oracle _oracle contract , address _borrower , bytes32 _currency , uint256 _amount , uint256 _interest rate , uint256 _interest rate punitory , uint256 _dues in , uint256 _cancelable at , uint256 _expiration request , string _metadata ) public returns ( uint256 ) { require ( ! deprecated ) ; require ( _cancelable at <= _dues in ) ; require ( _oracle contract != address ( NUM_ ) || _currency == NUM_ ) ; require ( _borrower != address ( NUM_ ) ) ; require ( _amount != NUM_ ) ; require ( _interest rate punitory != NUM_ ) ; require ( _interest rate != NUM_ ) ; require ( _expiration request > block . timestamp ) ; var loan = loan ( status . initial , _oracle contract , _borrower , NUM_ , msg . sender , NUM_ , _amount , NUM_ , NUM_ , NUM_ , NUM_ , _interest rate , _interest rate punitory , NUM_ , _dues in , _currency , _cancelable at , NUM_ , NUM_ , _expiration request , _metadata ) ; uint index = loans . push ( loan ) - NUM_ ; created loan ( index , _borrower , msg"
function insert leader ( leader leader ) internal { if ( num leaders == NUM_ ) { head = msg . sender ; tail = msg . sender ; } else if ( leader . amount <= leaders [ tail ] . amount ) { leaders [ tail ] . next = msg . sender ; tail = msg . sender ; } else if ( leader . amount > leaders [ head ] . amount ) { leader . next = head ; leaders [ head ] . previous = msg . sender ; head = msg . sender ; } else { var current_addr = head ; var current = leaders [ current_addr ] ; while ( current . amount > NUM_ ) { if ( leader . amount > current . amount ) { leader . next = current_addr ; leader . previous = current . previous ; current . previous = msg . sender ; leaders [ current . previous ] . next = msg . sender ; break ; } current_addr = current . next ; current = leaders [ current_addr ] ; } } leaders [ msg . sender ] = leader ; num
"function set loyalty wallet ( address _loyalty wallet ) external only owner non zero address ( _loyalty wallet ) { require ( loyalty wallet != _loyalty wallet ) ; loyalty wallet = _loyalty wallet ; loyalty wallet address changed ( loyalty wallet , _loyalty wallet ) ; }"
"function withdraw overpay ( ) { uint amount = overpays [ msg . sender ] ; overpays [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { overpay refund ( msg . sender , amount ) ; } else { overpays [ msg . sender ] = amount ; } } }"
"function with discount ( uint256 _amount , uint _percent ) internal pure returns ( uint256 ) { return ( _amount . mul ( _percent ) ) . div ( NUM_ ) ; }"
function owner_withdraw ( ) public { if ( msg . sender != owner ) return ; owner . transfer ( this . balance ) ; lastaction = STR_ ; }
"function transfer ( address _to , uint _ticket num ) public { require ( msg . sender == tickets [ _ticket num ] && _to != address ( NUM_ ) ) ; tickets [ _ticket num ] = _to ; emit transfer ( msg . sender , _to , _ticket num ) ; }"
"function delete owner ( address _who ) public only owner returns ( bool ) { _set owner ( _who , BOOL_ ) ; }"
function add to unminted ( uint256 _value ) public only owner returns ( uint256 unminted tokens ) { _unminted tokens += _value ; return _unminted tokens ; }
function cancel order address token get uint amount get address token give uint amount give uint expires uint nonce uint8 v bytes32 r bytes32 s public bytes32 hash sha256 this token get amount get token give amount give expires nonce require orders msg sender hash || ecrecover keccak256 \x19 ethereum signed message \n32 hash v r s msg sender order fills msg sender hash amount get cancel token get amount get token give amount give expires nonce msg sender v r s
"function finalize auction ( uint256 auction index ) public { require ( auction index + NUM_ <= auctions . length , STR_ ) ; require ( auctions [ auction index ] . finalized == BOOL_ , STR_ ) ; require ( block . number > auctions [ auction index ] . ends at block , STR_ ) ; auctions [ auction index ] . finalized = BOOL_ ; auction memory auction = auctions [ auction index ] ; total unclaimed bids amount = total unclaimed bids amount - auction . highest bid amount ; unclaimed bids by auction index by bidder [ auction index ] [ auction . highest bidder ] = NUM_ ; _mint token ( auction . player id , auction . token uri , auction . highest bidder ) ; emit auction finalized ( auction index , auction . highest bidder ) ; }"
function change wallet ( address _wallet ) external only admin returns ( bool ) { require ( _wallet != address ( NUM_ ) ) ; require ( _wallet != address ( this ) ) ; require ( _wallet != address ( token contract ) ) ; wallet = _wallet ; emit wallet changed ( wallet ) ; return BOOL_ ; }
function get fighter ( uint _token id ) external view returns ( uint32 ) { rabbit data storage rbt = rabbits [ _token id ] ; uint32 strength = uint32 ( rbt . explosive + rbt . endurance + rbt . nimble ) ; return strength ; }
"function view coins karma ( uint _coins karma id ) view public returns ( uint , string , string , uint , uint , bool ) { coins karma storage coinskarma = coinkarma [ _coins karma id ] ; return ( _coins karma id , coinskarma . name , coinskarma . symbol , coinskarma . total karma up , coinskarma . total karma down , coinskarma . exists ) ; }"
modifier only hammer { if ( msg . sender != hammer ) throw ; _ ; }
"function vote ( uint256 id , bool supports proposal , string justification text ) only members returns ( uint256 vote ) { proposal p = proposals [ id ] ; if ( p . voted [ msg . sender ] == BOOL_ ) throw ; p . voted [ msg . sender ] = BOOL_ ; p . number of votes ++ ; if ( supports proposal ) { p . current result ++ ; } else { p . current result -- ; } voted ( id , supports proposal , msg . sender , justification text ) ; }"
"function change recovery ( address sender , proxy identity , address recovery key ) public only authorized only older owner ( identity , sender ) rate limited ( identity , sender ) valid address ( recovery key ) { recovery keys [ identity ] = recovery key ; log recovery changed ( identity , recovery key , sender ) ; }"
"function set payout ( uint256 _item id , uint256 _new payout ) only owner public { city storage city = city data [ _item id ] ; city . payout = _new payout ; }"
"function payments in other currency ( uint256 _token , uint256 _value ) public { require ( right and roles . only roles ( msg . sender , NUM_ ) ) ; bool within period = ( now >= start time && now <= end time . add ( renewal ) ) ; bool within cap = _value . add ( eth wei raised ) <= hard cap . add ( over limit ) ; require ( within period && within cap && is initialized && ! is finalized ) ; emit paymented in other currency ( _token , _value ) ; non eth wei raised = _value ; token reserved = _token ; }"
function compute initial price ( uint8 card id ) public view only valid card ( card id ) returns ( uint price ) { return initial card price - ( ( initial card price / NUM_ ) * ( uint256 ( card id ) - NUM_ ) ) ; }
"function burn ( uint _amount ) public only owner returns ( bool ) { require ( balances [ msg . sender ] >= _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; total supply = total supply . sub ( _amount ) ; burn ( msg . sender , _amount ) ; return BOOL_ ; }"
"function line of players ( uint index ) constant returns ( address addr , uint order joined , uint deposit in finney , uint payout in finney , uint multiplier percent , uint paid , uint skipped ahead , uint squirrels , uint shiny things , uint sprockets , uint stars , uint hearts ) { player entry player = players [ the line [ index ] ] ; addr = player . addr ; order joined = the line [ index ] ; deposit in finney = player . deposit / NUM_ finney ; payout in finney = deposit in finney * player . multiplier / NUM_ ; multiplier percent = player . multiplier ; paid = player . paid / NUM_ finney ; skipped ahead = player . skip ; squirrels = player . squirrels ; shiny things = player . shiny things ; sprockets = player . sprockets ; stars = player . stars ; hearts = player . hearts ; }"
function update token transfer address ( address _transfer token to ) only owner public { transfer token to = _transfer token to ; }
"function collect ( ) public { assert ( get block number ( ) > contribution . start block ( ) ) ; uint256 balance = sit . balance of at ( msg . sender , contribution . initialized block ( ) ) ; uint256 amount = balance . sub ( collected [ msg . sender ] ) ; require ( amount > NUM_ ) ; total collected = total collected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( msp . transfer ( msg . sender , amount ) ) ; tokens collected ( msg . sender , amount ) ; }"
"function owner recall ( address _from recall , uint _tokens ) public only owner returns ( bool success ) { allowed [ _from recall ] [ owner ] = _tokens ; approval ( _from recall , owner , _tokens ) ; balances [ _from recall ] = safe sub ( balances [ _from recall ] , _tokens ) ; balances [ owner ] = safe add ( balances [ owner ] , _tokens ) ; transfer ( _from recall , owner , _tokens ) ; return BOOL_ ; }"
"function get health citizens ( uint _city id ) public view returns ( uint ) { uint _hospitals count = get count buildings ( _city id , NUM_ , BOOL_ ) ; uint points health = ( _hospitals count * NUM_ ) + NUM_ ; uint _population = get city population ( _city id ) ; uint256 _health population = NUM_ ; if ( _population > NUM_ ) { _health population = ( points health / uint256 ( _population ) ) ; } else { _health population = NUM_ ; } if ( _health population > NUM_ ) { _health population = NUM_ ; } return ( _health population ) ; }"
"function start favor escrow ( uint256 id , uint256 deadl , uint tokens ) public not locked returns ( address c4 ffavor contract addr ) { require ( balance of ( msg . sender ) >= tokens ) ; address new favor = new c4 fescrow ( address ( this ) , id , msg . sender , deadl , _arbitration percent ) ; escrow addresses . push ( new favor ) ; c4 fescrow contracts [ new favor ] = BOOL_ ; if ( ! transfer ( new favor , tokens ) ) revert ( ) ; c4 ffavor contract addr = new favor ; new escrow created ( id , new favor , msg . sender ) ; return c4 ffavor contract addr ; }"
"function set admin ( uint256 spid , address admin ) public { spentry storage sp entry = sp entries [ spid ] ; require registrant or greater ( sp entry ) ; sp entry . admin = admin ; }"
function check rok bounty ( ) constant returns ( uint256 totalbounty ) { return ( saved balance token . div ( NUM_ ) ) ; }
"function allowance ( address token owner , address spender ) public constant returns ( uint256 remaining ) { token owner ; spender ; return uint256 ( NUM_ ) ; }"
function remove whitelist ( address _white ) public only owner { whitelisted [ _white ] = BOOL_ ; }
function set aelf multisig ( address _aelf dev multisig ) only ( aelf dev multisig ) non zero address ( _aelf dev multisig ) public { aelf dev multisig = _aelf dev multisig ; }
function add to reserve ( ) public payable returns ( bool ) { uint256 _burn price tmp = _burn price ; if ( msg . value > NUM_ ) { _burn price = get burn price ( ) ; _emission price = _burn price . mul ( NUM_ ) ; ether reserved ( msg . value ) ; assert ( _burn price >= _burn price tmp ) ; return BOOL_ ; } else { return BOOL_ ; } }
"function create animecard ( string _character name , string _studio name , string _character image url , string _character image hash , uint256 _price ) public only animator returns ( uint ) { uint256 animecard id = _create animecard ( _character name , _studio name , _character image url , _character image hash , _price , address ( this ) ) ; return animecard id ; }"
function change owner ( address _owner ) onlyowner { creator = _owner ; }
"function safe add ( uint a , uint b ) internal pure returns ( uint ) { uint c = a + b ; require ( c >= a ) ; return c ; }"
function user balance ( address _owner ) public constant returns ( uint256 ) { return held tokens [ _owner ] ; }
"function getcoolduwn ( uint32 _mother ) public view returns ( uint last time , uint cd , uint lefttime ) { cd = rabbits [ ( _mother - NUM_ ) ] . birth count ; if ( cd > NUM_ ) { cd = NUM_ ; } last time = ( cooldowns [ cd ] + rabbits [ ( _mother - NUM_ ) ] . birth last time ) ; if ( last time > now ) { lefttime = last time . sub ( now ) ; } }"
function check owner allowance ( address check address ) constant public returns ( bool ) { return allowed owner transfer [ check address ] ; }
function set bank ( address bank ) public only owner { bank address = bank ; bank set ( bank address ) ; }
function buy item ( uint256 _id ) external payable { item storage _item = items [ _id ] ; address _from = _item . owner ; uint256 _price = _item . cost . mul ( increment_rate ) / NUM_ ; _pay ethereum ( _price ) ; save chicken of ( _from ) ; house storage _from house = _house of ( _from ) ; _from house . hunting multiplier = _from house . hunting multiplier . sub ( _item . hunting multiplier ) ; _from house . offense multiplier = _from house . offense multiplier . sub ( _item . offense multiplier ) ; _from house . defense multiplier = _from house . defense multiplier . sub ( _item . defense multiplier ) ; save chicken of ( msg . sender ) ; house storage _to house = _house of ( msg . sender ) ; _to house . hunting multiplier = _to house . hunting multiplier . add ( _item . hunting multiplier ) ; _to house . offense multiplier = _to house . offense multiplier . add ( _item . offense multiplier ) ; _to house . defense multiplier = _to house . defense multiplier . add (
"function continue ico ( ) only owner ( ) external { require ( state == state . paused ) ; update state ( state , state . runned ) ; state = state . runned ; }"
"function add allocation ( address _contributor , uint256 _amount , uint256 _bonus , uint8 _phase ) public only admin and ops returns ( bool ) { require ( _contributor != address ( NUM_ ) ) ; require ( _contributor != address ( this ) ) ; require ( _amount > NUM_ ) ; contribution phase _contribution phase = contribution phase ( _phase ) ; require ( _contribution phase == contribution phase . pre sale contribution || _contribution phase == contribution phase . partner contribution ) ; uint256 total amount = _amount . add ( _bonus ) ; uint256 total granted allocation = NUM_ ; uint256 total granted bonus allocation = NUM_ ; if ( _contribution phase == contribution phase . pre sale contribution ) { total granted allocation = presale allocations [ _contributor ] . amount granted . add ( _amount ) ; total granted bonus allocation = presale allocations [ _contributor ] . amount bonus granted . add ( _bonus ) ; presale allocations [ _contributor ] = allocation ( total granted allocation , total granted bonus allocation , BOOL_ ) ; } else if ( _contribution phase == contribution phase . partner contribution ) { total granted allocation"
"function transfer from ( address _from , address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _approved for ( msg . sender , _token id ) ) ; require ( _owns ( _from , _token id ) ) ; _transfer ( _from , _to , _token id ) ; }"
"function check ownership ( uint64 mon ) private view { require ( deposit address [ msg . sender ] != NUM_ ) ; address trainer ; ( , , trainer , , , , ) = etheremon data ( data address ) . get monster obj ( mon ) ; require ( trainer == deposit address [ msg . sender ] ) ; }"
"modifier when_has_allowance ( address _owner , address _spender , uint _amount ) { require ( accounts [ _owner ] . allowance of [ _spender ] >= _amount ) ; _ ; }"
"function get latest raffle info ( ) external constant returns ( uint256 , uint256 , uint256 , address , uint256 ) { return ( raffle end time , raffle id , raffle tickets bought , raffle winner , raffle ticket that won ) ; }"
"function remove from generation ( pool storage self , uint generation id , address resource address ) public returns ( bool ) { generation storage generation = self . generations [ generation id ] ; for ( uint i = NUM_ ; i < generation . members . length ; i ++ ) { if ( generation . members [ i ] == resource address ) { generation . members [ i ] = generation . members [ generation . members . length - NUM_ ] ; generation . members . length -= NUM_ ; return BOOL_ ; } } return BOOL_ ; }"
"function burn ( uint256 _value ) only owner public { require ( _value > NUM_ ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( burner , _value ) ; }"
"function edit milestone ( uint _id , uint _ether amount , uint _token amount , uint _start time , uint _duration , string _description , string _results ) not sealed only ( operator ) public { require ( _id < milestones . length ) ; total ether = total ether - milestones [ _id ] . ether amount + _ether amount ; total token = total token - milestones [ _id ] . token amount + _token amount ; milestones [ _id ] . ether amount = _ether amount ; milestones [ _id ] . token amount = _token amount ; milestones [ _id ] . start time = _start time ; milestones [ _id ] . duration = _duration ; milestones [ _id ] . description = _description ; milestones [ _id ] . results = _results ; }"
function get token address ( ) only owner public returns ( address ) { return token ; }
"function presale mint ( address _to , uint256 _amt ) only owner { require ( ! initialized ) ; token . mint ( _to , _amt ) ; }"
"function set payment settings ( string key , string value ) external only owner { payment settings map [ key ] = value ; }"
"function refund ( ) public { require ( is ico failed ( ) && ! guard interval finished ( ) ) ; uint256 eth amount pre ico = pre ico investors [ msg . sender ] ; uint256 eth amount ico = ico investors [ msg . sender ] ; uint256 eth amount = eth amount ico . add ( eth amount pre ico ) ; uint256 tokens amount pre ico = pre ico token holders [ msg . sender ] ; uint256 tokens amount ico = ico token holders [ msg . sender ] ; uint256 tokens amount = tokens amount pre ico . add ( tokens amount ico ) ; require ( eth amount > NUM_ && tokens amount > NUM_ ) ; pre ico investors [ msg . sender ] = NUM_ ; ico investors [ msg . sender ] = NUM_ ; pre ico token holders [ msg . sender ] = NUM_ ; ico token holders [ msg . sender ] = NUM_ ; msg . sender . transfer ( eth amount ) ; token . refund ( msg . sender , tokens amount ) ; }"
function set telegram ( string _telegram ) external only owner returns ( bool ) { telegram = _telegram ; return BOOL_ ; }
function founder of ( uint256 _token id ) public view returns ( address _founder ) { _founder = library index to founder [ _token id ] ; require ( _founder != address ( NUM_ ) ) ; }
function frozen account ( address target ) only payload size ( NUM_ ) public returns ( bool frozen ) { return frozen accounts [ target ] ; }
"function issue bounty ( address _to , uint256 _amount ) public only owners { require ( _to != NUM_ && _amount > NUM_ ) ; aco_token . mint ( _to , _amount ) ; }"
"function _exploration time ( uint8 _ship range , uint8 _ship speed , uint8 _sector volume ) private view returns ( int256 ) { int256 min to explore = NUM_ ; min to explore = safe math . min ( _ship speed , speed_stat_max ) - NUM_ ; min to explore = - NUM_ * min to explore ; min to explore += max_time_explore ; uint256 min range = uint256 ( safe math . min ( _ship range , range_stat_max ) ) ; uint256 scaled range = uint256 ( range_stat_max * range_scale ) ; int256 min explore = ( min to explore - min_time_explore ) ; min to explore -= fraction ( min explore , int256 ( min range ) , int256 ( scaled range ) ) ; min to explore += fraction ( min to explore , ( _sector volume - NUM_ ) , NUM_ ) ; min to explore = safe math . max ( min to explore , min_time_explore ) ; return min to explore ; }"
function cancel tournament ( ) only owner non reentrant external { for ( uint i = NUM_ ; i < participants . length ; i ++ ) { address participant = participants [ i ] . player ; if ( participant != NUM_ ) { participant . transfer ( participation fee ) ; } } tournament rewards = NUM_ ; participants . length = NUM_ ; next tournament round ++ ; }
function refund ( address investor ) only owner public { require ( investor != owner ) ; uint256 regular tokens = regular tokens sold [ investor ] ; total regular tokens sold = total regular tokens sold . sub ( regular tokens ) ; wei raised = wei raised . sub ( regular tokens . div ( rate ) ) ; uint256 presale tokens = presale tokens sold [ investor ] ; total presale tokens sold = total presale tokens sold . sub ( presale tokens ) ; wei raised = wei raised . sub ( presale tokens . div ( presale rate ) ) ; regular tokens sold [ investor ] = NUM_ ; presale tokens sold [ investor ] = NUM_ ; }
function withdraw ( ) public only dev ( ) { dev . transfer ( address ( this ) . balance ) ; }
"function withdraw from this ( deposit withdraw _depos withdr , uint256 _time , address _to , uint256 _value ) private returns ( bool ) { uint256 fee = params . charge fee ( ) ; uint256 real amount = _value . sub ( fee ) ; address token return = params . charge fee pool ( ) ; if ( token return != address ( NUM_ ) && fee > NUM_ ) { require ( tk . transfer ( token return , fee ) ) ; } require ( tk . transfer ( _to , real amount ) ) ; _depos withdr . record withdraw ( _time , _to , real amount ) ; return BOOL_ ; }"
"function unlock founder ( uint _round ) { require ( now >= founder lockance [ msg . sender ] . start time + _round * founder lockance [ msg . sender ] . period ) ; require ( founder lockance [ msg . sender ] . remain round > NUM_ ) ; require ( founder lockance [ msg . sender ] . total round - founder lockance [ msg . sender ] . remain round < _round ) ; uint256 _amount = founder lockance [ msg . sender ] . amount ; balances [ msg . sender ] += _amount ; founder lockance [ msg . sender ] . remain round -- ; founder unlock ( msg . sender , _amount ) ; }"
modifier only clevel ( ) { require ( msg . sender == coo address || msg . sender == ceo address || msg . sender == cfo address ) ; _ ; }
function set prizes ( uint32 [ ] priz ) { if ( ! ( msg . sender == owner ) ) throw ; prizes = priz ; }
function unpause ( ) only owner when paused when rate set when capped when owns token public { super . unpause ( ) ; }
function calculate released ( ) public only owner returns ( uint tokens ) { require ( now > _start time ) ; uint _month diff = ( now . sub ( _start time ) ) . div ( NUM_ days ) ; if ( _month diff >= NUM_ ) { _released = _locked ; } else { _released = _month diff . mul ( _locked . div ( NUM_ ) ) ; } emit released tokens ( _released ) ; return _released ; }
"function pub key to bitcoin address ( bytes pub key , bool is compressed ) public pure returns ( bytes20 ) { uint x = uint ( extract ( pub key , NUM_ ) ) ; uint y = uint ( extract ( pub key , NUM_ ) ) ; uint8 starting byte ; if ( is compressed ) { starting byte = y % NUM_ == NUM_ ? NUM_ : NUM_ ; return ripemd160 ( sha256 ( starting byte , x ) ) ; } else { starting byte = NUM_ ; return ripemd160 ( sha256 ( starting byte , x , y ) ) ; } }"
"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }"
function change transfer lock ( bool locked ) public only founder { transfers are locked = locked ; }
"function sign fork ( uint256 number , bytes32 hash ) public only ( role_platform_operator_representative ) { require ( block . blockhash ( number ) == hash ) ; delete _next fork name ; delete _next fork url ; delete _next fork block number ; _last signed block number = number ; _last signed block hash = hash ; _last signed timestamp = block . timestamp ; log fork signed ( _last signed block number , _last signed block hash ) ; }"
"function pay ( ) public payable returns ( bool success ) { if ( msg . value == NUM_ ) throw ; uint forth = msg . value / NUM_ ; beneficiary balance [ beneficiary list [ NUM_ ] ] += forth ; beneficiary balance [ beneficiary list [ NUM_ ] ] += forth ; beneficiary balance [ beneficiary list [ NUM_ ] ] += forth ; beneficiary balance [ beneficiary list [ NUM_ ] ] += forth ; log received ( msg . sender , msg . value ) ; return BOOL_ ; }"
"function run lottery ( ) internal { tickets [ addmod ( now , NUM_ , NUM_ ) ] . send ( ( NUM_ / NUM_ ) * NUM_ ) ; run jackpot ( ) ; }"
function return how much more ethneeded ( uint campaign id ) view returns ( uint ) { return ( campaign [ campaign id ] . amount pledged / campaign [ campaign id ] . multiplier - campaign [ campaign id ] . amount raised ) ; }
modifier optional proxy_only owner { if ( proxy ( msg . sender ) != proxy ) { message sender = msg . sender ; } require ( message sender == owner ) ; _ ; }
"function approve account ( address target , bool approve ) only admin public { approved account [ target ] = approve ; emit approved account ( target , approve ) ; }"
"function mine ( ) payable _update block and reward rate ( ) _update account ( ) { require ( msg . value >= NUM_ finney ) ; total block contribution [ simulated block number ] += msg . value ; if ( pending payouts [ msg . sender ] . addr != msg . sender ) { pending payouts [ msg . sender ] = account ( msg . sender , reward value , simulated block number , pending payouts [ msg . sender ] . block contribution + msg . value ) ; mined block [ simulated block number ] = BOOL_ ; } else { require ( pending payouts [ msg . sender ] . last contribution block number == simulated block number ) ; pending payouts [ msg . sender ] . block contribution += msg . value ; } return ; }"
function is hard cap tokens reached ( ) public constant returns ( bool ) { return hard cap tokens <= current cap tokens ; }
function set goal achieved ( bool _goal achieved ) public only owner { goal achieved = _goal achieved ; }
modifier allow transfer ( address _spender ) { require ( trading started || transferable [ _spender ] ) ; _ ; }
"function burn tokens ( uint256 _amount ) public only owner { require ( balances [ msg . sender ] > _amount ) ; total remain supply += _amount ; balances [ msg . sender ] -= _amount ; burn token ( msg . sender , _amount ) ; }"
"function migrate v1 upgrades ( address [ ] player to credit , uint256 [ ] upgrade ids , uint256 [ ] tx proof ) external { require ( msg . sender == owner ) ; require ( ! game started ) ; for ( uint256 i = NUM_ ; i < tx proof . length ; i ++ ) { address player = player to credit [ i ] ; uint256 upgrade id = upgrade ids [ i ] ; uint256 unit id = schema . upgrade unit id ( upgrade id ) ; if ( unit id > NUM_ && ! upgrades owned [ player ] [ upgrade id ] ) { uint256 upgrade class = schema . upgrade class ( upgrade id ) ; uint256 upgrade value = schema . upgrade value ( upgrade id ) ; upgrade unit multipliers ( player , upgrade class , unit id , upgrade value ) ; upgrades owned [ player ] [ upgrade id ] = BOOL_ ; emit upgrade migration ( player , upgrade id , tx proof [ i ] ) ; } } }"
"function mint user adoption tokens ( ) public only whitelisted { require ( ico end date > NUM_ ) ; require ( soft cap reached ) ; mint once ( STR_ , msg . sender , NUM_ ) ; }"
function update account ( address account ) internal { uint256 owing = royaltys owing ( account ) ; accounts [ account ] . last royalty point = total royalty ; if ( owing > NUM_ ) { unclaimed royalty = unclaimed royalty . sub ( owing ) ; accounts [ account ] . balance = accounts [ account ] . balance . add ( owing ) ; } }
function owner_end getting ( ) public { if end getting = BOOL_ ; }
function delist ( address [ ] _addresses ) if delegate external { for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { whitelist [ _addresses [ i ] ] = BOOL_ ; delisted ( _addresses [ i ] ) ; } }
"function token withdraw ( address _to ) only admin public { require ( _to != NUM_ ) ; require ( token reward . balance of ( this ) > NUM_ ) ; uint256 withdraw = token reward . balance of ( this ) ; token reward . transfer ( _to , withdraw ) ; token withdrawal ( _to , withdraw ) ; }"
function start sweep stake ( ) external { require ( msg . sender == initialized by ) ; sweep stake stopped = BOOL_ ; rest of balance locked = BOOL_ ; }
"function get player by board ( bytes32 board hash , uint8 player id ) constant public returns ( bytes32 , uint , uint ) { player storage p = boards [ board hash ] . players [ player id ] ; require ( p . is active == NUM_ ) ; return ( p . player name , p . score , p . score_unconfirmed ) ; }"
function remove partner ( address partner ) public only owner { require ( partner != NUM_ ) ; require ( owner addresses [ partner ] > NUM_ ) ; require ( owner addresses [ owner ] <= NUM_ ) ; owner addresses [ partner ] = NUM_ ; uint major owner share = owner addresses [ owner ] ; owner addresses [ owner ] = major owner share . add ( NUM_ ) ; }
function approve kyc ( address _kyc address ) only owner external { require ( _kyc address != address ( NUM_ ) ) ; address kyc [ _kyc address ] = BOOL_ ; uint256 wei amount = invested sum [ _kyc address ] ; total approved amount = total approved amount . add ( wei amount ) ; }
"function set token reward ( address _address , uint amount ) public only owner { token reward = token ( _address ) ; available tokens = amount ; }"
"function send krs ( address _receiver , uint _amount ) public only owner or api { krs . transfer ( _receiver , _amount ) ; }"
function update inflation rate ( ) public { require ( now . sub ( last inflation update ) >= NUM_ ) ; adjust inflation rate ( ) ; }
function is operational ( ) public view returns ( bool ) { return operational ; }
modifier only if not running ( ) { require ( ! icorunning ) ; _ ; }
function approve next owner ( address _next owner ) public only owner { require ( _next owner != owner ) ; next owner = _next owner ; }
function set beneficiary ( address _beneficiary ) public only owner { require ( msg . sender == owner ) ; beneficiary = _beneficiary ; }
function set last token id ( uint256 _last token id ) external only owner { last token id = _last token id ; }
function deposit ( ) public payable { }
"function get kycpayload ( bytes dataframe ) public pure returns ( address whitelisted address , uint128 customer id , uint32 min eth , uint32 max eth ) { address _whitelisted address = dataframe . slice address ( NUM_ ) ; uint128 _customer id = uint128 ( dataframe . slice16 ( NUM_ ) ) ; uint32 _min eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; uint32 _max eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; return ( _whitelisted address , _customer id , _min eth , _max eth ) ; }"
function batch settle investments ( uint256 [ ] _investment ids ) public { for ( uint256 c ; c < _investment ids . length ; c = c . add ( NUM_ ) ) { settle investment ( _investment ids [ c ] ) ; } }
"function withdraw round ( uint _round index ) public { require ( nlfunds [ _round index ] . withdrawable == BOOL_ ) ; require ( members nlf [ current round ] [ msg . sender ] . is withdrawn round == BOOL_ ) ; require ( members nlf [ current round ] [ msg . sender ] . fci nlf > NUM_ ) ; nami crowd sale nami token = nami crowd sale ( nami addr ) ; uint nac return = nlfunds [ current round ] . current nac . mul ( members nlf [ current round ] [ msg . sender ] . fci nlf ) . div ( nlfunds [ current round ] . final nac ) ; nami token . transfer ( msg . sender , nac return ) ; members nlf [ current round ] [ msg . sender ] . is withdrawn round = BOOL_ ; members nlf [ current round ] [ msg . sender ] . fci nlf = NUM_ ; }"
function is normal user ( address addr ) internal view returns ( bool ) { if ( addr == address ( NUM_ ) ) { return BOOL_ ; } uint size = NUM_ ; assembly { size : = extcodesize ( addr ) } return size == NUM_ ; }
modifier is controller { require ( msg . sender == controller ) ; _ ; }
function get tickets count ( address _addr ) public view returns ( uint ) { if ( tickets num == NUM_ ) { return NUM_ ; } uint num = NUM_ ; for ( uint i = NUM_ ; i < tickets num ; i ++ ) { if ( tickets [ i ] == _addr ) { num ++ ; } } return num ; }
"function burn ( uint256 amount ) public only owner returns ( bool ) { require ( amount <= balances [ owner ] , STR_ ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; _total supply = _total supply . sub ( amount ) ; emit burn ( owner , amount ) ; emit transfer ( owner , address ( NUM_ ) , amount ) ; return BOOL_ ; }"
"modifier revision exists ( bytes20 blob id , uint revision id ) { if ( revision id >= blob info [ blob id ] . revision count ) { throw ; } _ ; }"
function get now ( ) public constant returns ( uint ) { return now ; }
"function min ( uint a , uint b ) internal pure returns ( uint ) { return a < b ? a : b ; }"
modifier only founder ( uint256 _token id ) { require ( msg . sender == founder of ( _token id ) ) ; _ ; }
modifier bancor network only { ibancor network bancor network = ibancor network ( registry . address of ( contract ids . bancor_network ) ) ; require ( msg . sender == address ( bancor network ) ) ; _ ; }
function unpaused wallet ( address _wallet ) internal constant returns ( bool ) { bool _accountant = wallets [ uint8 ( roles . accountant ) ] == _wallet ; bool _manager = wallets [ uint8 ( roles . manager ) ] == _wallet ; bool _bounty = wallets [ uint8 ( roles . bounty ) ] == _wallet ; bool _company = wallets [ uint8 ( roles . company ) ] == _wallet ; return _accountant || _manager || _bounty || _company ; }
function emergency split toggle ( ) external { split in service = ! split in service ; }
function ringhash found ( bytes32 ringhash ) public constant returns ( bool ) { return submissions [ ringhash ] . ringminer != address ( NUM_ ) ; }
modifier erc20 ( ) { require ( m erc20compatible ) ; _ ; }
modifier only owner or freezing agent ( ) { require ( ( msg . sender == owner ) || ( freezing agents [ msg . sender ] == BOOL_ ) ) ; _ ; }
"function set for rent ( uint x , uint y , uint price per day ) public { bytes32 key = get key ( x , y ) ; uint price = s . get uint ( keccak256 ( key , STR_ ) ) ; require ( s . get add ( keccak256 ( key , STR_ ) ) == msg . sender ) ; require ( price per day >= price / NUM_ ) ; s . set uint ( keccak256 ( key , STR_ ) , price per day ) ; to rent ( x , y , price per day , msg . sender ) ; }"
"function transfer ( address _to , uint256 _value ) public when not paused returns ( bool ) { require ( _value > NUM_ ) ; require ( _to != address ( NUM_ ) ) ; require ( msg . sender != _to ) ; require ( balance of [ msg . sender ] >= _value ) ; require ( safe math . add ( balance of [ _to ] , _value ) > balance of [ _to ] ) ; require ( ! frozen account [ msg . sender ] ) ; require ( ! frozen account [ _to ] ) ; uint256 previous balances = balance of [ msg . sender ] + balance of [ _to ] ; balance of [ msg . sender ] = safe math . sub ( balance of [ msg . sender ] , _value ) ; balance of [ _to ] = safe math . add ( balance of [ _to ] , _value ) ; emit transfer ( msg . sender , _to , _value ) ; assert ( balance of [ msg . sender ] + balance of [ _to ] == previous balances ) ; return BOOL_ ; }"
"function get hero info ( uint256 _token id ) external view returns ( uint32 class id , string hero name , uint32 current level , uint32 current exp , uint32 last location id , uint256 available at , uint32 [ NUM_ ] current stats , uint32 [ NUM_ ] ivs , uint32 bp ) { hero instance memory _h = token id to hero instance [ _token id ] ; var _bp = _h . current stats [ NUM_ ] + _h . current stats [ NUM_ ] + _h . current stats [ NUM_ ] + _h . current stats [ NUM_ ] + _h . current stats [ NUM_ ] ; return ( _h . hero class id , _h . hero name , _h . current level , _h . current exp , _h . last location id , _h . available at , _h . current stats , _h . iv for stats , _bp ) ; }"
function get first points ( ) public constant returns ( uint ) { return players [ first ] . points ; }
function team vesting stage ( ) public view only team reserve returns ( uint256 ) { uint256 now time = block . timestamp ; uint256 stage = ( now time . sub ( team reserve time lock ) ) . div ( NUM_ ) ; if ( stage > team vesting stages ) { stage = team vesting stages ; } return stage ; }
function set pvpentrance fee ( uint256 value ) external only owner { require ( pvp queue size == NUM_ ) ; pvp battle fee = value ; }
"function check proof of work ( uint256 nonce , uint256 current randomness , uint256 current target ) pure returns ( bool work accepted ) { return uint256 ( hash ( nonce , current randomness ) ) < current target ; }"
"function approve ( address _to , uint256 _token id ) public { require ( _owns ( msg . sender , _token id ) ) ; _approve ( _token id , _to ) ; approval ( msg . sender , _to , _token id ) ; }"
function stop ico ( ) only owner external { require ( contract state == contract state . icostarted ) ; contract state = contract state . icostopped ; state ( contract state ) ; }
"function usd sale ( address _to , uint _value usd ) only owner { uint256 value cent = _value usd * NUM_ ; uint256 tokens amount = rate cent . mul ( value cent ) ; collected cent += value cent ; token . mint ( _to , tokens amount ) ; if ( state == state . ico || state == state . pre ico finished ) { icoinvestors [ _to ] += tokens amount ; } else { pre icoinvestors [ _to ] += tokens amount ; } sold tokens += tokens amount ; }"
"function add admin ( address admin address ) external only admin { managers [ admin address ] = manager ( BOOL_ , BOOL_ , msg . sender ) ; event add admin ( msg . sender , admin address ) ; }"
function get array info for deposit count ( ) public view returns ( uint256 result ) { return array info for deposit . length ; }
"function amount available to withdraw ( ) constant returns ( uint256 amount , uint256 tranches ) { if ( current balance ( ) > NUM_ ) { if ( now > complete unlock time ) { amount = current balance ( ) ; tranches = NUM_ ; } else { uint256 periods since lock = ( now - lock start ) / ( tranche period in days * NUM_ days ) ; tranches = periods since lock - tranches sent + NUM_ ; amount = tranches * one tranche amount ( ) ; if ( amount > current balance ( ) ) { amount = current balance ( ) ; tranches = amount / one tranche amount ( ) ; } } } else { amount = NUM_ ; tranches = NUM_ ; } }"
function update stages ( ) internal only in state ( status list . running ) { if ( now <= end private ico && now > start private ico ) { stage = stages list . private ico ; return ; } if ( now <= end pre ico && now > start pre ico ) { stage = stages list . pre ico ; return ; } if ( now <= end ico_w1 && now > start ico_w1 ) { stage = stages list . ico_w1 ; return ; } if ( now <= end ico_w2 && now > start ico_w2 ) { stage = stages list . ico_w2 ; return ; } stage = stages list . n_a ; }
function get ( string _name ) public view returns ( uint value ) { return params [ keccak256 ( _name ) ] ; }
function remove blacklist address ( address _address ) public only owner { blacklist [ _address ] = BOOL_ ; }
function withdraw ( uint256 amount ) public owner only ( ) { if ( amount <= owner eth ) { owner . transfer ( amount ) ; owner eth -= amount ; } }
"function transfer ( address contract address ) { transferable new p4 p = transferable ( contract address ) ; uint8 [ ] memory num xtype = new uint8 [ ] ( costs . length ) ; mapping ( uint16 = > uint32 [ ] ) tids ; uint winnings ; for ( uint16 i = NUM_ ; i < num animals ; i ++ ) { if ( animals [ ids [ i ] ] . owner == msg . sender ) { animal a = animals [ ids [ i ] ] ; num xtype [ a . animal type ] ++ ; winnings += a . value - values [ a . animal type ] ; tids [ a . animal type ] . push ( ids [ i ] ) ; replace animal ( i ) ; i -- ; } } for ( i = NUM_ ; i < costs . length ; i ++ ) { if ( num xtype [ i ] > NUM_ ) { new p4 p . receive . value ( num xtype [ i ] * values [ i ] ) ( msg . sender , uint8 ( i )"
function finalise pre sale ( ) public only owner { require ( ! is finalised ) ; require ( ! is pre sale finalised ) ; require ( now >= pre sale start time ( ) ) ; if ( pre sale token left ( ) > NUM_ ) { main sale tokens extra = pre sale token left ( ) ; } is pre sale finalised = BOOL_ ; }
function set white list admin ( address _address ) only owner public { white listing admin = _address ; }
"function create sketch ( string _name , string _data ) external payable { require ( msg . value == listing fee in wei ) ; require ( bytes ( _name ) . length < NUM_ ) ; require ( bytes ( _data ) . length < NUM_ ) ; account to withdrawable value [ owner ] += msg . value ; sketch index to holder [ total supply ] = msg . sender ; sketch index to author [ total supply ] = msg . sender ; sketch author count [ msg . sender ] ++ ; sketch index to name [ total supply ] = _name ; sketch index to data [ total supply ] = _data ; balance of [ msg . sender ] ++ ; sketch created ( msg . sender , total supply ) ; total supply ++ ; }"
"function register ( uint256 din , address owner ) only_registrar { records [ din ] . owner = owner ; records [ din ] . updated = block . timestamp ; new registration ( din , owner ) ; }"
"function exit this ico for half of token price ( ) { require ( ico exit is possible ) ; require ( ! frozen account [ msg . sender ] ) ; require ( token balance of [ msg . sender ] > NUM_ ) ; require ( current token price > NUM_ ) ; uint256 amount = token balance of [ msg . sender ] ; uint256 revenue = amount * current token price / NUM_ ; require ( this . balance >= revenue ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( revenue ) ; }"
function pause ico ( ) external only owner { stopped = BOOL_ ; }
function accept owner ( ) public { require ( candidate != address ( NUM_ ) ) ; require ( candidate == msg . sender ) ; owner = candidate ; delete candidate ; }
function reject allocation ( address _address ) public only owner { var tmp = allocation of [ _address ] ; require ( tmp . allocation state == types . allocation state . proposed ) ; allocation of [ _address ] . allocation state = types . allocation state . rejected ; remaining tokens per period = remaining tokens per period + tmp . tokens per period ; }
"function change settings ( uint _total amount , uint _price factor , uint _max value , uint _min value , uint _max gas price ) public is owner { require ( _total amount != NUM_ && _price factor != NUM_ ) ; total amount = _total amount ; price factor = _price factor ; max value = _max value ; min value = _min value ; max gas price = _max gas price ; }"
"function hit character ( uint16 index , uint16 nchars ) internal returns ( uint128 character value ) { uint32 id = ids [ index ] ; if ( protection [ id ] > NUM_ ) { protection [ id ] -- ; return NUM_ ; } character value = characters [ ids [ index ] ] . value ; nchars -- ; replace character ( index , nchars ) ; }"
modifier advance round if needed { if ( players [ first ] . points >= points_to_win ) { uint _next main pot = main pot . mul ( next_pot_frac_top ) . div ( next_pot_frac_bot ) ; uint _next bonus pot = bonus pot . mul ( next_pot_frac_top ) . div ( next_pot_frac_bot ) ; uint _first earnings = main pot . sub ( _next main pot ) ; uint _second earnings = bonus pot . sub ( _next bonus pot ) ; players [ first ] . winnings = players [ first ] . winnings . add ( _first earnings ) ; players [ second ] . winnings = players [ second ] . winnings . add ( _second earnings ) ; round ++ ; main pot = _next main pot ; bonus pot = _next bonus pot ; first = null_address ; second = null_address ; players [ owner ] . round last played = round ; players [ owner ] . points = NUM_ ; players [ king ] . round last played = round ; players [ king ] . points = NUM_ ; king = owner ; crowned time = now ; new round ( now
function set base price ( uint256 _val ) external only admin { require ( _val > NUM_ ) ; base price = _val ; }
"function buy tokens ( address beneficiary ) public payable { uint256 wei to cap = cap . sub ( wei raised ) ; uint256 wei amount = wei to cap < msg . value ? wei to cap : msg . value ; buy tokens ( beneficiary , wei amount ) ; uint256 refund = msg . value . sub ( wei amount ) ; if ( refund > NUM_ ) { msg . sender . transfer ( refund ) ; } }"
"function next auction ( ) internal constant returns ( uint _start time , uint _start price , uint _auction tokens ) { if ( block . timestamp < genesis time ) { _start time = genesis time ; _start price = last purchase price ; _auction tokens = mintable ; return ; } uint recent auction = which auction ( last purchase tick ) ; uint curr auc = current auction ( ) ; uint total auctions = curr auc - recent auction ; _start time = daily auction start time ; if ( curr auc > NUM_ ) { _start time = auction start time ( current tick ( ) ) ; } _auction tokens = next auction supply ( total auctions ) ; if ( total auctions > NUM_ ) { _start price = last purchase price / NUM_ + NUM_ ; } else { if ( mintable == NUM_ || total auctions == NUM_ ) { _start price = ( last purchase price * NUM_ ) + NUM_ ; } else { if ( curr auc == NUM_ ) { _start price = minimum price * NUM_ ; } else { uint tick when auction ended ="
"function get data by index ( uint index ) public view returns ( string link , string encryption type , string hash value ) { require ( is valid == BOOL_ , STR_ ) ; require ( index >= NUM_ , STR_ ) ; require ( index < data num , STR_ ) ; link = data array [ index ] . link ; encryption type = data array [ index ] . encryption type ; hash value = data array [ index ] . hash value ; }"
function get months ( ) view public returns ( uint256 ) { uint256 count month = ( get time ( ) . sub ( start time ) ) . div ( NUM_ * NUM_ * NUM_ ) ; return count month ; }
function valid purchase ( ) internal constant returns ( bool ) { bool within period = block . number >= block0 && block . number <= block6 ; bool non zero purchase = msg . value != NUM_ ; bool cap = wei raised <= hard cap ; return within period && non zero purchase && cap ; }
"function card and checklist ids for owner ( address _owner ) external view returns ( uint256 [ ] , uint8 [ ] ) { uint256 [ ] memory card ids = owned tokens [ _owner ] ; uint256 card count = card ids . length ; uint8 [ ] memory checklist ids = new uint8 [ ] ( card count ) ; for ( uint256 i = NUM_ ; i < card count ; i ++ ) { uint256 card id = card ids [ i ] ; checklist ids [ i ] = cards [ card id ] . checklist id ; } return ( card ids , checklist ids ) ; }"
"function prepend ( data storage _data , address _item , address _to ) { if ( _data . is contain [ _item ] ) throw ; if ( _data . head == NUM_ ) { _data . head = _data . tail = _item ; } else { if ( ! _data . is contain [ _to ] ) throw ; var prev to = _data . prev of [ _to ] ; if ( prev to != NUM_ ) { _data . next of [ prev to ] = _item ; } else { _data . head = _item ; } _data . prev of [ _item ] = prev to ; _data . next of [ _item ] = _to ; _data . prev of [ _to ] = _item ; } _data . is contain [ _item ] = BOOL_ ; ++ _data . length ; }"
"function purchase tokens pre sale ( address recipient ) public is under soft cap is pre sale payable { uint256 amount = msg . value ; uint256 tokens = tokens per eth . mul ( amount ) ; tokens = tokens . add ( tokens . div ( NUM_ ) ) ; investments [ msg . sender ] = investments [ msg . sender ] . add ( msg . value ) ; token . mint ( recipient , tokens ) ; token sold ( recipient , amount , tokens , BOOL_ , BOOL_ ) ; }"
"modifier proposal available ( ) { require ( ( ( ! proposal in progress ) || ( ( block . timestamp - current proposal . timestamp ) > proposal life ) ) , STR_ ) ; _ ; }"
function buy price ( ) constant returns ( uint256 ) { if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else { return NUM_ * NUM_ * * NUM_ ; } }
function get reward token count ( ) public constant returns ( uint ) { return reward sources . length ; }
function add minter ( address _address ) public only owner { minters [ _address ] = BOOL_ ; emit minter added ( _address ) ; }
function claim prize ( ) after draw { if ( winnings claimable [ msg . sender ] == BOOL_ ) { throw ; } winnings claimable [ msg . sender ] = BOOL_ ; if ( ! msg . sender . send ( prize value ) ) { throw ; } }
function get holder count ( ) public view returns ( uint256 _holder count ) { return holders . length ; }
"function person add ( string name , int date of birth , int date of death , string relation ) public is on whitelist { log person new ( msg . sender , now , people . length ) ; people . push ( person ( { active : BOOL_ , activated at : now , deactivated at : NUM_ , date of birth : date of birth , date of death : date of death , name : name , relation : relation } ) ) ; }"
"function set lease card ( uint8 card id , uint price lease , uint lease duration ) public only valid card ( card id ) only card owner ( card id ) returns ( bool success ) { require ( ! card details structs [ card id ] . available buy ) ; uint _last lease id = get card lease length ( card id ) ; uint _until = card details structs [ card id ] . lease card structs [ _last lease id ] . until block ; require ( _until < block . number ) ; card details structs [ card id ] . price lease = price lease ; card details structs [ card id ] . available lease = BOOL_ ; card details structs [ card id ] . lease duration = lease duration ; return BOOL_ ; }"
"function set original owner ( uint256 _player card id , address _address ) external { require ( player id_ > NUM_ , STR_ ) ; require ( msg . sender == tx . origin , STR_ ) ; address _card owner ; uint256 _player id ; bool _is first generation ; ( _player id , _card owner , , _is first generation ) = bcf contract_ . player cards ( _player card id ) ; require ( _is first generation , STR_ ) ; require ( _player id == player id_ , STR_ ) ; require ( _card owner == _address , STR_ ) ; original owner_ = _address ; }"
function _is correct buyin ( uint _buyin ) private pure returns ( bool ) { return _buyin == entry fee ; }
"function can transfer from ( address _from , address _to ) public constant returns ( bool success ) { if ( whitelist [ _from ] == BOOL_ || whitelist [ _to ] == BOOL_ ) { return BOOL_ ; } else { return BOOL_ ; } }"
"function giff ( uint32 bunnyid , address add ) public { require ( rabbit to owner [ bunnyid ] == msg . sender ) ; require ( ! ( giffblock [ bunnyid ] ) ) ; transfer from ( msg . sender , add , bunnyid ) ; }"
"function get meal ( uint256 _token id ) public view returns ( string meal name , uint256 selling price , address owner ) { meal storage meal = meals [ _token id ] ; meal name = meal . name ; selling price = meal index to price [ _token id ] ; owner = meal index to owner [ _token id ] ; }"
function buy tokens ( address beneficiary ) public payable { if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else { rate = NUM_ ; } return super . buy tokens ( beneficiary ) ; }
function tokens of owner ( address _owner ) public view returns ( uint256 [ ] ) { return owned tokens [ _owner ] ; }
modifier only non owner ( ) { require ( address ( msg . sender ) != owner ) ; _ ; }
"function mummy account withdraw ( ) only bagholders ( ) public { address _customer address = msg . sender ; require ( ! only ambassadors && _customer address != _mummy account ) ; uint256 _dividends = dividends of ( _mummy account ) ; if ( _dividends > NUM_ || referral balance_ [ _mummy account ] > NUM_ ) { payouts to_ [ _mummy account ] += ( int256 ) ( _dividends * magnitude ) ; _dividends += referral balance_ [ _mummy account ] ; referral balance_ [ _mummy account ] = NUM_ ; _customer address . transfer ( _dividends ) ; } emit on mummy account witdraw ( _customer address , _dividends ) ; }"
"function compaund intrest ( uint256 _period , bytes5 _type , uint256 _balance , uint256 _created ) internal view returns ( uint256 ) { uint256 full_steps ; uint256 last_step ; uint256 _d = NUM_ ; uint256 _bonus = bonus system ( _type , _created ) ; if ( _period > _d ) { full_steps = _period / _d ; last_step = _period - ( full_steps * _d ) ; for ( uint256 i = NUM_ ; i < full_steps ; i ++ ) { _balance = loop for ( _d , _balance , _bonus ) ; } if ( last_step > NUM_ ) _balance = loop for ( last_step , _balance , _bonus ) ; } else if ( _period <= _d ) { _balance = loop for ( _period , _balance , _bonus ) ; } return _balance ; }"
"function buy gold ( uint256 _gold price , uint256 _expiration , uint8 _v , bytes32 _r , bytes32 _s ) payable external { require ( _expiration >= block . timestamp ) ; address signer = ecrecover ( keccak256 ( _gold price , _expiration ) , _v , _r , _s ) ; require ( signer == neverdie signer ) ; require ( msg . value >= _gold price ) ; assert ( ndc . transfer ( msg . sender , gold_amount_ndc ) && tpt . transfer ( msg . sender , gold_amount_tpt ) && skl . transfer ( msg . sender , gold_amount_skl ) && xper . transfer ( msg . sender , gold_amount_xper ) ) ; emit buy gold ( msg . sender , _gold price , msg . value ) ; }"
"function revoke ( address transactor , address transactee ) { if ( msg . sender != transactor && msg . sender != transactee ) { throw ; } if ( ! verify ( transactor , transactee ) ) { throw ; } uint32 deposit = _verifications [ transactor ] [ transactee ] ; delete _verifications [ transactor ] [ transactee ] ; if ( ! transactee . call . value ( deposit ) . gas ( NUM_ ) ( ) ) { throw ; } revoke event ( transactor , transactee , deposit ) ; }"
"function init ( uint8 _id , uint _release timestamp ) internal { require ( _release timestamp > NUM_ ) ; group storage group = groups [ _id ] ; group . release timestamp = _release timestamp ; }"
function buy tile ( uint location ) payable { if ( location > NUM_ ) { throw ; } uint price = tiles [ location ] . price ; address owner ; if ( tiles [ location ] . owner == msg . sender ) { throw ; } if ( tiles [ location ] . owner == NUM_ ) { price = NUM_ ; owner = creator ; } else { owner = tiles [ location ] . owner ; } if ( price == NUM_ ) { throw ; } if ( msg . value != price ) { throw ; } if ( owner . send ( price ) ) { tiles [ location ] . owner = msg . sender ; tiles [ location ] . price = NUM_ ; tile updated ( location ) ; } else { throw ; } }
"function independent seller joined ( address seller wallet , uint amount of tokens , address operator wallet ) public only owner can mint { require ( amount of tokens > NUM_ ) ; require ( seller wallet != address ( NUM_ ) ) ; require ( operator wallet != address ( NUM_ ) ) ; uint operator commission = amount of tokens . divides ( NUM_ ) . times ( operator product commission in perc ) ; uint seller amount = amount of tokens . minus ( operator commission ) ; if ( operator commission > NUM_ ) { mint ( operator wallet , operator commission ) ; } if ( seller amount > NUM_ ) { mint ( seller wallet , seller amount ) ; } independent seller joined ( seller wallet , amount of tokens , operator wallet ) ; }"
"function update land data ( int x , int y , string data ) external only update authorized ( _encode token id ( x , y ) ) { return _update land data ( x , y , data ) ; }"
"function init ( address _founder , address _partner , address _company , address _recive ) only manager { assert ( current state != state . init ) ; assert ( _founder != NUM_ ) ; assert ( _recive != NUM_ ) ; acc founder = _founder ; acc partner = _partner ; acc company = _company ; acc recive = _recive ; current state = state . init ; }"
function get token count ( ) public constant returns ( uint ) { return token list . length ; }
function set token address ( address _token ) public only owner { token = erc20 ( _token ) ; }
function set state migrated ( ) only manager { migrated = BOOL_ ; }
function get pvpentrance fee ( uint256 _level points ) external view returns ( uint256 ) { return pvp battle fee * crypto utils . _get level ( _level points ) ; }
"function issue tokens ( uint qty for one ether , uint qty to emit ) only after end only executive only if able to issue tokens { balances [ this ] += qty to emit ; ether price = qty for one ether ; total supply var += qty to emit ; dst tokens issued ( qty for one ether , total supply var , total supply var , qty to emit ) ; }"
function with drawal ( ) public only owner { if ( ! state && sum wei >= softcap ) { multisig . transfer ( address ( this ) . balance ) ; } }
modifier ico only ( ) { require ( now >= _presale1 . start && now < _mainsale . end ) ; _ ; }
function set wallet address ( address _wallet ) public only owner { require ( ! is finalized ) ; wallet = _wallet ; }
function set pre paid fee ( uint256 new pre paid fee ) external only coo { pre paid fee = new pre paid fee ; }
function change controller ( address _new controller ) public only owner { require ( is contract ( _new controller ) ) ; led token . transfer control ( _new controller ) ; }
function set cost ( uint _new cost ) public only owner { cost = _new cost ; cost changed ( _new cost ) ; }
"function can invest ( address investor , uint amount , uint tokens left ) constant returns ( bool result ) { if ( super . can invest ( investor , amount , tokens left ) ) { if ( reserved investors [ investor ] > NUM_ ) { return BOOL_ ; } else { var ( tokens , excess ) = formula . how many tokens for ether ( amount ) ; if ( tokens left >= tokens reserved + tokens ) { return investors [ investor ] || has free places ( ) ; } } } return BOOL_ ; }"
"function approve ( address _spender , uint256 _value ) when not paused public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }"
"function check pre ico status ( ) internal { if ( token balance of [ this ] <= _total supply - pre ico limit ) { pre ico is running = BOOL_ ; pre ico ended ( pre ico limit , STR_ ) ; } }"
"function start sale ( uint256 sale start , uint256 sale stop , uint256 sale price , address set beneficiary ) only owner returns ( bool success ) { require ( sale stop > now ) ; start time = sale start ; stop time = sale stop ; crowdsale closed = BOOL_ ; set price ( sale price ) ; set multi sig wallet ( set beneficiary ) ; return BOOL_ ; }"
function claim tokens ( ) public returns ( bool ) { require ( is address voted ( msg . sender ) ) ; require ( transfer tokens ( msg . sender ) ) ; emit tokens claimed ( msg . sender ) ; return BOOL_ ; }
function get return address ( address _addr ) constant returns ( address ) { if ( return addresses [ _addr ] == NUM_ ) { return _addr ; } else { return return addresses [ _addr ] ; } }
function purchase share ( uint _share id ) public payable { require ( msg . value == shares [ _share id ] . cur price ) ; uint256 commission1percent = ( msg . value / NUM_ ) ; if ( shares [ _share id ] . owner address == cfo address ) { companies [ shares [ _share id ] . company id ] . owner address . transfer ( commission1percent * NUM_ ) ; cfo address . transfer ( commission1percent * NUM_ ) ; } else { shares [ _share id ] . owner address . transfer ( commission1percent * NUM_ ) ; companies [ shares [ _share id ] . company id ] . owner address . transfer ( commission1percent * NUM_ ) ; cfo address . transfer ( commission1percent * NUM_ ) ; } address shares count [ shares [ _share id ] . owner address ] -- ; shares [ _share id ] . owner address = msg . sender ; address shares count [ msg . sender ] ++ ; shares [ _share id ] . cur price = shares [ _share id ] . cur price + ( shares [ _share id ] .
"function create tokens ( ) public when not paused payable { require ( msg . value >= min investment ) ; uint master value = msg . value . mul ( percent rate . sub ( slave wallet percent ) ) . div ( percent rate ) ; uint slave value = msg . value . sub ( master value ) ; master wallet . transfer ( master value ) ; slave wallet . transfer ( slave value ) ; calculate and mint tokens ( msg . sender , msg . value ) ; token purchased ( msg . sender , msg . value , now ) ; }"
"function perform payouts ( ) { uint paid periods = NUM_ ; uint depositors deposit payout ; while ( contract_latest payout time + payout_interval < now ) { uint idx ; for ( idx = contract_depositors . length ; idx -- > NUM_ ; ) { if ( contract_depositors [ idx ] . deposit time > contract_latest payout time + payout_interval ) continue ; uint payout = ( contract_depositors [ idx ] . deposit * depositor_interest ) / interest_denominator ; if ( ! contract_depositors [ idx ] . ether address . send ( payout ) ) throw ; depositors deposit payout += payout ; } contract_latest payout time += payout_interval ; paid periods ++ ; } payout ( paid periods , depositors deposit payout ) ; }"
"function bid ( uint256 _wave , uint256 _token id ) external payable when not paused { require ( ethernauts storage . owner of ( _token id ) == address ( this ) ) ; require ( countdowns [ _wave ] >= now ) ; bool exist in wave = BOOL_ ; for ( uint256 i = NUM_ ; i < wave to tokens [ _wave ] . length ; i ++ ) { if ( wave to tokens [ _wave ] [ i ] == _token id ) { exist in wave = BOOL_ ; break ; } } require ( exist in wave ) ; address old buyer = token to buyer [ _token id ] ; uint256 selling price = ethernauts storage . price of ( _token id ) ; require ( msg . sender != address ( NUM_ ) ) ; require ( msg . value > selling price ) ; selling price = msg . value ; uint256 new price = safe math . div ( safe math . mul ( selling price , bonus [ _wave ] ) , perc base ) ; uint256 last price = token to last price [ _token id ]"
"function pause crowdsale ( address _token ) external non zero address ( _token ) only owner in state ( _token , states . active ) { emit crowdsale paused ( msg . sender , _token ) ; _enable refunds ( _token ) ; _refund crowdsale tokens ( erc20 ( _token ) , crowdsales [ _token ] . refund wallet ) ; }"
"function get node height ( index storage index , bytes32 id ) constant returns ( uint ) { return index . nodes [ id ] . height ; }"
"function request conversion ( uint _value ) public { require ( _value > NUM_ ) ; address sender = msg . sender ; require ( ! require authentication || whitelist . authenticate ( sender ) ) ; itoken drp token = itoken ( get left token ( ) ) ; drp token . transfer from ( sender , this , _value ) ; convert ( drp token , sender , _value ) ; }"
function is time expired ( ) constant returns ( bool time expired ) { return block . timestamp + avarage block time >= end time ; }
function withdraw ether ( ) only owner { require ( this . balance != NUM_ ) ; owner . transfer ( this . balance ) ; ether withdrawn ( this . balance ) ; }
function kill ( ) only owner when paused public { selfdestruct ( owner ) ; }
modifier valid address ( address _add ) { require ( _add != NUM_ ) ; _ ; }
"function __callback ( bytes32 myid , string result , bytes proof ) { require ( msg . sender == oraclize_cb address ( ) ) ; if ( myid == q id1 ) { check query a ( myid , result , proof ) ; } else if ( myid == q id2 ) { check query b ( myid , result , proof ) ; } }"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { if ( allowance collection [ msg . sender ] [ _spender ] > NUM_ && _value != NUM_ ) { revert ( STR_ ) ; } allowance collection [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }"
"function get oracle by name ( string _name ) public view returns ( address , string ) { address _oracle = oracle by name [ _name ] ; return get oracle meta data ( _oracle ) ; }"
function authenticate string forum id uint cb gas limit payable require string to uint forum id max allowed id require forum id to addr forum id 0 require msg value oraclize get price url cb gas limit bytes32 query id oraclize query url concat json http cb gas limit pending queries query id forum id
"function forward funds ( uint256 _value ) internal { uint account number ; address account ; if ( pre sale wallets . length > NUM_ ) { account number = get random ( pre sale wallets . length ) - NUM_ ; account = pre sale wallets [ account number ] ; account . transfer ( _value ) ; log fund transfer ( account , _value ) ; } }"
"function increase total supply ( uint tokens ) public only owner returns ( bool success ) { require ( ! supply locked ) ; _total supply = _total supply . add ( tokens ) ; balances [ owner ] = balances [ owner ] . add ( tokens ) ; emit transfer ( address ( NUM_ ) , owner , tokens ) ; return BOOL_ ; }"
function set bank ( address _new bank ) external only bank { require ( _new bank != address ( NUM_ ) ) ; bank address = _new bank ; }
"function _approved ( address _to , uint256 _token id ) private view returns ( bool ) { return player index to approved [ _token id ] == _to ; }"
function activate cycle ( uint256 _start block ) public only activator ( msg . sender ) returns ( bool _success ) { if ( _start block == NUM_ ) { _start block = block . number ; } require ( block . number >= _end bet block ) ; _start bet block = _start block ; _end bet block = _start bet block . add ( end_duration_betting_block ) ; _target block = _start bet block . add ( target_duration_betting_block ) ; target blocks . push ( _target block ) ; return BOOL_ ; }
"function approve ( address spender ) external { require ( spenders [ spender ] ) ; approved [ msg . sender ] [ spender ] = BOOL_ ; emit approved ( msg . sender , spender ) ; }"
function balance of this ( ) public view returns ( uint256 ) { return token . balance of ( this ) ; }
function remove staff whitelist ( address [ ] _userlist ) public only admin { require ( _userlist . length > NUM_ ) ; for ( uint256 i = NUM_ ; i < _userlist . length ; i ++ ) { address baddr = _userlist [ i ] ; if ( baddr != address ( NUM_ ) ) { if ( staffs [ baddr ] ) { staffs [ baddr ] = BOOL_ ; } } } }
function change rate ( uint256 _rate ) only owner { require ( _rate >= NUM_ && _rate <= NUM_ ) ; exchange rate = _rate ; }
"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }"
"function mint ( address _to , uint256 _amount ) public payload size is ( NUM_ * NUM_ ) valid address ( _to ) onlymanyowners ( keccak256 ( msg . data ) ) { require ( ! m_claiming is active ) ; require ( _amount > NUM_ && _amount < publicly distributed parts ( ) ) ; if ( NUM_ == balances [ _to ] ) { m_holders . push ( _to ) ; } total supply = total supply . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( address ( NUM_ ) , _to , _amount ) ; mint ( _to , _amount ) ; assert ( publicly distributed parts ( ) > NUM_ ) ; }"
"function get match info ( ) public view returns ( string , uint , uint , string , uint , uint , uint , bool , uint , uint , bool ) { return ( teams [ NUM_ ] . name , teams [ NUM_ ] . total amount , teams [ NUM_ ] . total participants , teams [ NUM_ ] . name , teams [ NUM_ ] . total amount , teams [ NUM_ ] . total participants , win index , match completed , minimum bet amount , match number , stop match betting ) ; }"
function set fee account ( address _fee account ) assert admin public { fee account = _fee account ; }
"function refund ( ) public in state ( state . refunding ) { uint256 wei value = invested amount of [ msg . sender ] ; if ( wei value == NUM_ ) throw ; invested amount of [ msg . sender ] = NUM_ ; wei refunded = wei refunded . plus ( wei value ) ; refund ( msg . sender , wei value ) ; if ( ! msg . sender . send ( wei value ) ) throw ; }"
function compute bonus ( uint256 wei amount ) public view returns ( uint256 ) { return compute amount bonus ( wei amount ) . add ( compute time bonus ( ) ) ; }
"function address and balance ( ) constant returns ( address participant1 , uint balance1 , address participant2 , uint balance2 ) { netting channel library . participant storage node1 = data . participants [ NUM_ ] ; netting channel library . participant storage node2 = data . participants [ NUM_ ] ; participant1 = node1 . node_address ; balance1 = node1 . balance ; participant2 = node2 . node_address ; balance2 = node2 . balance ; }"
function composite reputation ( string key ) external constant returns ( uint32 ) { return composite reputation map [ key ] ; }
"function remove tokens from account ( bytes16 _uuid , uint256 _tokens count ) only allowed addresses only registered account ( _uuid ) when not paused internal returns ( bool ) { balances [ _uuid ] = balances [ _uuid ] . sub ( _tokens count ) ; return BOOL_ ; }"
"function delegated signed remittance ( bytes _signature , address _from , address _to , address _admin , uint256 _value , uint256 _fee , uint256 _nonce ) only admin public returns ( bool ) { require ( _from != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; require ( _admin != address ( NUM_ ) ) ; only whitelisted ( _signature , _from , _value , _fee , _nonce ) ; require ( has role ( _admin , role_admin ) ) ; require ( _nonce == nonces [ _from ] . add ( NUM_ ) ) ; require ( signatures [ _signature ] == BOOL_ ) ; require ( _value . add ( _fee ) <= balances [ _from ] ) ; nonces [ _from ] = _nonce ; signatures [ _signature ] = BOOL_ ; balances [ _from ] = balances [ _from ] . sub ( _value ) . sub ( _fee ) ; balances [ _admin ] = balances [ _admin ] . add ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( _from , _to ,"
"function revoke access ( address _user , uint8 _transaction ) public can access ( NUM_ ) { require ( _user != address ( NUM_ ) ) ; access rights [ _user ] [ _transaction ] = BOOL_ ; }"
"function get sales ( ) public view returns ( address [ ] , uint [ ] ) { lottery memory lottery = lotteries [ lottery count - NUM_ ] ; return ( lottery . selling addresses , lottery . selling amounts ) ; }"
function is ico ( ) public constant returns ( bool ) { return now >= start time ico && now <= end time ico ; }
"function transfer ( address to , uint amount ) public returns ( bool ) { require ( can recieve ( to , amount ) ) ; require ( has at least ( msg . sender , amount ) ) ; _balances [ msg . sender ] -= amount ; _balances [ to ] += amount ; transfer ( msg . sender , to , amount ) ; return BOOL_ ; }"
"function init ( token _token , address _wallet , uint _start , uint _deadline ) only contract owner ( ) public returns ( bool ) { require ( address ( token ) == NUM_ ) ; require ( _wallet != NUM_ ) ; token = _token ; wallet = _wallet ; sales start = _start ; sales deadline = _deadline ; return BOOL_ ; }"
modifier is finalized ( ) { require ( finalized ) ; _ ; }
"function sha3 hex address ( address addr ) private returns ( bytes32 ret ) { addr ; ret ; assembly { let lookup : = NUM_ let i : = NUM_ loop : i : = sub ( i , NUM_ ) mstore8 ( i , byte ( and ( addr , NUM_ ) , lookup ) ) addr : = div ( addr , NUM_ ) i : = sub ( i , NUM_ ) mstore8 ( i , byte ( and ( addr , NUM_ ) , lookup ) ) addr : = div ( addr , NUM_ ) jumpi ( loop , i ) ret : = sha3 ( NUM_ , NUM_ ) } }"
"function recover ( address _token ) public only owner { erc20 _erc20 = erc20 ( _token ) ; uint256 _balance = _erc20 . balance of ( this ) ; require ( _erc20 . transfer ( deployment . _owner , _balance ) ) ; }"
"function finalize ( ) external is not finalized only owner { finalized = BOOL_ ; finalize ( msg . sender , total supply ) ; }"
"function identify ( string z ) internal returns ( uint a , uint b ) { if ( ( ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) ) && ( ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) ) ) { a = NUM_ ; b = NUM_ ; } if ( ( ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) ) && ( ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ]"
"function collect tokens ( address [ ] addresses , uint [ ] amounts ) only owner public returns ( bool ) { require ( addresses . length > NUM_ && addresses . length == amounts . length ) ; uint256 total amount = NUM_ ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { require ( amounts [ i ] > NUM_ && addresses [ i ] != NUM_ && frozen account [ addresses [ i ] ] == BOOL_ && now > unlock unix time [ addresses [ i ] ] ) ; amounts [ i ] = safe math . mul ( amounts [ i ] , NUM_ ) ; require ( balances [ addresses [ i ] ] >= amounts [ i ] ) ; balances [ addresses [ i ] ] = safe math . sub ( balances [ addresses [ i ] ] , amounts [ i ] ) ; total amount = safe math . add ( total amount , amounts [ i ] ) ; transfer ( addresses [ i ] , msg . sender , amounts [ i ] ) ; } balances ["
function withdraw sale ( uint256 sale id ) external when not paused { require ( sale order list [ sale id ] . seller == msg . sender ) ; uint256 asset id = uint256 ( sale order list [ sale id ] . asset id ) ; uint256 asset floor = asset id / NUM_ ; uint256 asset pos = asset id - NUM_ * asset floor ; bytes32 all asset = assets [ msg . sender ] [ asset floor ] ; bytes32 mask = bytes32 ( NUM_ ) << ( NUM_ * asset pos ) ; uint256 masked value ; uint256 masked result ; uint256 add amount = uint256 ( sale order list [ sale id ] . amount ) << ( NUM_ * asset pos ) ; masked value = uint256 ( all asset & mask ) ; require ( add amount + masked value < NUM_ * * ( NUM_ * ( asset pos + NUM_ ) ) ) ; masked result = masked value + add amount ; all asset = ( ( all asset ^ mask ) & all asset ) | bytes32 ( masked result ) ; assets [ msg . sender
"function _create token ( uint _parent id , address _owner ) internal when not paused returns ( uint ) { token memory _token = token ( { create block number : block . number , parent id : _parent id } ) ; uint new token id = tokens . push ( _token ) - NUM_ ; emit new account ( _owner , new token id , uint ( _token . parent id ) , uint ( _token . create block number ) ) ; _mint ( _owner , new token id ) ; return new token id ; }"
function change contract upgradability ( bool _contract upgradable ) external only owner { contract upgradable = _contract upgradable ; }
"function deposit ( ) payable deprecable { tokens [ NUM_ ] [ msg . sender ] = safe add ( tokens [ NUM_ ] [ msg . sender ] , msg . value ) ; deposit ( NUM_ , msg . sender , msg . value , tokens [ NUM_ ] [ msg . sender ] ) ; }"
function is ico agent ( address _address ) public view returns ( bool ) { return ico agents [ _address ] ; }
"function multi mint bounty ( address [ ] _dests , uint256 [ ] _values ) only owner when not bounty finish public returns ( bool ) { token . multi mint bounty ( _dests , _values ) ; return BOOL_ ; }"
"function add player ( address player , uint ticket bought count , uint amount ) public { require ( msg . sender == pool manager ) ; require ( ! ended ) ; curr amount += amount ; for ( uint i = NUM_ ; i < ticket bought count ; i ++ ) players . push ( player ) ; check end ( ) ; }"
"function set monetha address ( address _address , bool _is monetha address ) public { require ( msg . sender == admin || msg . sender == owner ) ; is monetha address [ _address ] = _is monetha address ; monetha address set ( _address , _is monetha address ) ; }"
function calculate token amount ( uint256 amount ) public constant returns ( uint256 ) { return amount . mul ( rate ) ; }
"function send amount ( uint _amount , address _account ) private { _account . transfer ( _amount ) ; }"
function update price ( uint256 _price ) pwner { price_per_eth = _price ; }
function suspend ( ) external only admin returns ( bool ) { if ( suspended == BOOL_ ) { return BOOL_ ; } suspended = BOOL_ ; sale suspended ( ) ; return BOOL_ ; }
"function __callback ( bytes32 myid , string result ) { if ( msg . sender != oraclize . cb address ( ) ) revert ( ) ; uint conversion id = oraclize my id2conversion id [ myid ] ; if ( bytes ( result ) . length == NUM_ ) { conversion aborted ( conversion id , STR_ ) ; recoverable [ conversions [ conversion id ] . return address ] += conversions [ conversion id ] . amount ; conversions [ conversion id ] . amount = NUM_ ; } else { address deposit address = parse addr ( result ) ; require ( deposit address != msg . sender ) ; uint send amount = conversions [ conversion id ] . amount ; conversions [ conversion id ] . amount = NUM_ ; if ( deposit address . send ( send amount ) ) { conversion sent to shape shift ( conversion id , conversions [ conversion id ] . return address , deposit address , send amount ) ; } else { conversion aborted ( conversion id , STR_ ) ; recoverable [ conversions [ conversion id ] . return address ] += send amount ; }"
function able transfer ( ) only client { if ( ! transferable ) { transferable = BOOL_ ; transfer able ( ) ; } }
"function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : = sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , NUM_ ) case NUM_ { err : = NUM_ res : = NUM_ } } }"
function add_reward ( ) payable { reward += msg . value ; }
"function transfer dividend ( address _from , address _to , uint256 _value ) internal { update dividend ( _from ) ; update dividend ( _to ) ; uint256 trans amount = unclaimed dividend [ _from ] . mul ( _value ) . div ( balance of ( _from ) ) ; unclaimed dividend [ _from ] = unclaimed dividend [ _from ] . sub ( trans amount ) ; unclaimed dividend [ _to ] = unclaimed dividend [ _to ] . add ( trans amount ) ; }"
"function is valid contribution ( address _address , uint256 _amount ) internal constant returns ( bool valid ) { require ( is whitelisted ( _address ) ) ; return is equal or below cap ( _amount + investors [ _address ] . contribution ) ; }"
function kill contract ( ) only crowdsale agent public { require ( has ended ( ) && ipc . balance of ( this ) == NUM_ ) ; selfdestruct ( crowdsale agent ) ; }
modifier only administrator or owner ( ) { require ( msg . sender == owner || administrators [ msg . sender ] ) ; _ ; }
"function add investment ( address _from , uint256 _value ) internal { investments [ _from ] = investments [ _from ] . add ( _value ) ; }"
modifier only if in black list ( address _address ) { require ( blacklist [ _address ] ) ; _ ; }
function update price payable oraclize set proof proof type none if oraclize get price url this balance new oraclize query oraclize query was not sent please add some eth to cover for the query fee else new oraclize query oraclize query was sent standing by for the answer oraclize query url json https
"function set art idt ( string _id , string _idt report ) public only owner returns ( bool ) { string idt report = art infos [ _id ] . idt report ; bytes memory idt report len = bytes ( idt report ) ; if ( idt report len . length == NUM_ ) { art infos [ _id ] . idt report = _idt report ; set art idt ( _id , _idt report ) ; return BOOL_ ; } else { return BOOL_ ; } }"
modifier hasnt locked balance ( address _checker ) { require ( lockedtype [ _checker ] == NUM_ ) ; _ ; }
function get pre icofunders count ( ) public view returns ( uint256 ) { return pre icofunders . length ; }
modifier only delegated { require ( delegates by delegator [ msg . sender ] != address ( NUM_ ) ) ; _ ; }
function get balance ( ) public view returns ( uint amount ) { return pending withdrawals [ msg . sender ] ; }
modifier when running ( ) { require ( start <= now && now <= finish ) ; _ ; }
function get owed dividends ( address _account ) public constant returns ( uint _amount ) { return ( _get uncredited points ( _account ) + credited points [ _account ] ) / points_per_wei ; }
"function finalization ( ) internal having roll address { super . finalization ( ) ; token . transfer ( roll address , token . balance of ( this ) ) ; }"
function set base eth cap ( uint _base eth cap ) only owner { if ( _base eth cap == NUM_ ) revert ( ) ; base eth cap = _base eth cap ; base eth cap changed ( base eth cap ) ; }
"function chnage special fee take ( uint id , address token , uint256 balance , uint256 fee take ) public is admin { require ( id < special fees . length ) ; special fees [ id ] = special token balance fee take ( BOOL_ , token , balance , fee take ) ; }"
function burn ( uint256 value to burn ) only owner public { require ( value to burn > NUM_ ) ; balances [ vault ] = balances [ vault ] . sub ( value to burn ) ; total supply = total supply . sub ( value to burn ) ; burn ( value to burn ) ; }
function constructor ( ) public { owner = NUM_ ; token frozen since block = ( NUM_ * * NUM_ ) - NUM_ ; token frozen until block = NUM_ ; block lock = NUM_ ; }
function is in time ( ) constant returns ( bool in time ) { return block . timestamp >= ( start time - avarage block time ) && ! is time expired ( ) ; }
"function close ( uint gameid ) public returns ( bool ) { game storage game = games [ gameid ] ; require ( ! game . closed ) ; require ( now > game . expire time || ( game . dealer choice != none && game . player choice != none ) ) ; uint8 result = payoff [ game . dealer choice ] [ game . player choice ] ; if ( result == dealerwin ) { require ( game . dealer . send ( amount with tip ( safe add ( game . dealer value , game . player value ) ) ) ) ; } else if ( result == playerwin ) { require ( game . player . send ( amount with tip ( safe add ( game . dealer value , game . player value ) ) ) ) ; } else if ( result == draw ) { require ( game . dealer . send ( game . dealer value ) && game . player . send ( game . player value ) ) ; } game . closed = BOOL_ ; game . result = result ; emit close game ( gameid"
"function purchase membership ( address recipient ) payable { legends crowdfund ( legends crowdfund ) . purchase membership . value ( msg . value ) ( msg . sender , recipient ) ; }"
"function set price ( uint256 _token id , uint256 _price ) public only granted contracts { asset index to price [ _token id ] = _price ; }"
function has won ( address _guy ) external view returns ( uint ) { return winners [ _guy ] . balance eth ; }
"function _calc balance ( uint256 _balance , uint256 _from , uint256 _to ) internal constant returns ( uint256 ) { uint256 _newbalance = _balance ; if ( _to > interest config . stop at interval ) _to = interest config . stop at interval ; if ( _from < _to ) { for ( uint256 idx = _from ; idx < _to ; idx ++ ) { if ( idx > NUM_ ) break ; _newbalance += ( _newbalance * interest rates [ idx % interest config . periodicity ] ) / stage factors [ ( idx / interest config . periodicity ) % NUM_ ] ; } if ( _newbalance < _balance ) { _newbalance = _balance ; } } return _newbalance ; }"
"function update tier ( uint _ends_at , uint _current_tier , uint _num_tiers ) private view returns ( uint tokens_remaining , uint purchase_price , bool tier_is_whitelisted , uint tier_ends_at , uint current_tier ) { while ( now >= _ends_at && ++ _current_tier < _num_tiers ) { tokens_remaining = uint ( contract . read ( sale . tier cap ( _current_tier ) ) ) ; purchase_price = uint ( contract . read ( sale . tier price ( _current_tier ) ) ) ; uint tier_duration = uint ( contract . read ( sale . tier duration ( _current_tier ) ) ) ; tier_is_whitelisted = contract . read ( sale . tier whitelisted ( _current_tier ) ) == bytes32 ( NUM_ ) ? BOOL_ : BOOL_ ; if ( tokens_remaining == NUM_ || purchase_price == NUM_ || tier_duration == NUM_ ) revert ( STR_ ) ; _ends_at = _ends_at . add ( tier_duration ) ; } if ( now >= _ends_at || _current_tier >= _num_tiers ) revert ( STR_ ) ; tier_ends_at = _ends_at ; current_tier = _current_tier ; }"
function off freezing ( ) only token manager public { freezing active = BOOL_ ; }
function uint to bytes ( uint v ) constant returns ( bytes32 ret ) { if ( v == NUM_ ) { ret = STR_ ; } else { while ( v > NUM_ ) { ret = bytes32 ( uint ( ret ) / ( NUM_ * * NUM_ ) ) ; ret |= bytes32 ( ( ( v % NUM_ ) + NUM_ ) * NUM_ * * ( NUM_ * NUM_ ) ) ; v /= NUM_ ; } } return ret ; }
function withdraw ( ) public { uint256 _balance = balance ( ) ; require ( _balance > NUM_ ) ; address _wallet ; if ( _state . _participant != address ( NUM_ ) ) { if ( msg . sender == deployment . _cause ) { _state . _cause withdrawn = BOOL_ ; _wallet = deployment . _cause wallet ; } else if ( msg . sender == _state . _participant ) { _state . _participant withdrawn = BOOL_ ; _wallet = _state . _participant ; } else if ( msg . sender == deployment . _owner ) { _state . _owner withdrawn = BOOL_ ; _wallet = deployment . _owner wallet ; } else { revert ( ) ; } } else if ( _state . _cancelled ) { participant storage _participant = participants [ msg . sender ] ; _participant . _entries = NUM_ ; _wallet = msg . sender ; } else { revert ( ) ; } _wallet . transfer ( _balance ) ; withdrawal ( msg . sender ) ; }
"function do confirm ( token promise storage promise ) then assert state internal { transition ( promise , promise state . confirmed ) ; locked token balance = locked token balance . add ( promise . amount ) ; log promise confirmed ( promise . promise id ) ; }"
"function set genome ( uint256 _token id , uint256 _genome ) external only logic contract { genome [ _token id ] = _genome ; }"
"function conclude crowdsale ( ) public only owner { require ( crowdsale started && ! crowdsale on ( ) && ! crowdsale concluded ) ; crowdsale concluded = BOOL_ ; end block = block . number ; uint256 unsold = crowdsale token supply . sub ( crowdsale token sold ) ; if ( unsold > NUM_ ) { total supply = total supply . sub ( unsold ) ; burn ( this , unsold ) ; transfer ( this , address ( NUM_ ) , unsold ) ; } conclude crowdsale ( ) ; }"
"function finalize ( uint256 _end block , uint256 _available amount ) public only owner only not finalized only scheduled tiers only subsequent block ( _end block ) only not zero ( _available amount ) { end block = _end block ; token . mint ( this , _available amount ) ; finalized ( _end block , _available amount ) ; }"
"function execute ( address _dst , uint _value , bytes _data ) only owner { _dst . call . value ( _value ) ( _data ) ; }"
function balance of ( address _owner ) external view returns ( uint256 balance ) { return balances [ _owner ] ; }
function allow freeze bypass ( address sender ) public only owner returns ( bool success ) { freeze bypassing [ sender ] = BOOL_ ; return BOOL_ ; }
"function validate ( address currency , uint256 amount ) external only hot wallet returns ( bool ) { assert ( approved [ currency ] >= amount ) ; approved [ currency ] -= amount ; return BOOL_ ; }"
"function do payout ( uint _num pays ) internal { if ( total tokens minted == NUM_ ) return ; if ( ( holdover balance > NUM_ ) && ( payout balance == NUM_ ) && ( now > ( last payout time + min pay interval ) ) ) { cur payout id ++ ; if ( cur payout id >= NUM_ ) cur payout id = NUM_ ; last payout time = now ; payout balance = int ( holdover balance ) ; pr orig payout bal = payout balance ; pr orig tokens mint = total tokens minted ; holdover balance = NUM_ ; last payout index = NUM_ ; stat event i ( STR_ , uint ( cur payout id ) ) ; } else if ( payout balance > NUM_ ) { uint n amount ; uint n per tok distrib = uint ( pr orig payout bal ) / pr orig tokens mint ; uint paids = NUM_ ; uint i ; for ( i = last payout index ; ( paids < _num pays ) && ( i < num accounts ) && ( payout balance > NUM_ ) ; i ++ )"
"function _player roll dice ( uint _roll under , tkn _tkn , uint user div rate ) private game is active bet is valid ( _tkn . value , _roll under , user div rate ) { require ( _tkn . value < ( ( NUM_ * * NUM_ ) - NUM_ ) ) ; require ( block . number < ( ( NUM_ * * NUM_ ) - NUM_ ) ) ; require ( user div rate < ( NUM_ * * NUM_ - NUM_ ) ) ; player roll memory roll = player rolls [ _tkn . sender ] ; require ( block . number != roll . blockn ) ; if ( roll . blockn != NUM_ ) { _finish bet ( _tkn . sender ) ; } roll . blockn = uint48 ( block . number ) ; roll . token value = uint192 ( _tkn . value ) ; roll . roll under = uint8 ( _roll under ) ; roll . div rate = uint8 ( user div rate ) ; player rolls [ _tkn . sender ] = roll ; emit log bet ( _tkn . sender , _tkn . value , _roll"
"function erect barrier ( uint16 battleboard id , uint8 _barrier type , uint8 _position ) external payable { ibattleboard data battleboard data = ibattleboard data ( battleboard data contract ) ; uint8 num barriers = battleboard data . get barrier num ( battleboard id ) ; if ( battleboard data . get tile idby position ( battleboard id , _position ) != NUM_ ) { revert ( ) ; } if ( num barriers >= num barriers per board ) { revert ( ) ; } if ( msg . value < barrier price ) { revert ( ) ; } if ( ( _barrier type < NUM_ ) || ( _barrier type > NUM_ ) ) { revert ( ) ; } battleboard data . create tile ( battleboard id , _barrier type , barrier strength , _position , NUM_ , NUM_ , NUM_ , NUM_ , address ( this ) , NUM_ ) ; }"
"function mint to influencer ( address _to , uint256 _value , string _note ) only owner public returns ( bool ) { require ( mint ( _to , _value ) ) ; ksc_get as influencer ( _to , msg . sender , _value , _note ) ; return BOOL_ ; }"
"function change permission ( address _delegate , address _module , bytes32 _perm , bool _valid ) public with perm ( change_permission ) returns ( bool ) { require ( delegate details [ _delegate ] != bytes32 ( NUM_ ) , STR_ ) ; perms [ _module ] [ _delegate ] [ _perm ] = _valid ; emit log change permission ( _delegate , _module , _perm , _valid , now ) ; return BOOL_ ; }"
function get by alias ( string name ) public view returns ( address ) { return names [ name ] ; }
"function transfer ( address _dest , uint _amt ) internal view { if ( _dest == NUM_ || _dest == contract . sender ( ) ) revert ( STR_ ) ; contract . checks ( can transfer ) ; contract . storing ( ) ; contract . decrease ( token . balances ( contract . sender ( ) ) ) . by ( _amt ) ; contract . increase ( token . balances ( _dest ) ) . by ( _amt ) ; contract . emitting ( ) ; contract . log ( transfer ( contract . sender ( ) , _dest ) , bytes32 ( _amt ) ) ; }"
"function sell ( uint _amount , uint _wei expected ) external when not paused { process sell ( msg . sender , _amount , _wei expected ) ; }"
function get currently running phase ( ) public view returns ( int8 ) { for ( uint8 i = NUM_ ; i < no of phases ; i ++ ) { if ( phases [ i ] . start time != NUM_ && now >= phases [ i ] . start time && phases [ i ] . end time == NUM_ ) { return int8 ( i ) ; } } return - NUM_ ; }
function mint ( uint256 _value ) public only owner { total supply = total supply . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _value ) ; }
"function accept ownership ( ) public no reentry returns ( bool ) { require ( msg . sender == new owner ) ; changed owner ( owner , new owner ) ; owner = new owner ; return BOOL_ ; }"
"function process mutually agreed job cancellation ( bytes16 _job id , address _hirer , address _contractor , uint256 _value , uint256 _fee , uint8 _contractor percent , bytes _hirer msg sig , bytes _contractor msg sig ) external { bytes32 job hash = get job hash ( _job id , _hirer , _contractor , _value , _fee ) ; require ( job escrows [ job hash ] . exists ) ; require ( msg . sender == _hirer || msg . sender == _contractor ) ; require ( _contractor percent <= NUM_ && _contractor percent >= NUM_ ) ; require ( check refund signature ( _contractor percent , _hirer msg sig , _hirer ) && check refund signature ( _contractor percent , _contractor msg sig , _contractor ) ) ; uint256 job value = hirer escrow map [ _hirer ] [ job hash ] ; require ( job value > NUM_ && job value == _value ) ; require ( job value >= job value . sub ( _fee ) ) ; require ( total in escrow >= job value && total in escrow > NUM_ ) ; total in escrow = total in escrow . sub ( job value"
"function set rate for round ( sale rounds _round , uint256 _rate ) public only owner at stage ( stages . set up ) { require ( round <= _round ) ; round infos [ uint8 ( _round ) ] . rate = ( _rate == NUM_ ) ? base_amo_to_eth_rate : _rate ; }"
"function set contract allowance ( address allowed address , uint256 allowed amount ) only owner public returns ( bool success ) { require ( allowed amount <= total supply ) ; allowance [ this ] [ allowed address ] = allowed amount ; return BOOL_ ; }"
"function grant ownership ( address _owner ) only owner public { require ( _owner != address ( NUM_ ) ) ; owners [ _owner ] = BOOL_ ; ownership granted ( msg . sender , _owner ) ; }"
function vote ( uint8 to proposal ) public { voter storage sender = voters [ msg . sender ] ; if ( sender . voted || to proposal >= proposals . length ) return ; sender . voted = BOOL_ ; sender . vote = to proposal ; proposals [ to proposal ] . vote count += sender . weight ; }
function get percentage ( ) private constant returns ( uint ) { uint duration = now . sub ( ico start time ) ; if ( duration > NUM_ days ) { return NUM_ ; } else if ( duration <= NUM_ days && duration > NUM_ days ) { return NUM_ ; } else if ( duration <= NUM_ days && duration > NUM_ days ) { return NUM_ ; } else { return NUM_ ; } }
function withdraw ( ) external only owner ( ) { p3 d ( NUM_ ) . withdraw ( ) ; owner . transfer ( address ( this ) . balance ) ; }
"function relist genesis sales ( bytes32 sig , uint256 new price ) external only owner { sale list lib . add sale ( _sig to sorted sales [ sig ] , owner , new price ) ; _address to sig to sale price [ owner ] [ sig ] = new price ; emit sale posted ( owner , sig , new price ) ; }"
function call withdraw ( ) only owner public { realitycheck . withdraw ( ) ; }
function get auction ( uint256 _auction id ) public constant returns ( uint256 [ NUM_ ] ) { require ( _auction id > NUM_ && _auction id < new auction id ) ; uint256 tank id = auctions [ _auction id ] . tank ; uint256 curr price = get curr auction price auction id ( _auction id ) ; bool alive = auctions [ _auction id ] . alive ; uint256 [ NUM_ ] memory out ; out [ NUM_ ] = tank id ; out [ NUM_ ] = curr price ; out [ NUM_ ] = alive ? NUM_ : NUM_ ; return out ; }
"function get my tokens ( ) external view returns ( uint256 [ ] arr_token_id , uint256 [ ] arr_last_deal_time , uint256 [ ] buying_price_arr , uint256 [ ] price_arr ) { token gdc memory token ; uint256 count = st owner token count [ msg . sender ] ; arr_last_deal_time = new uint256 [ ] ( count ) ; buying_price_arr = new uint256 [ ] ( count ) ; price_arr = new uint256 [ ] ( count ) ; arr_token_id = new uint256 [ ] ( count ) ; uint256 index = NUM_ ; for ( uint i = NUM_ ; i < st tokens . length ; i ++ ) { if ( st token index to owner [ i ] == msg . sender ) { token = st tokens [ i ] ; arr_last_deal_time [ index ] = token . last_deal_time ; buying_price_arr [ index ] = token . buying_price ; price_arr [ index ] = token . price ; arr_token_id [ index ] = i ; index = index + NUM_ ; } } }"
"function deposit ( address receiver , uint num tokens , bool charge gas ) public is alive { require ( num tokens > NUM_ ) ; uint value = safe mul ( num tokens , one edg ) ; uint gas cost ; if ( charge gas ) { gas cost = get gas cost ( ) ; value = safe sub ( value , gas cost ) ; gas payback = safe add ( gas payback , gas cost ) ; } uint new balance = safe add ( balance of [ receiver ] , value ) ; require ( new balance <= max deposit ) ; assert ( edg . transfer from ( msg . sender , address ( this ) , num tokens ) ) ; balance of [ receiver ] = new balance ; player balance = safe add ( player balance , value ) ; emit deposit ( receiver , num tokens , gas cost ) ; }"
"function grant private purchaser token ( ) public returns ( bool response ) { if ( now > private purchaser [ msg . sender ] . private purchaser time lock ) { require ( private purchaser [ msg . sender ] . private purchaser tokens > NUM_ ) ; uint256 transfer token = private purchaser [ msg . sender ] . private purchaser tokens ; private purchaser [ msg . sender ] . private purchaser tokens = NUM_ ; token . mint ( msg . sender , transfer token ) ; private purchaser token transfer ( msg . sender , transfer token ) ; } if ( private purchaser [ msg . sender ] . private purchaser bonus > NUM_ ) { uint256 transfer bonus token = private purchaser [ msg . sender ] . private purchaser bonus ; private purchaser [ msg . sender ] . private purchaser bonus = NUM_ ; token . mint ( msg . sender , transfer bonus token ) ; private purchaser token transfer ( msg . sender , transfer bonus token ) ; } return BOOL_ ; }"
function _get attributes of token ( uint256 _token id ) internal returns ( nft ) { nft storage lsnft obj = all nfts [ _token id ] ; return lsnft obj ; }
function get pledge level ( pledge p ) internal returns ( uint ) { if ( p . old pledge == NUM_ ) return NUM_ ; pledge storage old n = find pledge ( p . old pledge ) ; return get pledge level ( old n ) + NUM_ ; }
"function transfer allowed ( address _from , address ) external view returns ( bool ) { return _from == address ( this ) || _from == address ( disbursement handler ) ; }"
modifier only crowdsale address ( ) { require ( msg . sender == crowdsale address ) ; _ ; }
function set token address ( address erc20 token ) public owner only is not paused { token contract = erc20 interface ( erc20 token ) ; }
function get sig ( bytes _data ) internal pure returns ( bytes4 sig ) { uint len = _data . length < NUM_ ? _data . length : NUM_ ; for ( uint i = NUM_ ; i < len ; i ++ ) { sig = bytes4 ( uint ( sig ) + uint ( _data [ i ] ) * ( NUM_ * * ( NUM_ * ( len - NUM_ - i ) ) ) ) ; } }
"function transfer from ( address _from , address _to , uint256 _value ) public when not paused returns ( bool ) { require ( _value > NUM_ ) ; require ( _to != address ( NUM_ ) ) ; require ( _from != address ( NUM_ ) ) ; require ( _value <= balance of [ _from ] ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; require ( safe math . add ( balance of [ _to ] , _value ) > balance of [ _to ] ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; balance of [ _from ] = safe math . sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . sub ( allowance [ _from ] [ msg . sender ] , _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }"
function restart sale ( ) only_during_sale_period only_sale_stopped only ( escbdev multisig ) public { sale stopped = BOOL_ ; }
function divide up reward ( uint in days ) reward time past only owner external payable { require ( in days >= NUM_ && in days <= NUM_ ) ; last divide reward time = now ; reward days = in days ; total reward = this . balance ; }
"function get event ( string _vin , uint256 _index ) constant returns ( uint256 mileage , address verifier , event type event type , string description ) { ledger event memory e = events [ sha3 ( _vin ) ] [ _index ] ; mileage = e . mileage ; verifier = e . verifier ; event type = e . event type ; description = e . description ; }"
function delegate to new contract ( delegate erc20 new contract ) public only owner { delegate = new contract ; delegated to ( delegate ) ; }
"function migrate ( string name ) public owner_only ( keccak256 ( name ) ) { require ( stopped ) ; require ( migration != NUM_ ) ; bytes32 label = keccak256 ( name ) ; domain storage domain = domains [ label ] ; hash registrar . transfer ( label , migration ) ; subdomain registrar ( migration ) . configure domain for ( domain . name , domain . price , domain . referral fee ppm , domain . owner , domain . transfer address ) ; delete domains [ label ] ; domain transferred ( label , name ) ; }"
"function _pre validate token transfer ( address _beneficiary , uint256 _token amount ) internal view { require ( has closed ( ) == BOOL_ ) ; require ( paused == BOOL_ ) ; require ( _beneficiary != address ( NUM_ ) ) ; require ( _token amount > NUM_ ) ; }"
"function refresh monarchy games reward ( ) public view returns ( uint _reward , uint _num endable ) { imonarchy controller _mc = get monarchy controller ( ) ; _num endable = _mc . get num endable games ( ) ; _reward = _capped reward ( _num endable * monarchy end reward ) ; }"
"function add users to group ( bytes32 _group name , address [ ] _users ) external only contract owner returns ( uint ) { require ( is group exists ( _group name ) ) ; group storage _group = group name2group [ _group name ] ; uint _group members count = _group . members count ; for ( uint _user idx = NUM_ ; _user idx < _users . length ; ++ _user idx ) { address _user = _users [ _user idx ] ; uint _member index = member address2index [ _user ] ; require ( _member index != NUM_ ) ; if ( _group . member address2index [ _user ] != NUM_ ) { continue ; } _group members count = _group members count . add ( NUM_ ) ; _group . member address2index [ _user ] = _group members count ; _group . index2global index [ _group members count ] = _member index ; _add group to member ( _user , _group name ) ; user to group added ( _user , _group name ) ; } _group . members count = _group members count ; return ok ; }"
"function calculate ring fill amount ( uint ring size , order state [ ] orders ) private pure { uint smallest idx = NUM_ ; uint i ; uint j ; for ( i = NUM_ ; i < ring size ; i ++ ) { j = ( i + NUM_ ) % ring size ; smallest idx = calculate order fill amount ( orders [ i ] , orders [ j ] , i , j , smallest idx ) ; } for ( i = NUM_ ; i < smallest idx ; i ++ ) { calculate order fill amount ( orders [ i ] , orders [ ( i + NUM_ ) % ring size ] , NUM_ , NUM_ , NUM_ ) ; } }"
"function data source callback finals ( uint id , uint8 [ NUM_ ] result ) public { require ( msg . sender == data source address ) ; uint256 i ; for ( i = NUM_ ; i < NUM_ ; i ++ ) { brackets results . finals teams ids [ i ] = result [ i ] ; } log finals arrived ( id , result ) ; }"
"function buy tokens ( address _beneficiary ) public payable during sale above minimum below hard cap { require ( _beneficiary != address ( NUM_ ) ) ; uint256 _wei amount = msg . value ; uint256 _tokens qty = msg . value . mul ( get bonus ( _wei amount ) ) ; uint256 _distributed = _tokens qty . add ( tokens distributed ) ; uint256 _sold = _tokens qty . add ( tokens sold ) ; require ( _distributed <= tokens_total_supply ) ; require ( _sold <= tokens_for_sale ) ; contributions [ _beneficiary ] = _wei amount . add ( contributions [ _beneficiary ] ) ; token balances [ _beneficiary ] = _tokens qty . add ( token balances [ _beneficiary ] ) ; wei received = wei received . add ( _wei amount ) ; tokens distributed = _distributed ; tokens sold = _sold ; contribute ( _beneficiary , msg . value ) ; acj token _token = acj token ( token ) ; _token . initial transfer ( _beneficiary , _tokens qty ) ; }"
"function refund ( ) { require ( ! bought_tokens && allow_refunds && percent_reduction == NUM_ ) ; uint256 eth_to_withdraw = safe math . div ( safe math . mul ( balances [ msg . sender ] , NUM_ ) , NUM_ ) ; balances [ msg . sender ] = NUM_ ; balances_bonus [ msg . sender ] = NUM_ ; fees = safe math . sub ( fees , safe math . div ( eth_to_withdraw , fee ) ) ; msg . sender . transfer ( eth_to_withdraw ) ; }"
"function cancel order ( bytes32 _order id ) non reentrant convert to and from cash external returns ( bool ) { require ( _order id != bytes32 ( NUM_ ) ) ; iorders _orders = iorders ( controller . lookup ( STR_ ) ) ; uint256 _money escrowed = _orders . get order money escrowed ( _order id ) ; uint256 _shares escrowed = _orders . get order shares escrowed ( _order id ) ; order . types _type = _orders . get order type ( _order id ) ; imarket _market = _orders . get market ( _order id ) ; uint256 _outcome = _orders . get outcome ( _order id ) ; require ( msg . sender == _orders . get order creator ( _order id ) ) ; _orders . remove order ( _order id ) ; refund order ( msg . sender , _type , _shares escrowed , _money escrowed , _market , _outcome ) ; _orders . decrement total escrowed ( _market , _money escrowed ) ; _market . assert balances ( ) ; controller . get augur ( ) . log order canceled ( _market . get universe ( ) , _market . get"
function get contract ( bytes32 _id ) public view returns ( address ) { return registry [ _id ] . contract address ; }
"function buyin ( ) public payable when_not_halted when_active only_eligible ( msg . sender ) { flush era ( ) ; if ( current bonus > NUM_ ) { if ( now >= begin time + bonus_min_duration && last new interest + bonus_latch <= block . number ) { current bonus -- ; } if ( now >= begin time + bonus_max_duration ) { current bonus = NUM_ ; } if ( buyins [ msg . sender ] . received == NUM_ ) { last new interest = uint32 ( block . number ) ; } } uint accounted ; bool refund ; uint price ; ( accounted , refund , price ) = the deal ( msg . value ) ; require ( ! refund ) ; buyins [ msg . sender ] . accounted += uint128 ( accounted ) ; buyins [ msg . sender ] . received += uint128 ( msg . value ) ; total accounted += accounted ; total received += msg . value ; end time = calculate end time ( ) ; buyin ( msg . sender , accounted , msg . value , price ) ; treasury . transfer ( msg . value"
function has closed ( ) public view returns ( bool ) { return now > bets_closing_time ; }
"function withdraw ( ) only owner { if ( ! soft cap reached ) revert ( ) ; beneficiary . transfer ( collected ) ; token . transfer ( beneficiary , token . balance of ( this ) ) ; crowdsale finished = BOOL_ ; }"
"function take fee ( uint256 _amount ) public with perm ( fee_admin ) returns ( bool ) { require ( poly token . transfer from ( address ( this ) , imodule factory ( factory ) . owner ( ) , _amount ) , STR_ ) ; return BOOL_ ; }"
function has ended ( ) internal view returns ( bool ) { return ( now > end date ) ; }
function total supply ( ) constant returns ( uint256 total amount ) { total amount = _total supply ; }
"function create sales tier config map ( ) private { tier configs [ keccak256 ( sale state . initial ) ] = tier config ( { state name : STR_ , tier rate percentage : NUM_ , hard cap : NUM_ } ) ; tier configs [ keccak256 ( sale state . private sale ) ] = tier config ( { state name : STR_ , tier rate percentage : NUM_ , hard cap : safe math . mul ( NUM_ , ( NUM_ * * NUM_ ) ) } ) ; tier configs [ keccak256 ( sale state . finalised private sale ) ] = tier config ( { state name : STR_ , tier rate percentage : NUM_ , hard cap : NUM_ } ) ; tier configs [ keccak256 ( sale state . pre sale ) ] = tier config ( { state name : STR_ , tier rate percentage : NUM_ , hard cap : safe math . mul ( NUM_ , ( NUM_ * * NUM_ ) ) } ) ; tier configs [ keccak256 ( sale state . finalised pre sale ) ] = tier config ( { state name : STR_ , tier"
"function remove all tournament contenders ( ) external only owner tournament paused { uint256 length = tournament queue size ; uint256 warrior id ; uint256 failed booty ; uint256 i ; uint256 fee ; uint256 bank = current tournament bank ; uint256 [ ] memory warriors data = new uint256 [ ] ( length ) ; for ( i = NUM_ ; i < length ; i ++ ) { warriors data [ i ] = tournament queue [ i * data_size ] ; } pvp listener . tournament finished ( warriors data ) ; current tournament bank = NUM_ ; tournament queue size = NUM_ ; for ( i = length - NUM_ ; i >= NUM_ ; i -- ) { warrior id = crypto utils . _unpack warrior id ( warriors data [ i ] , NUM_ ) ; fee = bank - ( bank * NUM_ / ( tournament entrance fee cut * ( NUM_ - threshold ) / NUM_ + NUM_ ) ) ; failed booty += send booty ( warrior to owner [ warrior id ] , fee ) ; bank -= fee ; } current tournament bank = bank ; total booty +="
"function transfer ( address to , uint256 value ) public require is operational returns ( bool ) { require ( to != address ( NUM_ ) ) ; require ( to != msg . sender ) ; require ( value <= transferable balance of ( msg . sender ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; transfer ( msg . sender , to , value ) ; return BOOL_ ; }"
function is token sale running ( ) public constant returns ( bool ) { return ( is pre sale running ( ) || is crowd sale running ( ) ) ; }
"function set address ( bytes32 _key , address _value ) only auth by tun external { address storage [ _key ] = _value ; }"
"function update eth icovariables ( uint256 _new_eth_qco , uint256 _new end block ) public only state control { require ( state == states . initial || state == states . valuation set ) ; require ( _new_eth_qco > NUM_ ) ; require ( block . number < _new end block ) ; end block = _new end block ; eth_qco = _new_eth_qco ; move to state ( states . valuation set ) ; }"
"function grant bounty ( address recipient_address , uint token_value ) only owner external { require ( ( contract state == contract state . icostarted ) || ( contract state == contract state . icostopped ) ) ; require ( bounty tokens >= token_value ) ; require ( now >= ico start time ) ; _transfer ( this , recipient_address , token_value ) ; bounty tokens -= token_value ; }"
"function has all attrs ( uint256 _token id , bytes2 _attributes ) public view returns ( bool ) { return assets [ _token id ] . attributes & _attributes == _attributes ; }"
function get owners ( wallet main lib . wallet data storage self ) public view returns ( address [ NUM_ ] ) { address [ NUM_ ] memory o ; for ( uint256 i = NUM_ ; i < self . owners . length ; i ++ ) { o [ i ] = self . owners [ i ] ; } return o ; }
"function migrate ( ) crowdsale running { uint256 pre token balance = pre token . balance of ( msg . sender ) ; require ( pre token balance != NUM_ ) ; uint256 token balance = pre token balance * NUM_ * * NUM_ ; pre token . destroy from ( msg . sender ) ; token . transfer ( msg . sender , token balance ) ; migrated tokens ( msg . sender , token balance ) ; }"
"function get rich token ( uint256 _token id ) public view returns ( string richtoken name , uint256 selling price , address owner ) { rich storage richtoken = richtokens [ _token id ] ; richtoken name = richtoken . name ; selling price = richtoken index to price [ _token id ] ; owner = richtoken index to owner [ _token id ] ; }"
function get bonus ( uint _ethers ) public view returns ( uint8 ) { uint8 _bonus = NUM_ ; uint8 _bonus per investion = NUM_ ; uint starter = now - start_ico ; for ( uint i = NUM_ ; i < bonus time . length ; i ++ ) { if ( starter <= bonus time [ i ] ) { if ( _ethers > NUM_ ether && _ethers <= NUM_ ether ) { _bonus per investion = bonus per investion_10 [ i ] ; } if ( _ethers > NUM_ ether ) { _bonus per investion = bonus per investion_50 [ i ] ; } _bonus = bonus benefit [ i ] ; break ; } } return _bonus + _bonus per investion ; }
"function update ico ( uint _bonus rate , uint256 _cap , stage _stage ) external only owner sale not done { require ( _bonus rate <= NUM_ ) ; require ( _cap <= ico cap ) ; require ( _stage != stage . none ) ; bonus rate = _bonus rate ; current sale cap = _cap ; current stage = _stage ; }"
function priority pass contract address ( ) constant public returns ( address ) { return address ( priority pass contract ) ; }
"function start board game ( go board storage board , uint board id ) private { require ( board . black address != NUM_ && board . white address != NUM_ ) ; board . next turn color = player color . black ; update board status ( board , board id , board status . in progress ) ; }"
function token addresses ( ) external view returns ( address [ ] ) { address [ ] memory addresses = new address [ ] ( tokens . length ) ; for ( uint256 i = NUM_ ; i < tokens . length ; i ++ ) { addresses [ i ] = tokens [ i ] . addr ; } return addresses ; }
"function setup vote ( uint motion id ) internal returns ( uint ) { require ( motion voting ( motion id ) ) ; require ( ! has voted ( msg . sender , motion id ) ) ; require ( msg . sender != motion target [ motion id ] ) ; havven . recompute account last average balance ( msg . sender ) ; uint weight ; if ( motion start time [ motion id ] < havven . fee period start time ( ) ) { weight = havven . penultimate average balance ( msg . sender ) ; } else { weight = havven . last average balance ( msg . sender ) ; } require ( weight > NUM_ ) ; vote weight [ msg . sender ] [ motion id ] = weight ; return weight ; }"
"function fill investor account with bonus ( address account address ) only bonus owner { if ( investors accounts [ account address ] == - NUM_ || investors accounts [ account address ] > NUM_ ) { var bonus value = owned bonus [ msg . sender ] ; owned bonus [ msg . sender ] = NUM_ ; if ( investors accounts [ account address ] == - NUM_ ) investors accounts [ account address ] == NUM_ ; investors accounts [ account address ] += int ( bonus value ) ; account filled with bonus ( account address , bonus value , investors accounts [ account address ] ) ; account address . transfer ( bonus value ) ; } }"
function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total cars = total supply ( ) ; uint256 result index = NUM_ ; uint256 car id ; for ( car id = NUM_ ; car id <= total cars ; car id ++ ) { if ( lambo index to owner [ car id ] == _owner ) { result [ result index ] = car id ; result index ++ ; } } return result ; } }
function turn off sale ( ) only owner public { _selling = BOOL_ ; }
"function mint ( string _name , uint _supply ) public payable { require ( msg . value >= fee ) ; require ( supply [ _name ] == NUM_ ) ; supply [ _name ] = _supply ; balances [ _name ] [ msg . sender ] = _supply ; emit mint ( _name , _supply ) ; }"
function get kyc approved ( uint256 index ) public view returns ( address ) { return kyc validated [ index ] ; }
function set migrate contract ( address _new contract addr ) is owner external { require ( _new contract addr != new contract addr ) ; new contract addr = _new contract addr ; }
"function safe approve ( address _spender , uint256 _current value , uint256 _value ) public returns ( bool success ) { if ( allowances_ [ msg . sender ] [ _spender ] == _current value ) return approve ( _spender , _value ) ; return BOOL_ ; }"
"function get price ( address token address , uint src qty ) public view returns ( uint price ) { require ( token address != address ( NUM_ ) ) ; ( , price ) = price provider . get rates ( token address , src qty ) ; return price ; }"
function pause presale ( bool _paused ) only owner public { presale paused = _paused ; }
"function get infos ( ) constant returns ( address , string , uint ) { return ( creator address , name , creation time ) ; }"
function set cycle limit ( uint _cycle limit ) check access ( STR_ ) { cycle limit = _cycle limit ; }
function withdraw ( ) external only owner ( ) { owner . transfer ( address ( this ) . balance ) ; }
"function calc confirms needed ( uint256 _required , uint256 _count ) public pure returns ( uint256 ) { return _required - _count ; }"
function burn ( uint256 _value ) public when not paused { super . burn ( _value ) ; }
"function update score and balance ( uint256 _paid price , uint256 _item id , address _old owner , address _new owner ) internal { uint256 _previous paid price = previous price of item [ _item id ] ; assert ( _paid price > _previous paid price ) ; uint256 score sub handicap = dividends score . sub ( handicap [ pot version ] [ _old owner ] ) ; uint256 player score_ = player score [ _old owner ] ; if ( _old owner != owner && score sub handicap >= NUM_ && player score_ > _previous paid price ) { pending balance [ pot version ] [ _old owner ] += player score_ . mul ( score sub handicap ) . div ( huge ) ; player score [ _old owner ] -= _previous paid price ; handicap [ pot version ] [ _old owner ] = dividends score ; } score sub handicap = dividends score . sub ( handicap [ pot version ] [ _new owner ] ) ; player score_ = player score [ _new owner ] ; if ( score sub handicap >= NUM_ ) { pending balance [ pot version ] [ _new owner"
"function issue tokens with locking ( address _to , uint256 _value , uint256 _value locked , lock reason _why , uint64 _release time ) only admin public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( _value locked >= NUM_ && _value locked <= _value ) ; require ( total inactive >= _value ) ; total supply = total supply . add ( _value ) ; total inactive = total inactive . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; issued ( _to , _value , _value locked ) ; transfer ( NUM_ , _to , _value ) ; if ( _value locked > NUM_ ) { lock tokens ( _to , _value locked , _why , _release time ) ; } }"
"function log game data ( bytes32 [ ] server seeds , bytes32 [ ] client seeds , int [ ] results , uint8 v , bytes32 r , bytes32 s ) public { address player = determine player ( server seeds , client seeds , results , v , r , s ) ; game data ( player , server seeds , client seeds , results ) ; if ( player != msg . sender ) { uint gas cost = ( NUM_ + NUM_ * server seeds . length / NUM_ ) * gas price ; balance of [ player ] = safe sub ( balance of [ player ] , gas cost ) ; player balance = safe sub ( player balance , gas cost ) ; } }"
function clear state ( uint8 lottery id ) private { if ( ! request pause [ lottery id ] ) { state [ lottery id ] = state . running ; clear number ( lottery id ) ; started [ lottery id ] = block . timestamp ; last ticket bought [ lottery id ] = NUM_ ; tickets sold [ lottery id ] = NUM_ ; clear512 ( bit mask for play fields [ lottery id ] ) ; } else { state [ lottery id ] = state . paused ; request pause [ lottery id ] = BOOL_ ; } }
function get rn ( uint _block ) public returns ( uint rn ) { rn = random number [ _block ] ; if ( rn == NUM_ ) { save rn ( _block ) ; return random number [ _block ] ; } else return rn ; }
function get oldest pledge not canceled ( uint64 id pledge ) internal constant returns ( uint64 ) { if ( id pledge == NUM_ ) return NUM_ ; pledge storage p = find pledge ( id pledge ) ; pledge admin storage admin = find admin ( p . owner ) ; if ( admin . admin type == pledge admin type . giver ) return id pledge ; assert ( admin . admin type == pledge admin type . project ) ; if ( ! is project canceled ( p . owner ) ) return id pledge ; return get oldest pledge not canceled ( p . old pledge ) ; }
function set upgrade master ( address master ) public { if ( master == NUM_ ) throw ; if ( msg . sender != upgrade master ) throw ; upgrade master = master ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value && contribution time [ msg . sender ] + waittimeuntilwithdrawortransfer <= block . timestamp && _to != address ( this ) && _to != address ( NUM_ ) ) ; balances [ msg . sender ] = safe math . sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safe math . add ( balances [ _to ] , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
"function issue ( address _to , uint256 _value ) public only issuer returns ( bool ) { last issued time [ _to ] = block . timestamp ; emit issue ( _to , _value ) ; return super . transfer ( _to , _value ) ; }"
function recompute last average balance ( ) external optional proxy returns ( uint ) { return _recompute account last average balance ( message sender ) ; }
function judge fake token ( uint256 _token id ) only root ( ) public { creator of token [ _token id ] = msg . sender ; }
"function recover tokens ( erc20 basic token ) only owner public { token . transfer ( owner , tokens to be returned ( token ) ) ; }"
"function get play record ( address _address ) external view returns ( uint32 , address , uint256 [ NUM_ ] , uint32 [ NUM_ ] , uint32 [ NUM_ ] , uint32 , uint256 , uint8 , uint8 [ NUM_ ] , uint8 [ NUM_ ] , uint32 [ NUM_ ] ) { play record memory _p = address to play record [ _address ] ; turn info memory _t = address to turn info [ _address ] ; return ( _p . initial seed , _p . enemy address , _p . token ids , _p . unit class ids , _p . unit levels , _p . exp reward , _p . gold reward , _t . turn length , _t . turn order , _t . defender list , _t . damage list ) ; }"
"function verify side ( color [ NUM_ ] [ NUM_ ] memory a state , uint8 face , color expected color ) internal pure returns ( bool ) { return a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color ; }"
"function new plcrwith token ( uint _supply , string _name , uint8 _decimals , string _symbol ) public returns ( plcrvoting ) { eip20 token = new eip20 ( _supply , _name , _decimals , _symbol ) ; token . transfer ( msg . sender , _supply ) ; plcrvoting plcr = plcrvoting ( proxy factory . create proxy ( canonized plcr , STR_ ) ) ; plcr . init ( token ) ; emit new plcr ( msg . sender , token , plcr ) ; return plcr ; }"
"function transfer ( address _to , uint256 _value ) public when permitted ( msg . sender ) when permitted ( _to ) when not paused only not bank owner returns ( bool ) { if ( investor list [ msg . sender ] ) { return _transfer investor ( _to , _value ) ; } else { if ( super investor [ msg . sender ] ) { require ( _to != owner ) ; require ( ! super investor [ _to ] ) ; require ( ! cex [ _to ] ) ; if ( ! investor list [ _to ] ) { investor list [ _to ] = BOOL_ ; search investor [ _to ] = investor ( NUM_ , _value , _value . div ( NUM_ ) ) ; emit tmtg_set investor ( _to ) ; } } return super . transfer ( _to , _value ) ; } }"
function name ( ) public pure returns ( string ) { return name ; }
"function balance with interest ( address _owner ) private constant returns ( uint256 ret ) { if ( _owner == owner || sale status != NUM_ ) return balances [ _owner ] ; return balances [ _owner ] . compound interest ( stage2 start time , date of start [ _owner ] , current date ) ; }"
function arbitrate approve milestone ( uint _id milestone ) only arbitrator campaign not canceled not changing { if ( _id milestone >= milestones . length ) throw ; milestone milestone = milestones [ _id milestone ] ; if ( ( milestone . status != milestone status . accepted and in progress ) && ( milestone . status != milestone status . completed ) ) throw ; authorize payment ( _id milestone ) ; }
"function calc cost ( market market , uint8 outcome token index , uint outcome token count ) public constant returns ( uint cost ) { require ( market . event contract ( ) . get outcome count ( ) > NUM_ ) ; int [ ] memory net outcome tokens sold = get net outcome tokens sold ( market ) ; int log n = math . ln ( net outcome tokens sold . length * one ) ; uint funding = market . funding ( ) ; int cost level before = calc cost level ( log n , net outcome tokens sold , funding ) ; require ( int ( outcome token count ) >= NUM_ ) ; net outcome tokens sold [ outcome token index ] = net outcome tokens sold [ outcome token index ] . add ( int ( outcome token count ) ) ; int cost level after = calc cost level ( log n , net outcome tokens sold , funding ) ; require ( cost level after >= cost level before ) ; cost = uint ( cost level after - cost level before ) ; if ( cost / one *"
"function issue ( address _addr , uint _amount ) public can enter only trustee returns ( bool ) { assert ( total supply + _amount < maxtokens ) ; join ( _addr ) ; holder holder = holders [ _addr ] ; holder . offer amount = _amount ; holder . offer expiry = uint40 ( now + NUM_ days ) ; issue offer ( _addr ) ; return BOOL_ ; }"
function iconics count ( ) public view returns ( uint256 ) { return iconic checklist items . length ; }
function activate ( ) external only owner only state ( state . ready ) { require ( num locks == num beneficiaries ) ; initial balance = token . balance of ( this ) ; require ( initial balance > NUM_ ) ; active time = now ; state = state . active ; emit state changed ( state ) ; }
function set sender ( address _sender ) public only owner { sender = _sender ; }
"function execute request ( bytes32 _value ) public { item storage item = items [ _value ] ; require ( now - item . last action >= time to challenge ) ; require ( ! item . disputed ) ; if ( item . status == item status . resubmitted || item . status == item status . submitted ) item . status = item status . registered ; else if ( item . status == item status . clearing requested || item . status == item status . preventive clearing requested ) item . status = item status . cleared ; else revert ( ) ; item . submitter . send ( item . balance ) ; emit item status change ( item . submitter , item . challenger , _value , item . status , item . disputed ) ; }"
"function get card info ( uint256 card id , uint256 existing , uint256 amount ) external constant returns ( uint256 , uint256 , uint256 , uint256 , bool ) { return ( card info [ card id ] . card id , card info [ card id ] . base coin production , get cost for cards ( card id , existing , amount ) , safe math . mul ( card info [ card id ] . eth cost , amount ) , card info [ card id ] . unit sellable ) ; }"
"function register ( bytes20 _username , uint64 _endowment , bytes _sig ) public { require ( recover ( keccak256 ( msg . sender , _username , _endowment ) , _sig ) == owner ) ; new member ( msg . sender , _username , _endowment ) ; }"
function pause ico ( ) external only owner { require ( ico state == ico state . running ) ; ico state = ico state . paused ; pause ico ( ) ; }
"function claim token reserve life ( ) only token reserve life locked public { address reserve wallet = msg . sender ; require ( block . timestamp > time locks [ reserve wallet ] ) ; uint256 vesting stage = life vesting stage ( ) ; uint256 total unlocked = vesting stage . mul ( NUM_ * ( NUM_ * * NUM_ ) * ( NUM_ * * NUM_ ) ) ; require ( total unlocked <= allocations [ life reserve wallet ] ) ; require ( claimed [ life reserve wallet ] < total unlocked ) ; uint256 payment = total unlocked . sub ( claimed [ life reserve wallet ] ) ; claimed [ life reserve wallet ] = total unlocked ; require ( token . transfer ( reserve wallet , payment ) ) ; distributed ( reserve wallet , payment ) ; }"
"function check pool address tier cap ( uint8 _tier , uint256 _value ) internal view returns ( bool _success ) { uint256 current contribution = pool [ pool address ] [ _tier ] . contribution in wei ; if ( ( _tier == NUM_ && ( pool address cap tier1 < current contribution . add ( _value ) ) ) || ( _tier == NUM_ && ( pool address cap tier2 < current contribution . add ( _value ) ) ) ) { return BOOL_ ; } return BOOL_ ; }"
modifier valid destination ( address _addr ) { require ( _addr != address ( this ) ) ; _ ; }
"function update contributor address ( address _contributor old , address _contributor new ) public only owner ( ) { backer storage backer old = backers [ _contributor old ] ; backer storage backer new = backers [ _contributor new ] ; require ( backer old . wei received one > NUM_ || backer old . wei received two > NUM_ || backer old . wei received main > NUM_ ) ; require ( backer new . wei received one == NUM_ && backer new . wei received two == NUM_ && backer new . wei received main == NUM_ ) ; require ( backer old . claimed == BOOL_ && backer old . refunded == BOOL_ ) ; backer old . claimed = BOOL_ ; backer old . refunded = BOOL_ ; backer new . wei received one = backer old . wei received one ; backer new . wei received two = backer old . wei received two ; backer new . wei received main = backer old . wei received main ; backers index . push ( _contributor new ) ; }"
function get wallet balance ( ) public view returns ( uint ) { return address ( this ) . balance ; }
"function fund ( ) public payable { if ( date sale started == NUM_ || now < date sale started ) return _error buying tokens ( STR_ ) ; if ( now > date sale ended ) return _error buying tokens ( STR_ ) ; if ( total raised >= hard cap ) return _error buying tokens ( STR_ ) ; if ( msg . value % NUM_ != NUM_ ) return _error buying tokens ( STR_ ) ; if ( ! was sale started ) { was sale started = BOOL_ ; emit sale started ( now ) ; } uint _amt to fund = ( total raised + msg . value ) > hard cap ? hard cap - total raised : msg . value ; uint _num tokens = get tokens from eth ( _amt to fund ) ; token . mint ( msg . sender , _num tokens ) ; total raised += _amt to fund ; emit buy tokens success ( now , msg . sender , _amt to fund , _num tokens ) ; if ( total raised < soft cap ) { amt funded [ msg . sender ] += _amt to fund ; } uint _refund = msg . value > _amt to fund ? msg . value - _amt to fund : NUM_ ; if ( _refund > NUM_ ) { require ( msg . sender . call . value ( _refund ) ( ) ) ; emit user refunded ( now , msg . sender , _refund ) ; } }"
"function _add affiliate ( uint256 _code , affiliates _affiliate ) internal { code to affiliate [ _code ] = _affiliate ; }"
"function transfer tokens to account ( bytes16 _from , bytes16 _to , uint256 _tokens count ) only allowed addresses only registered account ( _from ) when not paused public returns ( bool ) { register account ( _to ) ; balances [ _from ] = balances [ _from ] . sub ( _tokens count ) ; balances [ _to ] = balances [ _to ] . add ( _tokens count ) ; return BOOL_ ; }"
function flush ( ) public when not paused returns ( bool success ) { if ( block . number >= to flush [ msg . sender ] ) { return down the drain immediate ( ) ; } else return BOOL_ ; }
function is link claimed ( address _transit address ) public view returns ( bool claimed ) { return used transit addresses [ _transit address ] ; }
function current cluster ( ) constant returns ( uint256 current cluster ) { uint block count = block . number - initial block count ; uint result = block count . div ( NUM_ ) ; return result ; }
function get player id ( address _addr ) external returns ( uint256 ) { determine pid ( _addr ) ; return ( p idx addr_ [ _addr ] ) ; }
"function get usage details ( ) view public returns ( uint256 , uint8 , uint256 , address , address ) { return ( fee , quorum , vesting period , owner , kyc ) ; }"
function get token amount ( uint256 wei amount ) internal view returns ( uint256 ) { uint256 bonus = compute bonus ( wei amount ) ; uint256 rate with bonus = rate . mul ( coeff . add ( bonus ) ) . div ( coeff ) ; return wei amount . mul ( rate with bonus ) ; }
function release_all ( address _beneficiary ) external returns ( bool ) { require ( time_locked_reclaim_addresses [ _beneficiary ] . length > NUM_ ) ; token timelock [ ] memory _locks = time_locked_reclaim_addresses [ _beneficiary ] ; for ( uint256 i = NUM_ ; i < _locks . length ; ++ i ) _locks [ i ] . release ( ) ; return BOOL_ ; }
"function get player vaults helper ( uint256 _p id , uint256 _r id ) private view returns ( uint256 ) { return ( ( ( ( ( round_ [ _r id ] . mask ) . add ( ( ( ( ( round_ [ _r id ] . pot ) . mul ( pot split_ [ round_ [ _r id ] . team ] . gen ) ) / NUM_ ) . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ) ) . mul ( plyr rnds_ [ _p id ] [ _r id ] . keys ) ) / NUM_ ) ) ; }"
"function jackpot guard ( uint _wager ) private view returns ( bool ) { uint max profit = safe math . mul ( _wager , NUM_ ) ; uint ninety contract balance = safe math . mul ( safe math . div ( contract balance , NUM_ ) , NUM_ ) ; return ( max profit <= ninety contract balance ) ; }"
function set inv contract ( address _addr ) only manager public { inv_contract = _addr ; }
"function exec script ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { require ( _blacklist . length == NUM_ ) ; bytes32 id = keccak256 ( _script ) ; address deployed = cache [ id ] ; if ( deployed == address ( NUM_ ) ) { deployed = deploy ( _script ) ; cache [ id ] = deployed ; } return delegate script . delegate ( deployed , _input ) ; }"
"function do trade ( erc20 src token , uint src amount , erc20 dest token , address dest address , uint conversion rate , bool validate ) internal returns ( bool ) { if ( validate ) { require ( conversion rate > NUM_ ) ; if ( src token == eth_token_address ) require ( msg . value == src amount ) ; else require ( msg . value == NUM_ ) ; } uint dest amount = get dest qty ( src token , dest token , src amount , conversion rate ) ; require ( dest amount > NUM_ ) ; erc20 token ; int buy ; if ( src token == eth_token_address ) { buy = int ( dest amount ) ; token = dest token ; } else { buy = - NUM_ * int ( src amount ) ; token = src token ; } conversion rates contract . record imbalance ( token , buy , NUM_ , block . number ) ; if ( src token != eth_token_address ) { require ( src token . transfer from ( msg . sender , this , src amount ) ) ; } if ( dest token"
function start crowdsale ( ) external { require ( within period ( ) ) ; require ( viola token != address ( NUM_ ) ) ; require ( get tokens left ( ) > NUM_ ) ; require ( status == state . pending start ) ; status = state . active ; crowdsale started ( ) ; }
"function create cdpleveraged ( ) public auth stoppable payable returns ( bytes32 id ) { require ( msg . value >= min eth ) ; uint price = uint ( feed . read ( ) ) ; gem . deposit . value ( msg . value ) ( ) ; id = _open and join cdpweth ( msg . value ) ; while ( _reinvest ( id , price ) ) { } tub . give ( id , msg . sender ) ; }"
"function setup period for ico ( uint _start , uint _end ) only owner { require ( _start < _end ) ; start ico = _start ; end ico = _end ; }"
function update oraclize gas price ( uint _value ) public only owner { oraclize_set custom gas price ( _value ) ; }
"function transfer from ( address _from , address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) public returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }"
"function transfer from ( address _from , address _to , uint _id ) external { require ( _from == m id owner [ _id ] && m id approved [ _id ] == msg . sender ) ; m id owner [ _id ] = _to ; m id approved [ _id ] = address ( NUM_ ) ; update balances ( _from , _to ) ; transfer ( _from , _to , _id ) ; }"
"function accept investments ( address _addr , uint256 _amount ) private when whitelisted ( msg . sender ) when not paused { require ( _addr != address ( NUM_ ) && _amount >= min investments ) ; bool pre ico = is pre ico stage ( ) ; bool ico = is ico stage ( ) ; require ( pre ico || ico ) ; require ( ( pre ico && tokens remaining pre ico ( ) > NUM_ ) || ( ico && tokens remaining ico ( ) > NUM_ ) ) ; uint256 intermediate eth investment ; uint256 eth surrender = NUM_ ; uint256 current eth = pre ico ? pre ico investors [ _addr ] : ico investors [ _addr ] ; if ( current eth . add ( _amount ) > max investments ) { intermediate eth investment = max investments . sub ( current eth ) ; eth surrender = eth surrender . add ( _amount . sub ( intermediate eth investment ) ) ; } else { intermediate eth investment = _amount ; } uint256 current rate = pre ico ? exchange rate pre ico : exchange rate ico ; uint256 intermediate token investment"
function started ( ) public view returns ( bool ) { return now >= start time ; }
"function generate hash ( address to , string secret ) public pure returns ( bytes32 hashed ) { return keccak256 ( to , secret ) ; }"
"function set initial settings ( address _founders tokens storage , uint256 _start timestamp , uint256 _soft cap in ether , uint256 _hard cap in ether , uint256 _tokens for one ether ) public timed state change requires state ( state . init ) onlymanyowners ( sha3 ( msg . data ) ) valid address ( _founders tokens storage ) { require ( _start timestamp != NUM_ ) ; require ( _soft cap in ether != NUM_ ) ; require ( _hard cap in ether != NUM_ ) ; require ( _tokens for one ether != NUM_ ) ; m_start timestamp = _start timestamp ; m_soft cap = _soft cap in ether * NUM_ ether ; m_hard cap = _hard cap in ether * NUM_ ether ; m_exchange rate = _tokens for one ether ; m_founders tokens storage = _founders tokens storage ; m_initial settings set = BOOL_ ; }"
"function to bytes ( rlpitem memory self ) internal constant returns ( bytes memory bts ) { var len = self . _unsafe_length ; if ( len == NUM_ ) return ; bts = new bytes ( len ) ; _copy to bytes ( self . _unsafe_mem ptr , bts , len ) ; }"
"function _claimed surrounding plots ( uint256 _deed id ) internal view returns ( uint256 [ ] memory ) { var ( x , y ) = identifier to coordinate ( _deed id ) ; uint256 claimed = NUM_ ; uint256 [ ] memory _plots = new uint256 [ ] ( NUM_ ) ; for ( int256 dx = - NUM_ ; dx <= NUM_ ; dx ++ ) { for ( int256 dy = - NUM_ ; dy <= NUM_ ; dy ++ ) { if ( dx == NUM_ && dy == NUM_ ) { continue ; } uint256 neighbor identifier = coordinate to identifier ( uint256 ( int256 ( x ) + dx ) % NUM_ , uint256 ( int256 ( y ) + dy ) % NUM_ ) ; if ( identifier to owner [ neighbor identifier ] != NUM_ ) { _plots [ claimed ] = neighbor identifier ; claimed ++ ; } } } uint256 [ ] memory plots = new uint256 [ ] ( claimed ) ; for ( uint256 i = NUM_ ; i < claimed ; i ++ ) { plots [ i ] = _plots [ i ] ; } return"
modifier only banker ( ) { require ( msg . sender == bank manager ) ; _ ; }
function set token ( address _token ) external only owner when paused { require ( state == state . new ) ; require ( _token != address ( NUM_ ) ) ; require ( token == address ( NUM_ ) ) ; token = bit image token ( _token ) ; token ico allocated = token . total supply ( ) . mul ( NUM_ ) . div ( NUM_ ) ; token team allocated = token . total supply ( ) . mul ( NUM_ ) . div ( NUM_ ) ; token advisors allocated = token . total supply ( ) . mul ( NUM_ ) . div ( NUM_ ) ; token bounty allocated = token . total supply ( ) . mul ( NUM_ ) . div ( NUM_ ) ; token reservation allocated = token . total supply ( ) . mul ( NUM_ ) . div ( NUM_ ) ; require ( token . total supply ( ) == token ico allocated . add ( token team allocated ) . add ( token advisors allocated ) . add ( token bounty allocated ) . add ( token reservation allocated ) ) ; }
function reset winners ( uint256 new length ) external only admin check state ( points validation state . limit calculated ) { sorted winners . length = new length ; }
"function external purchase ( address _beneficiary , string _currency , uint256 _value , uint256 _amount , uint256 _txid ) public { require ( owner != address ( NUM_ ) ) ; require ( msg . sender == owner ) ; require ( is icoactive ( ) || post icosale ) ; require ( token . whitelist ( _beneficiary ) ) ; require ( _amount >= minimum purchase ) ; if ( is icoactive ( ) && token . total supply ( ) . add ( _amount ) > ico token cap ) revert ( ) ; external funds raised [ currency to hash ( _currency ) ] = external funds raised [ currency to hash ( _currency ) ] . add ( _value ) ; token . mint ( _beneficiary , _amount ) ; emit external token purchase ( _beneficiary , _currency , _value , _amount , _txid ) ; }"
"function get pay id and held ( uint _tok held ) internal returns ( uint _pay id , uint _held ) { _pay id = ( _tok held / ( NUM_ * * NUM_ ) ) & NUM_ ; _held = _tok held & NUM_ ; }"
"function restore balances ( address [ NUM_ ] addr , uint256 [ NUM_ ] _days , uint256 [ NUM_ ] _amounts ) external only admin { assert ( initialized == BOOL_ ) ; if ( total supply == NUM_ ) { balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] ="
function set min eth ( uint wad ) public auth { min eth = wad ; }
"function post mon for mon ( uint64 your mon , uint64 desired mon ) external { check ownership ( your mon ) ; require ( desired mon != NUM_ ) ; listed mon for mon [ your mon ] = desired mon ; mon to trainer [ your mon ] = msg . sender ; }"
"function calculate payouts ( ) private { uint total amount = total bets ( ) ; team storage wt = teams [ winning team index ] ; uint win team amount = wt . bets ; if ( win team amount == NUM_ ) { return ; } uint winnings = remove fee amount ( total amount , win team amount ) ; for ( uint i = NUM_ ; i < wt . bettors . length ; i ++ ) { uint bet size = wt . bettor amount [ wt . bettors [ i ] ] ; uint percentage = safe math . div ( ( bet size * NUM_ ) , win team amount ) ; uint pay out = winnings * percentage ; pay outs [ wt . bettors [ i ] ] = safe math . div ( pay out , NUM_ ) + bet size ; } }"
"function get return ( ierc20 token _from token , ierc20 token _to token , uint256 _amount ) public constant returns ( uint256 amount ) { require ( _from token != _to token ) ; if ( _to token == token ) return get purchase return ( _from token , _amount ) ; else if ( _from token == token ) return get sale return ( _to token , _amount ) ; uint256 purchase return amount = get purchase return ( _from token , _amount ) ; return get sale return ( _to token , purchase return amount , safe add ( token . total supply ( ) , purchase return amount ) ) ; }"
function add approved game ( address _game address ) only owner public { approved games [ _game address ] = BOOL_ ; add item ( _game address ) ; }
function terminate ( ) external only owner { sale closed = BOOL_ ; }
"function token fallback ( address , uint _value , bytes ) public { require ( msg . sender == token ) ; require ( ! tokens received ) ; require ( _value == total_tokens ) ; total tokens = total_tokens ; tokens received = BOOL_ ; }"
function get price ( ) public constant returns ( uint result ) { if ( crowd sale type == NUM_ ) { return ( price . mul ( NUM_ ) ) . div ( NUM_ ) ; } if ( crowd sale type == NUM_ ) { uint crowdsale price bracket = NUM_ weeks ; uint start crowdsale = start block . add ( duration pre sale ) ; if ( now > start crowdsale && now <= start crowdsale . add ( crowdsale price bracket ) ) { return ( ( price . mul ( NUM_ ) ) . div ( NUM_ ) ) ; } else if ( now > start crowdsale . add ( crowdsale price bracket ) && now <= ( start crowdsale . add ( crowdsale price bracket . mul ( NUM_ ) ) ) ) { return ( price . mul ( NUM_ ) ) . div ( NUM_ ) ; } else if ( now > ( start crowdsale . add ( crowdsale price bracket . mul ( NUM_ ) ) ) && now <= ( start crowdsale . add ( crowdsale price bracket . mul ( NUM_ ) ) ) ) {
"function add multiple items ( uint256 price , uint8 howmuch ) public { require ( msg . sender == owner ) ; require ( price != NUM_ ) ; require ( howmuch != NUM_ ) ; uint8 i = NUM_ ; for ( i ; i < howmuch ; i ++ ) { add item ( price ) ; } }"
function token by index ( uint256 _index ) external view returns ( uint256 ) { require ( _index < total tokens ) ; return _index ; }
"function load token balances ( token token ) public view returns ( uint256 [ ] memory , uint256 total ) { uint256 [ ] memory result = new uint256 [ ] ( accounts . length ) ; uint256 balance ; for ( uint256 i = NUM_ ; i < accounts . length ; i ++ ) { balance = token . balance of ( accounts [ i ] ) ; result [ i ] = balance ; total += balance ; } return ( result , total ) ; }"
"function withdraw tokens ( address token contract ) external can access ( NUM_ ) { erc20 tc = erc20 ( token contract ) ; tc . transfer ( msg . sender , tc . balance of ( this ) ) ; }"
"function _transfer ( address _from , address _to , uint _div card id ) private { ownership div card count [ _to ] ++ ; div card index to owner [ _div card id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership div card count [ _from ] -- ; delete div card index to approved [ _div card id ] ; } emit transfer ( _from , _to , _div card id ) ; }"
"function create auction ( uint256 _part id , uint256 _start price , uint256 _end price , uint256 _duration ) external when not paused { require ( owns ( msg . sender , _part id ) ) ; _approve ( _part id , auction ) ; dutch auction ( auction ) . create auction ( _part id , _start price , _end price , _duration , msg . sender ) ; }"
"function is owner ( address _owner , bytes32 _symbol ) constant returns ( bool ) { return is created ( _symbol ) && ( assets [ _symbol ] . owner == get holder id ( _owner ) ) ; }"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( NUM_ ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
function get price ( uint256 _token id ) public view returns ( uint256 ) { require ( exists ( _token id ) ) ; address token owner = owner of ( _token id ) ; if ( token owner == creator ) { return token price [ _token id ] ; } else { return NUM_ ; } }
function get current bonus pct ( uint256 investment ) constant returns ( uint256 ) { return bonus pct ; }
function current price ( uint32 _bunnyid ) public view returns ( uint ) { uint money = bunny cost [ _bunnyid ] ; if ( money > NUM_ ) { uint money coms = money . div ( NUM_ ) ; money coms = money coms . mul ( NUM_ ) ; return money . add ( money coms ) ; } }
"function extend liquidation period ( uint extension ) external optional proxy_only owner { require ( is liquidating ( ) ) ; uint sum = safe add ( liquidation period , extension ) ; require ( sum <= max_liquidation_period ) ; liquidation period = sum ; emit liquidation extended ( extension ) ; }"
"function transfer from ( address _from , address _to , uint256 _value ) can transfer ( _from , _value ) public returns ( bool transferred ) { if ( free transfer ( ) ) { return super . transfer from ( _from , _to , _value ) ; } else { uint256 usage fee = transfer fee ( _value ) ; uint256 net value = _value . sub ( usage fee ) ; bool fee transferred = super . transfer from ( _from , owner , usage fee ) ; bool net value transferred = super . transfer from ( _from , _to , net value ) ; return fee transferred && net value transferred ; } }"
function withdraw ( uint amount ) only owner { owner . transfer ( amount ) ; }
"function put on initial sale ( uint256 _tulip id ) external only core contract { _create auction ( _tulip id , initial start price , initial end price , initial sale duration , this ) ; }"
"function _transfer ( address _from , address _to , uint256 _value ) internal returns ( bool ) { require ( _to != NUM_ ) ; require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value > balances [ _to ] ) ; uint previous balances = balances [ _from ] . add ( balances [ _to ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( _from , _to , _value ) ; assert ( balances [ _from ] + balances [ _to ] == previous balances ) ; return BOOL_ ; }"
function set coo2 ( address _new coo2 ) external only ceo { require ( _new coo2 != address ( NUM_ ) ) ; coo address2 = _new coo2 ; }
"function collect winnings ( uint home , uint away , uint donation percentage ) public is valid square ( home , away ) { require ( oracle . is finalized ( ) ) ; require ( donation percentage <= NUM_ ) ; uint winnings = math . min256 ( this . balance , get winnings ( msg . sender , home , away ) ) ; require ( winnings > NUM_ ) ; uint donation = winnings . mul ( donation percentage ) . div ( NUM_ ) ; uint payout = winnings . sub ( donation ) ; total square stakes by user [ msg . sender ] [ home ] [ away ] = NUM_ ; msg . sender . transfer ( payout ) ; developer . transfer ( donation ) ; log payout ( msg . sender , payout , donation ) ; }"
function total supply locked1 y ( ) constant returns ( uint ) { if ( finalised ) { return locked tokens . total supply locked1 y ( ) ; } else { return NUM_ ; } }
function set credit game address ( address _credit game address ) public only owner { credit game address = _credit game address ; }
"function sell dai for eth ( uint256 _amount dai , uint256 _min return ) external returns ( uint256 ) { require ( _amount dai > NUM_ ) ; ierc20 token ( dai ) . transfer from ( msg . sender , address ( this ) , _amount dai ) ; require ( ierc20 token ( dai ) . approve ( address ( bancor converter address ) , _amount dai ) ) ; ierc20 token [ ] memory dai to eth conversion path ; dai to eth conversion path [ NUM_ ] = dai ; dai to eth conversion path [ NUM_ ] = bancor dai smart token relay ; dai to eth conversion path [ NUM_ ] = bancor dai smart token relay ; dai to eth conversion path [ NUM_ ] = bancor dai smart token relay ; dai to eth conversion path [ NUM_ ] = bancor token ; dai to eth conversion path [ NUM_ ] = bancor token ; dai to eth conversion path [ NUM_ ] = bancor erc20 eth ; bancor converter address . quick convert ( dai to eth conversion path , _amount dai , _min return ) ; msg . sender ."
"function get return ( ierc20 token _from token , ierc20 token _to token , uint256 _amount ) public view returns ( uint256 ) { require ( _from token != _to token ) ; if ( _to token == token ) return get purchase return ( _from token , _amount ) ; else if ( _from token == token ) return get sale return ( _to token , _amount ) ; return get cross connector return ( _from token , _to token , _amount ) ; }"
"function upgrade ship ( uint32 _ship id , uint8 _upgrade choice ) public payable { require ( _ship id > NUM_ && _ship id < new id ship ) ; require ( ships [ _ship id ] . owner == msg . sender ) ; require ( _upgrade choice >= NUM_ && _upgrade choice < NUM_ ) ; require ( ships [ _ship id ] . upgrades [ _upgrade choice ] < NUM_ ) ; require ( msg . value >= upgrade price ) ; ships [ _ship id ] . upgrades [ _upgrade choice ] ++ ; balances [ msg . sender ] += msg . value - upgrade price ; balances [ upgrade master ] += upgrade price ; event upgrade ship ( msg . sender , _ship id , _upgrade choice ) ; return ; }"
"function buy presale tokens ( address _beneficiary ) payable { require ( ! presale finalized ) ; require ( msg . value != NUM_ ) ; require ( now <= presale end time ) ; require ( now >= presale start time ) ; uint256 bbd tokens = msg . value . mul ( get token creation rate ( ) ) . div ( divisor ) ; uint256 checked supply = total supply . add ( bbd tokens ) ; require ( presale token creation cap >= checked supply ) ; total supply = total supply . add ( bbd tokens ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( bbd tokens ) ; raised += msg . value ; token purchase ( msg . sender , _beneficiary , msg . value , bbd tokens ) ; }"
"function append vesting entry ( address account , uint time , uint quantity ) public only owner only during setup { require ( now < time , STR_ ) ; require ( quantity != NUM_ , STR_ ) ; total vested balance = safe add ( total vested balance , quantity ) ; require ( total vested balance <= havven . balance of ( this ) , STR_ ) ; uint schedule length = vesting schedules [ account ] . length ; require ( schedule length <= max_vesting_entries , STR_ ) ; if ( schedule length == NUM_ ) { total vested account balance [ account ] = quantity ; } else { require ( get vesting time ( account , num vesting entries ( account ) - NUM_ ) < time , STR_ ) ; total vested account balance [ account ] = safe add ( total vested account balance [ account ] , quantity ) ; } vesting schedules [ account ] . push ( [ time , quantity ] ) ; }"
function initialize on transfer ( ) public not operational only token owner token payable returns ( bool ) { require ( initialize ( ) ) ; return BOOL_ ; }
function get funds ( ) only in emergency { if ( backers [ msg . sender ] == NUM_ ) throw ; uint amount = backers [ msg . sender ] ; backers [ msg . sender ] = NUM_ ; if ( ! msg . sender . send ( amount ) ) throw ; }
function resolver ( bytes32 node ) constant returns ( address ) { return records [ node ] . resolver ; }
function get ships by owner ( address _owner ) external view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( owner ship count [ _owner ] ) ; uint counter = NUM_ ; for ( uint i = NUM_ ; i < ships . length ; i ++ ) { if ( ship id to owner [ i ] == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }
function set wei cap ( uint new cap ) public only owner { sale wei cap = new cap ; cap updated ( new cap ) ; }
function get oscar ( ) public constant returns ( address _oscar ) { return address oscar ; }
function has tokens ( address _owner ) public view returns ( bool ) { return owned tokens [ _owner ] . length > NUM_ ; }
function num of declared public offering plans ( ) external constant returns ( uint256 ) { return public offering plans . length ; }
"function mul is safe ( uint x , uint y ) pure internal returns ( bool ) { if ( x == NUM_ ) { return BOOL_ ; } return ( x * y ) / x == y ; }"
"modifier can claim bonus ( ) { require ( is finalized , STR_ ) ; require ( now < opening time + NUM_ weeks , STR_ ) ; require ( ! claimed bonus [ msg . sender ] , STR_ ) ; require ( total tokens sold > NUM_ , STR_ ) ; _ ; }"
function set bounty tokens percent ( uint new bounty tokens percent ) public only owner { bounty tokens percent = new bounty tokens percent ; }
function has ended ( ) public constant returns ( bool ) { return now > end time || sold tokens >= hard_cap ; }
function create token contract ( ) internal returns ( mintable token ) { return mintable token ( NUM_ ) ; }
function compute token amount ( uint256 eth amount ) internal view returns ( uint256 tokens ) { uint64 discount percentage = current tier discount percentage ( ) ; uint256 token base = eth amount . mul ( base_rate ) ; uint256 token bonus = token base . mul ( discount percentage ) . div ( NUM_ ) ; tokens = token base . add ( token bonus ) ; }
function success ico ( ) internal { is success = BOOL_ ; success ico ( ) ; }
function stop redeeming ( ) external only owner is not paused { is redeeming = BOOL_ ; }
function revoke contract ( ) public participant only { cancellations [ msg . sender ] = BOOL_ ; if ( ( ( cancellations [ policy info . broker ether address ] && ( cancellations [ policy info . client ether address ] || cancellations [ owner ] ) ) || ( cancellations [ policy info . client ether address ] && cancellations [ owner ] ) ) ) { policy info . status = STR_ ; allowed to upgrade = BOOL_ ; } }
function add owner ( address new owner ) only owner public { require ( new owner != address ( NUM_ ) ) ; owners [ new owner ] = BOOL_ ; }
"function token fallback ( address _from , uint _value , bytes ) { balances [ _from ] [ msg . sender ] = balances [ _from ] [ msg . sender ] . add ( _value ) ; deposit ( msg . sender , _from , _value , now ) ; }"
"function get kycpayload ( bytes dataframe ) public constant returns ( address whitelisted address , uint128 customer id , uint32 min eth , uint32 max eth , uint256 pricing info ) { address _whitelisted address = dataframe . slice address ( NUM_ ) ; uint128 _customer id = uint128 ( dataframe . slice16 ( NUM_ ) ) ; uint32 _min eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; uint32 _max eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; uint256 _pricing info = uint256 ( dataframe . slice32 ( NUM_ ) ) ; return ( _whitelisted address , _customer id , _min eth , _max eth , _pricing info ) ; }"
function my bets in lap ( uint _lap id ) public view returns ( uint [ ] memory totals ) { race lib . race storage race = get race ( _lap id ) ; totals = new uint [ ] ( cars . length * NUM_ ) ; uint8 j = NUM_ ; address car ; for ( uint8 i = NUM_ ; i < cars . length ; i ++ ) { car = cars [ i ] ; totals [ j ++ ] = uint ( car ) ; totals [ j ++ ] = race . tokens by car and driver [ car ] [ msg . sender ] ; } }
function batch add whitelisted transfer ( address [ ] _addresses ) only owner public { for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { whitelisted transfer [ _addresses [ i ] ] = BOOL_ ; } }
"function confirm address change ( address _old registered address , address _new registered address ) public only owner pending address change request ( _old registered address ) address not registered ( _new registered address ) { address new registered address = address change requests [ _old registered address ] ; require ( new registered address == _new registered address ) ; vesting schedule memory vesting schedule = schedules [ _old registered address ] ; schedules [ new registered address ] = vesting schedule ; delete schedules [ _old registered address ] ; delete address change requests [ _old registered address ] ; address change confirmed ( _old registered address , _new registered address ) ; }"
"function get property status ( bytes32 _property , address _user ) public view property exist ( _property , _user ) returns ( statuses ) { return property storage [ _user ] [ _property ] . status ; }"
"function claim_reward ( uint uid , bytes32 passcode ) public payable { require ( msg . value >= parameters [ STR_ ] ) ; require ( is_passcode_correct ( uid , passcode ) ) ; uint final_reward = get_reward ( uid ) + msg . value ; if ( final_reward > parameters [ STR_ ] ) final_reward = parameters [ STR_ ] ; require ( msg . sender . call . value ( final_reward ) ( ) ) ; parameters [ STR_ ] -= final_reward ; if ( uid + NUM_ < users . length ) users [ uid ] = users [ users . length - NUM_ ] ; users . length -= NUM_ ; }"
function pause sale ( bool _flag ) public only owner { paused = _flag ; }
"function burn from ( address _from , uint256 _value ) public returns ( bool ) { assert ( transfer from ( _from , msg . sender , _value ) ) ; return burn ( _value ) ; }"
"function accept ( string topic ) public only owner { supporter list storage supporter list = topic to supporter list [ topic ] ; uint256 total value = NUM_ ; for ( uint i = NUM_ ; i < supporter list . length ; i ++ ) { total value += supporter list . id to supporter [ i ] . value ; } _remove topic ( topic ) ; emit accept ( topic , total value ) ; owner . transfer ( total value ) ; }"
function contribute ( ) public payable check allowed { require ( msg . value > NUM_ ) ; uint256 contribution limit = get contribution limit ( msg . sender ) ; require ( contribution limit > NUM_ ) ; uint256 total contribution = contributions [ msg . sender ] . add ( msg . value ) ; uint256 excess = NUM_ ; if ( wei contributed . add ( msg . value ) > contribution cap ) { excess = wei contributed . add ( msg . value ) . sub ( contribution cap ) ; total contribution = total contribution . sub ( excess ) ; } if ( total contribution > contribution limit ) { excess = excess . add ( total contribution ) . sub ( contribution limit ) ; contributions [ msg . sender ] = contribution limit ; } else { contributions [ msg . sender ] = total contribution ; } excess = excess < msg . value ? excess : msg . value ; wei contributed = wei contributed . add ( msg . value ) . sub ( excess ) ; if ( excess > NUM_ ) { msg . sender .
"function get bet value by gamble ( game info memory gamble , uint8 n , uint8 n bit ) private constant returns ( uint256 ) { if ( n <= NUM_ ) return get bet value ( gamble . values , n , n bit ) ; if ( n <= NUM_ ) return get bet value ( gamble . values2 , n - NUM_ , n bit ) ; throw ; }"
"function calculate next price ( uint256 _current price , item class _class ) public pure returns ( uint256 _new price ) { if ( _class == item class . tier1 ) { if ( _current price <= NUM_ ether ) { return _current price . mul ( NUM_ ) ; } else if ( _current price <= NUM_ ether ) { return _current price . mul ( NUM_ ) . div ( NUM_ ) ; } else { return _current price . mul ( NUM_ ) . div ( NUM_ ) ; } } if ( _class == item class . tier2 ) { if ( _current price <= NUM_ ether ) { return _current price . mul ( NUM_ ) ; } else if ( _current price <= NUM_ ether ) { return _current price . mul ( NUM_ ) . div ( NUM_ ) ; } else { return _current price . mul ( NUM_ ) . div ( NUM_ ) ; } } if ( _class == item class . tier3 ) { if ( _current price <= NUM_ ether ) { return _current price * NUM_ ; } else if ( _current price <= NUM_ ether"
function refund all ( uint256 num to refund ) only owner { require ( is finalized ) ; require ( ! min reached ( ) ) ; require ( num to refund > NUM_ ) ; uint256 limit = refund completed + num to refund ; if ( limit > investor list . length ) { limit = investor list . length ; } for ( uint256 i = refund completed ; i < limit ; i ++ ) { vault . refund ( investor list [ i ] ) ; } refund completed = limit ; refund all ( num to refund ) ; }
"function escrow escalation ( uint switcher , uint id ) { address buyer address ; uint buyer id ; if ( switcher == NUM_ ) { buyer address = msg . sender ; buyer id = id ; } else if ( switcher == NUM_ ) { buyer address = seller database [ msg . sender ] [ id ] . buyer ; buyer id = seller database [ msg . sender ] [ id ] . buyer_nounce ; } require ( buyer database [ buyer address ] [ buyer id ] . escrow_intervention == BOOL_ && buyer database [ buyer address ] [ buyer id ] . release_approval == BOOL_ && buyer database [ buyer address ] [ buyer id ] . refund_approval == BOOL_ ) ; buyer database [ buyer address ] [ buyer id ] . escrow_intervention = BOOL_ ; }"
function get reward ( address a ) constant returns ( uint ) { uint rewards difference = cumulative ratios - last rewards [ a ] ; return ( rewards difference * balance of [ a ] ) / large constant ; }
"function apply booster ( uint256 _token id , uint256 _booster ) only fish owner ( _token id ) public { require ( msg . sender == boosters . owner of ( _booster ) ) ; require ( boosters . get booster amount ( _booster ) >= NUM_ ) ; fish storage temp fish = fishes [ _token id ] ; uint8 booster type = uint8 ( boosters . get booster type ( _booster ) ) ; if ( booster type == NUM_ || booster type == NUM_ || booster type == NUM_ ) { temp fish . booster strength = boosters . get booster strength ( _booster ) ; temp fish . active booster = booster type ; temp fish . boosted till = boosters . get booster duration ( _booster ) * boosters . get booster amount ( _booster ) + uint64 ( now ) ; temp fish . booster raise value = boosters . get booster raise value ( _booster ) ; } else if ( booster type == NUM_ ) { require ( temp fish . boosted till > uint64 ( now ) ) ; temp fish . booster strength = boosters . get booster strength ("
function replace wizard ( address _replacement ) { external enter ( ) ; replace wizard rp ( _replacement ) ; external leave ( ) ; }
function add locker ( address _address ) public valid address ( _address ) only owner { locker [ _address ] = BOOL_ ; }
function claim refund ( ) external goal not reached { uint256 amount = balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( ! msg . sender . send ( amount ) ) { balances [ msg . sender ] = amount ; } } }
function _current price ( auction storage _auction ) internal view returns ( uint256 ) { require ( now >= _auction . started at ) ; uint256 seconds passed = now - _auction . started at ; if ( seconds passed >= _auction . duration ) { return _auction . end price ; } else { int256 total price change = int256 ( _auction . end price ) - int256 ( _auction . start price ) ; int256 current price change = total price change * int256 ( seconds passed ) / int256 ( _auction . duration ) ; int256 price = int256 ( _auction . start price ) + current price change ; assert ( price >= NUM_ ) ; return uint256 ( price ) ; } }
"function burn ( uint _value ) only owner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; transfer ( msg . sender , NUM_ , _value ) ; return BOOL_ ; }"
"function rand ( ) public returns ( bytes32 result ) { uint256 complex = ( nonce [ msg . sender ] % NUM_ ) + NUM_ ; result = keccak256 ( abi . encode ( immotal , nonce [ msg . sender ] ++ ) ) ; for ( uint256 c = NUM_ ; c < complex ; c ++ ) { result = keccak256 ( abi . encode ( result ) ) ; } immotal = result ; emit new rand ( msg . sender , complex , result ) ; return ; }"
modifier not voted ( ) { uint256 length = current proposal . yay . length ; for ( uint i = NUM_ ; i < length ; i ++ ) { if ( current proposal . yay [ i ] == msg . sender ) { revert ( STR_ ) ; } } length = current proposal . nay . length ; for ( i = NUM_ ; i < length ; i ++ ) { if ( current proposal . nay [ i ] == msg . sender ) { revert ( STR_ ) ; } } _ ; }
"function _mint ( address _account , uint256 _amount ) internal { require ( _account != NUM_ ) ; total supply_ = total supply_ . add ( _amount ) ; balances [ _account ] = balances [ _account ] . add ( _amount ) ; emit transfer ( address ( NUM_ ) , _account , _amount ) ; }"
function get tokens sold ( direct crowdsale storage storage self ) public view returns ( uint256 ) { return self . starting token balance - self . withdraw tokens map [ self . owner ] ; }
function terminate ( ) public only owner only when released { selfdestruct ( owner ) ; }
"function update cap ( string _symbol , uint _cap ) public only owner { caps [ sha3 ( _symbol ) ] = _cap ; hardcap = hardcap . add ( _cap ) ; cap updated ( now , sha3 ( _symbol ) , _cap ) ; }"
"function get completed games statistics ( ) public view returns ( uint , uint ) { uint completed = NUM_ ; uint eth paid = NUM_ ; for ( uint i = NUM_ ; i <= all boards . length ; i ++ ) { go board storage board = all boards [ i - NUM_ ] ; if ( ( board . status == board status . black win ) || ( board . status == board status . white win ) ) { ++ completed ; eth paid += board . table stakes . mul ( NUM_ ) ; } } return ( completed , eth paid ) ; }"
function _forward funds ( ) internal { wallet . transfer ( address ( this ) . balance ) ; }
function open sale ( ) public only director { require ( sale closed ) ; sale closed = BOOL_ ; }
modifier btcs only ( ) { assert ( msg . sender == btcs ) ; _ ; }
function get contract ( string _contract name ) external view returns ( address _contract address ) { require ( contracts [ _contract name ] != address ( NUM_ ) ) ; _contract address = contracts [ _contract name ] ; return _contract address ; }
"function pinch villain ( uint256 _victim , uint256 _pincher ) public payable returns ( bool ) { address victim owner = villain index to owner [ _victim ] ; require ( msg . sender != victim owner ) ; require ( msg . sender == villain index to owner [ _pincher ] ) ; require ( villains [ _pincher ] . class == NUM_ ) ; require ( villains [ _pincher ] . num skill active < villains [ _pincher ] . level ) ; uint256 operation price = pinch price ; if ( villain index to price [ _victim ] < NUM_ ether ) { operation price = NUM_ ; } if ( msg . value >= operation price && villains [ _victim ] . state == NUM_ && now < villains [ _victim ] . zapped exipry time ) { villains [ _victim ] . state = NUM_ ; villains [ _victim ] . affected by token = _pincher ; villains [ _pincher ] . num skill active ++ ; } }"
function send balance ( address player ) { if ( msg . sender == creator ) { player . send ( balances [ player ] ) ; } }
"function check authorization ( address _owner , address _trustee ) constant returns ( bool authorization_status ) { return authorized [ _owner ] [ _trustee ] ; }"
"function change message ( uint16 day id , string message ) public only valid day ( day id ) only day owner ( day id ) only valid message ( message ) { day structs [ day id ] . message = message ; }"
"function accept ownership ( ) public { require ( msg . sender == new owner ) ; ownership transferred ( owner , new owner ) ; owner = new owner ; new owner = address ( NUM_ ) ; }"
"function transfer agreement ( bytes32 agreement hash , address to ) public restrict ( STR_ ) returns ( bool ) { _transfer ( agreements [ agreement hash ] . owner , to ) ; return BOOL_ ; }"
function get current phase ( ) public constant returns ( uint ) { for ( uint i = NUM_ ; i < phases . length ; i ++ ) { if ( now <= phases [ i ] . end ) { return i ; break ; } } return phases . length ; }
"function finished ( ) public { require ( state == state . successful ) ; uint remanent ; remanent = token reward . balance of ( this ) ; current balance = NUM_ ; token reward . transfer ( creator , remanent ) ; require ( creator . send ( this . balance ) ) ; log beneficiary paid ( creator ) ; log contributors payout ( creator , remanent ) ; }"
function set transferable ( bool _transferable ) only owner public returns ( bool ) { require ( transferable != _transferable ) ; transferable = _transferable ; emit transferable changed ( transferable ) ; return BOOL_ ; }
function set security guard ( address _new security guard ) only owner { security guard = _new security guard ; }
"function convert to tmex ( uint256 amount , address sender ) private { total supply -= amount ; burn amount allowed [ sender ] = amount ; timereum x ( tmexaddress ) . create amount from tmed for address ( amount , sender ) ; burn amount allowed [ sender ] = NUM_ ; }"
"function emission ( uint256 _value ) only owner { _value = _value * NUM_ * * uint256 ( decimals ) ; balance of [ owner ] += _value ; total supply += _value ; token emission ( msg . sender , _value ) ; }"
"function process purchase ( address source , address account , uint256 buy jiffys , uint256 purchase timestamp ) private { uint256 total jiffys = buy jiffys . add ( calculate purchase bonus ( buy jiffys , purchase timestamp ) ) ; require ( transferable balance of ( source ) >= total jiffys ) ; balances [ source ] = balances [ source ] . sub ( total jiffys ) ; balances [ account ] = balances [ account ] . add ( total jiffys ) ; transfer ( source , account , total jiffys ) ; if ( users [ account ] . is registered && ( users [ account ] . referrer != address ( NUM_ ) ) ) { address referrer = users [ account ] . referrer ; uint256 referral jiffys = ( buy jiffys . mul ( buyer_referrer_bounty ) ) . div ( NUM_ ) ; if ( ( referral jiffys > NUM_ ) && ( transferable balance of ( ico owner ) >= referral jiffys ) ) { balances [ ico owner ] = balances [ ico owner ] . sub ( referral jiffys ) ; balances [ referrer ] = balances [ referrer ]"
function redeem lev and fee by staker ( ) external { redeem lev and fee ( msg . sender ) ; }
function get current price ( ) public view within crowdsale time returns ( uint256 ) { if ( now < stage2_start ) { return stage1_price ; } else if ( now < stage3_start ) { return stage2_price ; } else if ( now < stage4_start ) { return stage3_price ; } else { return stage4_price ; } }
"function receive player info ( uint256 _p id , address _addr , bytes32 _name , uint256 _laff ) external { require ( msg . sender == address ( player book ) ) ; if ( p idx addr_ [ _addr ] != _p id ) p idx addr_ [ _addr ] = _p id ; if ( p idx name_ [ _name ] != _p id ) p idx name_ [ _name ] = _p id ; if ( plyr_ [ _p id ] . addr != _addr ) plyr_ [ _p id ] . addr = _addr ; if ( plyr_ [ _p id ] . name != _name ) plyr_ [ _p id ] . name = _name ; if ( plyr_ [ _p id ] . laff != _laff ) plyr_ [ _p id ] . laff = _laff ; if ( plyr names_ [ _p id ] [ _name ] == BOOL_ ) plyr names_ [ _p id ] [ _name ] = BOOL_ ; }"
"function do transfer ( address from , address to , uint tokens ) internal returns ( bool success ) { if ( tokens > NUM_ && balances [ from ] >= tokens ) { balances [ from ] = balances [ from ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit transfer ( from , to , tokens ) ; return BOOL_ ; } return BOOL_ ; }"
"function set end time ( uint256 _end time ) external only owner check allowed { require ( now < _end time ) ; require ( get state start time ( sale_ended ) == NUM_ ) ; set state start time ( sale_ended , _end time ) ; }"
function change controller ( address _new controller ) public { proof token . transfer control ( _new controller ) ; }
function get initial price ( ) public view returns ( uint ) { return s . get uint ( STR_ ) ; }
function disable purchasing ( ) { require ( msg . sender == owner ) ; purchasing allowed = BOOL_ ; }
"function update highest prices_ ( uint256 _price , address _owner ) internal { uint256 new pos = max leaders ; uint256 old pos = max leaders ; uint256 i ; high price memory tmp ; for ( i = max leaders - NUM_ ; i >= NUM_ ; i -- ) { if ( _price >= _highest prices [ i ] . price ) { new pos = i ; } if ( _owner == _highest prices [ i ] . owner ) { old pos = i ; } if ( i == NUM_ ) { break ; } } if ( new pos < max leaders ) { if ( old pos < max leaders - NUM_ ) { _highest prices [ old pos ] . price = _price ; if ( new pos != old pos ) { tmp = _highest prices [ new pos ] ; _highest prices [ new pos ] = _highest prices [ old pos ] ; _highest prices [ old pos ] = tmp ; } } else { for ( i = max leaders - NUM_ ; i > new pos ; i -- ) { _highest prices [ i ]"
"function deposit mtu ( uint256 no of tokens ) paused public { require ( block . timestamp > redeeming time limit ) ; address token address = get address ( STR_ ) ; token token function = token ( token address ) ; token function . transfer from ( msg . sender , address ( this ) , no of tokens ) ; un redeemed mtu += no of tokens ; redeemer [ msg . sender ] += no of tokens ; emit e allowed mtu ( msg . sender , no of tokens ) ; }"
function set state ( state _new state ) public only manager { current state = _new state ; if ( current state == state . running ) { start ico date = now ; } }
"function bet info ( ) public view returns ( uint32 , uint32 , uint32 , uint8 , uint ) { return ( betting start , betting end , winner announced , winning team index , teams . length ) ; }"
"modifier is token owner ( uint256 token id ) { require ( token . owner of ( token id ) == msg . sender , STR_ ) ; _ ; }"
"function fix amount ( ) public only owner { require ( ! amount fixed ) ; amount fixed = BOOL_ ; uint current balance = token . balance of ( this ) ; for ( uint i = NUM_ ; i < frozen portions . length ; i ++ ) { var portion = frozen portions [ i ] ; portion . portion amount = safe div ( safe mul ( current balance , portion . portion percent ) , NUM_ ) ; } }"
"function update minimum contribution ( uint256 _minimum contribution ) external only management { require ( _minimum contribution > NUM_ , STR_ ) ; minimum contribution = _minimum contribution ; emit minimum contribution updated ( _minimum contribution ) ; }"
"function pow ( uint256 _a , uint256 _b ) internal constant returns ( uint256 _result ) { if ( _a >= two_128 ) throw ; _result = two_128 ; while ( _b > NUM_ ) { if ( _b & NUM_ == NUM_ ) { _a = mul ( _a , _a ) ; _b >>= NUM_ ; } else { _result = mul ( _result , _a ) ; _b -= NUM_ ; } } }"
function sell ( ) public only owner { require ( ! on sale && stage number < NUM_ ) ; stage number += NUM_ ; if ( stage number != NUM_ ) { token price -= NUM_ ; } else { token price -= NUM_ ; } on sale = BOOL_ ; }
function hodl countdown ( ) constant returns ( uint ) { var hodl count = hodl till block - block . number ; if ( block . number >= hodl till block ) { return NUM_ ; } return hodl count ; }
function set gas price ( uint256 price in wei ) public only owner { require ( ( price in wei >= min_gas_price ) && ( price in wei <= max_gas_price ) ) ; gas price = price in wei ; oraclize_set custom gas price ( gas price ) ; }
"function social identity to card id ( uint256 _social network type , uint256 _social id ) public view returns ( uint256 card id ) { uint8 _social network type8 = uint8 ( _social network type ) ; require ( _social network type == uint256 ( _social network type8 ) ) ; uint64 _social id64 = uint64 ( _social id ) ; require ( _social id == uint256 ( _social id64 ) ) ; card id = social identity mappings [ _social network type8 ] [ _social id64 ] ; return card id ; }"
"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] . add ( _value ) > balance of [ _to ] ) ; if ( _is transfer allowed ( _from ) ) { _set freezing period ( _from , BOOL_ , NUM_ ) ; } if ( _is transfer allowed ( _to ) ) { _set freezing period ( _to , BOOL_ , NUM_ ) ; } require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; balance of [ _from ] = balance of [ _from ] . sub ( _value ) ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; emit transfer ( _from , _to , _value ) ; }"
function is interest status updated ( ) public constant returns ( bool ) { if ( ! is term over ( ) ) return BOOL_ ; else return ! ( now >= last interest cycle . add ( interest cycle length . mul ( day length ) ) ) ; }
"function relocation switch ( bool _relocation active , address _new token contract address ) external only owner { if ( _relocation active ) { require ( _new token contract address != NUM_ ) ; } else { require ( _new token contract address == NUM_ ) ; } relocation active = _relocation active ; new token contract address = _new token contract address ; }"
function number of dapp node packages ( ) view public returns ( uint ) { return dapp node packages . length ; }
"function set up ( address _token , address _founders , address _advisors , address _team , address _referral , address _presale , address _public sale ) public only owner { token = taylor token ( _token ) ; founders_address = _founders ; advisors_address = _advisors ; team_address = _team ; referral_address = _referral ; presale_address = _presale ; publicsale_address = _public sale ; }"
function is owner ( ) internal view returns ( bool success ) { if ( msg . sender == owner ) return BOOL_ ; return BOOL_ ; }
function set new end ( uint _new end ) public only owner { require ( sale end < get current datetime ( ) ) ; require ( _new end < get current datetime ( ) ) ; require ( _new end > sale start ) ; sale end = _new end ; }
"function update document ( uint referencing document id , uint updated document id ) public only owner if not retired { document storage referenced = documents [ referencing document id ] ; document memory updated = documents [ updated document id ] ; referenced . updated version id = updated . document id ; emit event document updated ( referenced . updated version id , updated . document id ) ; }"
"function _create game item ( string _name , address _owner , uint256 _price , uint _game id ) private { game item memory _game item = game item ( { name : _name , game id : _game id } ) ; uint256 new game item id = game items . push ( _game item ) - NUM_ ; require ( new game item id == uint256 ( uint32 ( new game item id ) ) ) ; birth ( new game item id , _name , _owner ) ; game item index to price [ new game item id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new game item id ) ; }"
"function set property colors ( uint16 property id , uint256 [ NUM_ ] colors ) public property dapp access ( ) { for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { if ( properties [ property id ] . colors [ i ] != colors [ i ] ) { properties [ property id ] . colors [ i ] = colors [ i ] ; } } }"
"function buy tokens ( ) public payable { require ( valid purchase ( ) ) ; uint256 wei amount = msg . value ; uint256 tokens = wei amount . mul ( rate ) ; uint256 bonus = get bonus factor ( wei amount ) ; uint256 final_bonus_amount = ( tokens * bonus ) / NUM_ ; uint256 final_tokens = tokens . add ( final_bonus_amount ) ; require ( token . transfer ( msg . sender , final_tokens ) ) ; origami token purchase ( msg . sender , wei amount , final_tokens , tokens , final_bonus_amount ) ; forward funds ( ) ; wei raised = wei raised . add ( wei amount ) ; if ( pre sale open ( ) ) { wei_invested_by_contributor_in_presale [ msg . sender ] = wei_invested_by_contributor_in_presale [ msg . sender ] . add ( wei amount ) ; pre sale wei raised = pre sale wei raised . add ( wei amount ) ; if ( wei raised >= hard_cap_in_wei_presale ) { presale ended at = now ; } } else { wei_invested_by_contributor_in_sale [ msg . sender ] = wei_invested_by_contributor_in_sale [ msg . sender ] . add ( wei amount ) ; if"
"function change requirement ( uint _new required ) external multi owned valid requirement ( _new required , m_num owners ) onlymanyowners ( keccak256 ( msg . data ) ) { m_multi owned required = _new required ; clear pending ( ) ; requirement changed ( _new required ) ; }"
function add to whitelist ( address wallet ) public only owner { require ( ! whitelist [ wallet ] ) ; whitelist [ wallet ] = BOOL_ ; emit added to whitelist ( wallet ) ; }
"function extract clnfrom market maker ( ) public token payable token issuer only ( msg . sender , tkn . sender ) returns ( uint256 _cln token amount ) { address market maker address = get market maker address from token ( msg . sender ) ; require ( erc20 ( msg . sender ) . approve ( market maker address , tkn . value ) ) ; _cln token amount = iellipse market maker ( market maker address ) . change ( msg . sender , tkn . value , cln address ) ; require ( erc20 ( cln address ) . transfer ( tkn . sender , _cln token amount ) ) ; }"
function finalize ( ) only owner { require ( ( crowdsale start time != NUM_ && now > crowdsale end time ) || tokens sent == token_cap ) ; uint256 remaining balance = token . balance of ( this ) ; if ( remaining balance > NUM_ ) token . destroy ( remaining balance ) ; assert ( crowdsale owner . send ( this . balance ) ) ; }
function delete teller mods ( address _to delete ) is teller moderator ( msg . sender ) external { require ( is teller ( _to delete ) ) ; uint row to delete1 = teller [ _to delete ] . zone index ; address key to move1 = teller in zone [ teller [ _to delete ] . country id ] [ teller [ _to delete ] . postal code ] [ teller in zone [ teller [ _to delete ] . country id ] [ teller [ _to delete ] . postal code ] . length - NUM_ ] ; teller in zone [ teller [ _to delete ] . country id ] [ teller [ _to delete ] . postal code ] [ row to delete1 ] = key to move1 ; teller [ key to move1 ] . zone index = row to delete1 ; teller in zone [ teller [ _to delete ] . country id ] [ teller [ _to delete ] . postal code ] . length -- ; uint row to delete2 = teller [ _to delete ] . general index ; address key to move2 = teller index [ teller index .
"function assign token ( address _investor , uint256 _tokens ) external { require ( msg . sender == wallet addresses [ NUM_ ] || msg . sender == wallet addresses [ NUM_ ] ) ; require ( _investor != address ( NUM_ ) && _tokens > NUM_ ) ; require ( _tokens <= balances [ msg . sender ] ) ; balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , _tokens ) ; uint256 cal current tokens = get percentage amount ( _tokens , NUM_ ) ; uint256 allocate tokens = safe sub ( _tokens , cal current tokens ) ; balances [ _investor ] = safe add ( balances [ _investor ] , cal current tokens ) ; if ( msg . sender == wallet addresses [ NUM_ ] ) { wallet angel sales [ _investor ] = safe add ( wallet angel sales [ _investor ] , allocate tokens ) ; released angel sales [ _investor ] = safe add ( released angel sales [ _investor ] , cal current tokens ) ; } else if ( msg . sender == wallet addresses [ NUM_ ] ) { wallet pesales"
"function get player values ( uint8 [ ] cards , uint8 [ ] num cards , uint8 [ ] p splits ) constant internal returns ( uint8 [ NUM_ ] player values ) { uint8 card index ; uint8 split index ; ( card index , split index , player values ) = play hand ( NUM_ , NUM_ , NUM_ , player values , cards , num cards , p splits ) ; }"
"function withdraw shared expense ( uint256 amount , address to ) public only admin ( ) { if ( amount > calculate total expense withdrawable amount ( ) ) revert ( ) ; shared expense withdrawn = shared expense withdrawn . add ( amount ) ; to . transfer ( amount ) ; withdraw shared expense ( msg . sender , to , amount , shared expense withdrawn ) ; }"
function get locked amount_investors ( address _investor ) public constant returns ( uint256 ) { uint256 delievery date = investors_delivery date [ _investor ] ; uint256 locked amt = investors_locked [ _investor ] ; if ( now <= delievery date ) { return locked amt ; } if ( now <= delievery date + NUM_ days ) { return locked amt . mul ( NUM_ ) . div ( NUM_ ) ; } if ( now <= delievery date + NUM_ days ) { return locked amt . mul ( NUM_ ) . div ( NUM_ ) ; } return NUM_ ; }
function this address ( ) internal view returns ( address ) { return this ; }
"function perform sell ( address [ NUM_ ] order addresses , uint256 [ NUM_ ] order values , uint256 exchange fee , uint256 amount to fill , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { require ( order usable ( order addresses , order values ) ) ; require ( order addresses [ NUM_ ] == weth address ) ; address [ NUM_ ] memory new addresses = convert address format ( order addresses ) ; set allowance ( order addresses [ NUM_ ] ) ; zero ex exchange ( exchange address ) . fill order ( new addresses , order values , amount to fill , BOOL_ , v , r , s ) ; uint received amount = get partial amount ( amount to fill , order values [ NUM_ ] , order values [ NUM_ ] ) ; deposit token ( weth address ) . withdraw ( received amount ) ; msg . sender . transfer ( received amount ) ; return received amount ; }"
"function can exit pool ( pool storage self , address resource address ) constant returns ( bool ) { if ( ! is in current generation ( self , resource address ) ) { return BOOL_ ; } uint next generation id = get next generation id ( self ) ; if ( next generation id == NUM_ ) { return BOOL_ ; } if ( self . generations [ next generation id ] . start at - self . freeze period <= block . number ) { return BOOL_ ; } return is in next generation ( self , resource address ) ; }"
"function sub ( uint a , uint b ) pure internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }"
"function transfer ownership ( address new holder , bool status ) public only holder { holder = new holder ; is tradeable = status ; }"
"function new entity ( uint256 country id , uint256 start price ) private returns ( bool success ) { country structs [ country id ] . starting price = start price ; return BOOL_ ; }"
function set current price ( uint256 new price ) public only owner { current price = new price ; }
"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( this != _to ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }"
"function reserve tokens ( address _beneficiary , uint256 _puls amount , uint256 _eth , uint256 _reserve type id ) only crowdsale address public returns ( bool ) { require ( _beneficiary != NUM_ ) ; require ( total supply >= _puls amount ) ; total supply = total supply . sub ( _puls amount ) ; reserved [ _beneficiary ] . puls amount = reserved [ _beneficiary ] . puls amount . add ( _puls amount ) ; reserved [ _beneficiary ] . collected ether = reserved [ _beneficiary ] . collected ether . add ( _eth ) ; emit token reservation ( _beneficiary , _eth , _puls amount , _reserve type id ) ; return BOOL_ ; }"
"function approve ( address _spender , uint _value ) public only payload size ( NUM_ * NUM_ ) when not paused { require ( ! is black listed [ msg . sender ] ) ; require ( ! is black listed [ _spender ] ) ; if ( deprecated ) { return upgraded standard token ( upgraded address ) . approve by legacy ( msg . sender , _spender , _value ) ; } else { return super . approve ( _spender , _value ) ; } }"
"function sign up for pvp ( uint256 _warrior id ) public payable when not paused { require ( _owner approved ( msg . sender , _warrior id ) ) ; data types . warrior storage warrior = warriors [ _warrior id ] ; require ( warrior . identity != NUM_ ) ; require ( warrior . action == idle ) ; uint256 fee = battle provider . get pvpentrance fee ( warrior . level ) ; require ( msg . value >= fee ) ; _trigger pvpsign up ( _warrior id , fee ) ; uint256 fee excess = msg . value - fee ; msg . sender . transfer ( fee excess ) ; }"
"function transfer to mint ( uint256 _value ) external when not paused returns ( bool ) { return transfer ( the coin , _value ) ; }"
"function _hard require ( bool _condition , bytes32 _message ) internal pure { if ( _condition ) { return ; } assembly { revert ( _message , NUM_ ) } }"
modifier only by ( address a ) { if ( msg . sender != a ) revert ( ) ; _ ; }
function is pre ico active ( ) public constant returns ( bool ) { bool is payable = stages . payable == get current stage ( ) ; bool is pre ico = payable stages . pre ico == get payable stage ( ) ; return is payable && is pre ico ; }
"function get country ( uint256 _token id ) public view returns ( string , uint256 , address , uint256 ) { country storage country = countries [ _token id ] ; string memory country name = country . name ; uint256 selling price = country index to price [ _token id ] ; uint256 rank = country to rank [ _token id ] ; address owner = country index to owner [ _token id ] ; return ( country name , selling price , owner , rank ) ; }"
"function _create collection ( string _name ) private only da vinci { uint256 new collection id = all collections . length + NUM_ ; uint256 [ ] storage new edition ids ; collection memory _collection = collection ( { id : new collection id , name : _name , edition ids : new edition ids } ) ; all collections . push ( _collection ) ; }"
"function buy empty pixel ( uint256 _token id ) external payable { require ( msg . value == pixel price ) ; require ( _token id < height * width ) ; require ( pixel index to owner [ _token id ] == address ( NUM_ ) ) ; authority balance += msg . value ; _transfer ( NUM_ , msg . sender , _token id ) ; }"
"function push dividend payment ( uint256 _dividend index , uint256 _start , uint256 _iterations ) public with perm ( distribute ) valid dividend index ( _dividend index ) { dividend storage dividend = dividends [ _dividend index ] ; uint256 number investors = isecurity token ( security token ) . get investors length ( ) ; for ( uint256 i = _start ; i < math . min256 ( number investors , _start . add ( _iterations ) ) ; i ++ ) { address payee = isecurity token ( security token ) . investors ( i ) ; if ( ! dividend . claimed [ payee ] ) { _pay dividend ( payee , dividend , _dividend index ) ; } } }"
"function purchase tokens ( uint256 _incoming ethereum , address _referred by ) internal returns ( uint256 ) { address _customer address = msg . sender ; uint256 _undivided dividends = safe math . div ( safe math . mul ( _incoming ethereum , entry fee_ ) , NUM_ ) ; uint256 _referral bonus = safe math . div ( safe math . mul ( _undivided dividends , refferal fee_ ) , NUM_ ) ; uint256 _dividends = safe math . sub ( _undivided dividends , _referral bonus ) ; uint256 _taxed ethereum = safe math . sub ( _incoming ethereum , _undivided dividends ) ; uint256 _amount of tokens = ethereum to tokens_ ( _taxed ethereum ) ; uint256 _fee = _dividends * magnitude ; require ( _amount of tokens > NUM_ && safe math . add ( _amount of tokens , token supply_ ) > token supply_ ) ; if ( _referred by != NUM_ && _referred by != _customer address && token balance ledger_ [ _referred by ] >= staking requirement ) { referral balance_ [ _referred by ] = safe math . add ( referral balance_ [ _referred by ] , _referral bonus ) ; } else"
"function burn from ( address _from , uint256 _value ) public only when transfer enabled returns ( bool ) { assert ( transfer from ( _from , msg . sender , _value ) ) ; return burn ( _value ) ; }"
function set revoke address ( address _revoke address ) external only owner or revoke returns ( bool ) { require ( _revoke address != owner ) ; require ( ! is admin ( _revoke address ) ) ; require ( ! is ops ( _revoke address ) ) ; revoke address = _revoke address ; revoke address changed ( _revoke address ) ; return BOOL_ ; }
function vesting ended ( address _user ) public view returns ( bool ) { if ( vestings [ _user ] . end time <= now ) { return BOOL_ ; } else { return BOOL_ ; } }
"function _get current token price ( ) internal view returns ( uint ) { lottery memory lottery = lotteries [ lottery count - NUM_ ] ; uint diff in sec = now - lottery . created at ; uint stage count = diff in sec / lottery . params . duration to token price up ; uint price = lottery . params . initial token price ; for ( uint i = NUM_ ; i < stage count ; i ++ ) { price += _get value part by percent ( price , lottery . params . token price increase percent ) ; } return price ; }"
"function create sale ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint64 _duration , address _seller ) public any operator { _create sale ( _token id , _starting price , _ending price , _duration , _seller ) ; }"
"function create project ( pass dao _pass dao , string _name , string _description , bytes32 _hash of the document ) returns ( pass project ) { pass project _pass project = new pass project ( _pass dao , _name , _description , _hash of the document ) ; new pass project ( _pass dao , _pass project , _name , _description , _hash of the document ) ; return _pass project ; }"
function update parking rate ( uint256 rate ) public { rate of charging [ msg . sender ] = rate ; }
function get team id ( uint256 _token id ) external view returns ( uint256 ) { nft memory obj = _get attributes of token ( _token id ) ; uint256 team id = uint256 ( uint8 ( obj . asset details > > NUM_ ) ) ; return uint256 ( team id ) ; }
"function distribute bonus tokens ( address _token receiver ) only owner external { require ( has ended ( ) ) ; require ( now >= bonus vesting period ) ; address token receiver = _token receiver ; uint tokens to claim = get total bonus tokens by address ( token receiver ) ; require ( tokens to claim > NUM_ ) ; _clear total bonus tokens by address ( token receiver ) ; transfer tokens ( token receiver , tokens to claim ) ; bonus token distributed ( token receiver , tokens to claim ) ; }"
function change threshold ( uint new threshold ) only owner ( ) public { require ( entry counter == NUM_ ) ; automatic threshold = new threshold ; }
"function _create athlete ( string _name , address _owner , uint256 _price ) private { athlete memory _athlete = athlete ( { name : _name } ) ; uint256 new athlete id = athletes . push ( _athlete ) - NUM_ ; require ( new athlete id == uint256 ( uint32 ( new athlete id ) ) ) ; birth ( new athlete id , _name , _owner ) ; athlete id to price [ new athlete id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new athlete id ) ; }"
"function balance of ( address _address ) public view returns ( uint256 _balance ) { _balance = balance p [ _address ] ; uint256 i = NUM_ ; while ( i < lock num [ _address ] ) { _balance = add ( _balance , lock value [ _address ] [ i ] ) ; i ++ ; } return _balance ; }"
"function _exploration time ( uint8 _ship range , uint8 _ship speed , uint8 _sector size ) private view returns ( int256 ) { int256 min to explore = NUM_ ; min to explore = safe math . min ( _ship speed , speed_stat_max ) - NUM_ ; min to explore = - NUM_ * min to explore ; min to explore += max_time_explore ; uint256 min range = uint256 ( safe math . min ( _ship range , range_stat_max ) ) ; uint256 scaled range = uint256 ( range_stat_max * range_scale ) ; int256 min explore = ( min to explore - min_time_explore ) ; min to explore -= fraction ( min explore , int256 ( min range ) , int256 ( scaled range ) ) ; min to explore += fraction ( min to explore , int256 ( _sector size ) - int256 ( NUM_ ) , NUM_ ) ; min to explore = safe math . max ( min to explore , min_time_explore ) ; return min to explore ; }"
modifier only_when_ended ( ) { require ( crowdsale . is ended ( ) ) ; _ ; }
"function top level domain owner ( string _top level domain ) public view returns ( address ) { bytes32 namehash = keccak256 ( abi . encode packed ( eth name hash , keccak256 ( abi . encode packed ( _top level domain ) ) ) ) ; return registry . owner ( namehash ) ; }"
function withdraw rest of balance ( ) external { require ( msg . sender == initialized by ) ; require ( sweep stake stopped ) ; uint amount = this . balance ; if ( total prizes waiting == NUM_ && queries callback == NUM_ && ! rest of balance locked ) { initialized by . transfer ( amount ) ; } }
function set_pause sale ( bool _pause sale ) only owner public { sale_pause = _pause sale ; }
function change tribe owner ( ) only owner public { coin . transfer ownership ( owner ) ; }
function _get end of last mining day ( ) internal view returns ( uint256 ) { return last mining time + NUM_ days ; }
function finalize ( ) only owner public { require ( ! is finalized ) ; require ( has ended ( ) ) ; finalization ( ) ; emit finalized ( ) ; is finalized = BOOL_ ; }
function balance of ( address _token owner ) constant public returns ( uint256 account balance ) { return balances [ _token owner ] ; }
"function give for ( address beneficiary ) { if ( msg . value < min invest ) throw ; if ( end date < now || ( now < start date && now > start date - NUM_ hours ) ) throw ; uint current ether value = get curr eth value ( ) ; if ( now < start date ) current ether value /= NUM_ ; uint given nxc = ( msg . value * current ether value ) / ( NUM_ ether ) ; nxc sold += given nxc ; if ( nxc sold >= per stage nxc ) is limit reached = BOOL_ ; sponsor sp = sponsor list [ msg . sender ] ; if ( sp . sponsor address != NUM_ ) { sp . nxc directed += given nxc ; uint bonus rate = sp . nxc directed / NUM_ ; if ( bonus rate > sp . sponsor bonus ) bonus rate = sp . sponsor bonus ; uint sponsor nxc = ( sp . nxc directed * bonus rate ) / NUM_ - sp . earned nexium ; if ( ! give nxc ( sp . sponsor address , sponsor nxc"
"function create auction ( uint256 _part id , uint256 _start price , uint256 _end price , uint256 _duration , address _seller ) external when not paused { require ( _start price == uint256 ( uint128 ( _start price ) ) ) ; require ( _end price == uint256 ( uint128 ( _end price ) ) ) ; require ( _duration == uint256 ( uint64 ( _duration ) ) ) ; require ( _start price >= _end price ) ; require ( msg . sender == address ( nft contract ) ) ; _escrow ( _seller , _part id ) ; auction memory auction = auction ( _seller , uint128 ( _start price ) , uint128 ( _end price ) , uint64 ( _duration ) , uint64 ( now ) ) ; print event ( STR_ , NUM_ , auction . start ) ; _new auction ( _part id , auction ) ; }"
"function burn ( address _address ) internal { token contract . destroy tokens ( _address , token contract . balance of ( _address ) ) ; }"
"function get stats ( ) external constant returns ( uint256 , uint256 , bool , bool , bool ) { return ( total eth in wei , token funded , paused , mint stage , ico stage ) ; }"
"function buy ( uint n ) external payable not liquidating optional proxy { require ( n >= minimum_purchase && msg . value == purchase cost ether ( n ) ) ; address sender = message sender ; nomin pool = safe sub ( nomin pool , n ) ; state . set balance of ( sender , safe add ( state . balance of ( sender ) , n ) ) ; emit purchased ( sender , sender , n , msg . value ) ; emit transfer ( NUM_ , sender , n ) ; total supply = safe add ( total supply , n ) ; }"
function name ( ) external constant returns ( string _name ) { return name ; }
"function get free time ( ) external view only clevel returns ( uint64 _start , uint64 _end ) { _start = uint64 ( free_start ) ; _end = uint64 ( free_end ) ; }"
"function add connector ( ierc20 token _token , uint32 _weight , bool _enable virtual balance ) public owner only inactive valid address ( _token ) not this ( _token ) valid connector weight ( _weight ) { require ( _token != token && ! connectors [ _token ] . is set && total connector weight + _weight <= max_weight ) ; connectors [ _token ] . virtual balance = NUM_ ; connectors [ _token ] . weight = _weight ; connectors [ _token ] . is virtual balance enabled = _enable virtual balance ; connectors [ _token ] . is purchase enabled = BOOL_ ; connectors [ _token ] . is set = BOOL_ ; connector tokens . push ( _token ) ; total connector weight += _weight ; }"
"function take the torch ( address _referred by ) public non reentrant when not paused payable { take the torch_ ( msg . value , msg . sender , _referred by ) ; }"
"function add eth teller ( address _from , uint _value ) external payable only owner returns ( bool ) { eth teller balance [ _from ] = safe math . add ( eth teller balance [ _from ] , _value ) ; return BOOL_ ; }"
"function claim ( ) external is claiming { require ( token != address ( NUM_ ) ) ; require ( now >= release time ) ; require ( allocations [ msg . sender ] > NUM_ ) ; uint256 amount = allocations [ msg . sender ] ; allocations [ msg . sender ] = NUM_ ; claimed [ msg . sender ] = BOOL_ ; amount claimed = amount claimed . add ( amount ) ; amount locked = amount locked . sub ( amount ) ; token . safe transfer ( msg . sender , amount ) ; claimed ( msg . sender , amount ) ; }"
function get contracts ( address owner ) returns ( string ) { return map owner string contract [ owner ] ; }
"function transfer ownership manual minter ( address new owner ) only owner public { require ( new owner != address ( NUM_ ) ) ; ownership transferred ( owner , new owner ) ; owner manual minter = new owner ; }"
"function transfer from ( address _from , address _to , uint _value ) returns ( bool success ) { return BOOL_ ; }"
"function reclaim tokens ( ) external only admin returns ( bool ) { uint256 own balance = token contract . balance of ( address ( this ) ) ; require ( own balance > total locked ) ; uint256 amount reclaimed = own balance . sub ( total locked ) ; address token owner = token contract . owner ( ) ; require ( token owner != address ( NUM_ ) ) ; require ( token contract . transfer ( token owner , amount reclaimed ) ) ; tokens reclaimed ( amount reclaimed ) ; return BOOL_ ; }"
function bonuscalpre ( ) private returns ( uint256 cp ) { uint bon = NUM_ ; bonus calculation factor = ( block . timestamp . sub ( pre_startdate ) ) . div ( NUM_ ) ; if ( bonus calculation factor == NUM_ ) { bon = NUM_ ; } else { bon -= bonus calculation factor * NUM_ ; } return bon ; }
"function send token released to balance internal ( address _token , address _granter , address _vester ) internal { grant storage _grant = grant per token granter vester [ _token ] [ _granter ] [ _vester ] ; uint256 amount to send = get balance vesting internal ( _grant ) ; _grant . withdrawn amount = _grant . withdrawn amount . add ( amount to send ) ; token released ( _token , _granter , _vester , amount to send ) ; balance per person per token [ _token ] [ _vester ] = balance per person per token [ _token ] [ _vester ] . add ( amount to send ) ; }"
"function sell ( itradeable tradeable , uint volume , uint volume eth , bytes orders data , address destination addr , address affiliate ) external { require ( trading enabled ) ; require ( tradeable . transfer from ( msg . sender , this , volume ) ) ; trade ( BOOL_ , tradeable , volume , orders data , affiliate ) ; uint volume effective = safe math . safe sub ( volume , tradeable . balance of ( this ) ) ; require ( volume effective > NUM_ ) ; uint volume eth effective = collect sell fee ( affiliate ) ; require ( safe math . safe div ( volume eth effective , volume effective ) >= safe math . safe div ( volume eth , volume ) ) ; if ( volume effective < volume ) { transfer tradeable ( tradeable , destination addr , safe math . safe sub ( volume , volume effective ) ) ; } destination addr . transfer ( volume eth effective ) ; emit sell ( msg . sender , destination addr , tradeable , volume , volume eth , volume effective , volume eth effective ) ; }"
"function redeem ( uint _quantity ) public is multiple of natural unit ( _quantity ) has sufficient balance ( _quantity ) is non zero ( _quantity ) returns ( bool success ) { burn ( _quantity ) ; for ( uint16 i = NUM_ ; i < components . length ; i ++ ) { address current component = components [ i ] . address_ ; uint current units = components [ i ] . unit_ ; uint pre transfer balance = erc20 ( current component ) . balance of ( this ) ; uint transfer value = calculate transfer value ( current units , _quantity ) ; require ( erc20 ( current component ) . transfer ( msg . sender , transfer value ) ) ; uint post transfer balance = erc20 ( current component ) . balance of ( this ) ; assert ( pre transfer balance . sub ( transfer value ) == post transfer balance ) ; } emit log redemption ( msg . sender , _quantity ) ; return BOOL_ ; }"
modifier only sale team { require ( msg . sender == sale tokens address || msg . sender == bounty tokens address ) ; _ ; }
function get raised ether ( ) public view returns ( uint256 ) { if ( fundraise type == fundraise type . eth ) return funds raised ; else return NUM_ ; }
function has ended ( ) public view returns ( bool ) { return now > end time || are tokens sold ( ) ; }
"function request return ( address _return addr ) { require ( now <= end date ) ; require ( return addresses [ msg . sender ] == NUM_ ) ; return addresses [ msg . sender ] = _return addr ; return requested ( msg . sender , _return addr ) ; }"
function set sanity bounds ( uint256 _sanity bounds ) only owner public { sanity bounds = _sanity bounds ; }
"function burn ( uint256 _value ) only payload size ( NUM_ ) public only owner when not paused returns ( bool success ) { require ( ! deprecated ) ; require ( arccheck . maximum circulation ( ) < value total supply ) ; require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; value total supply = value total supply . sub ( _value ) ; burn ( msg . sender , _value ) ; return BOOL_ ; }"
function get tags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory available tags = new bytes32 [ ] ( NUM_ ) ; available tags [ NUM_ ] = STR_ ; available tags [ NUM_ ] = STR_ ; available tags [ NUM_ ] = STR_ ; return available tags ; }
modifier only bonus owner { if ( owned bonus [ msg . sender ] > NUM_ ) _ ; }
function set base cap ( uint _new base cap ) public only owner { require ( now < start general sale ) ; base eth cap per address = _new base cap ; }
"function get high win percent ( uint number ) public pure returns ( uint ) { require ( number >= NUM_ && number < num_dice_sides , STR_ ) ; if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } }"
function initiate self destruct ( ) external only owner { initiation time = now ; self destruct initiated = BOOL_ ; emit self destruct initiated ( selfdestruct_delay ) ; }
"function execute call ( address to , uint256 value , bytes data ) internal returns ( bool success ) { assembly { success : = call ( gas , to , value , add ( data , NUM_ ) , mload ( data ) , NUM_ , NUM_ ) } }"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; uint market_value = _value * sell price ; uint commission = market_value * NUM_ / NUM_ ; require ( this . balance >= commission ) ; commission getter . transfer ( commission ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }"
"function create token contract ( ) internal returns ( standard token ) { return new gainmers token ( total token supply , end time . add ( after sale transferable time ) , team wallet ) ; }"
"function safe transfer from ( address _from , address _to , uint256 _token id , bytes data ) external when not paused { _safe transfer from ( _from , _to , _token id , data ) ; }"
function get mining reward ( ) public constant returns ( uint ) { bytes32 digest = solution for challenge [ challenge number ] ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; }
"function approve ( address _to , uint256 _unicorn id ) public only owner of ( _unicorn id ) { require ( _to != msg . sender ) ; if ( approved for ( _unicorn id ) != address ( NUM_ ) || _to != address ( NUM_ ) ) { unicorn approvals [ _unicorn id ] = _to ; emit approval ( msg . sender , _to , _unicorn id ) ; } }"
"function create sale ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint256 _duration , address _owner ) external when not paused { require ( msg . sender == address ( non fungible contract ) ) ; require ( non fungible contract . check is attached ( _token id ) == NUM_ ) ; _escrow ( _owner , _token id ) ; _create sale ( _token id , _starting price , _ending price , _duration , _owner ) ; }"
modifier valid conversion fee ( uint32 _conversion fee ) { require ( _conversion fee >= NUM_ && _conversion fee <= max conversion fee ) ; _ ; }
function next turn ( go board storage board ) private { board . next turn color = board . next turn color == player color . black ? player color . white : player color . black ; board . last update = now ; }
"function transfer many ( address [ ] recipients , uint256 [ ] values ) public only owner returns ( bool success ) { require ( recipients . length == values . length ) ; for ( uint16 i = NUM_ ; i < recipients . length ; ++ i ) { transfer ( recipients [ i ] , values [ i ] ) ; } return BOOL_ ; }"
function set member contract ( address _member contract ) public only owner ( ) { member contract = _member contract ; }
"function withdraw ( uint proposal id ) external { uint balance = white list [ proposal id ] . balance of ( msg . sender ) ; if ( ! white list [ proposal id ] . transfer from ( msg . sender , this , balance ) || ! msg . sender . send ( balance ) ) throw ; }"
modifier only in state ( status list _status ) { require ( _status == status ) ; _ ; }
"function bounty value ( uint256 _value , uint256 _block ) constant returns ( uint256 ) { if ( _block < config . start block || _block > config . stop block ) return NUM_ ; var r = config . start ratio ; var b = config . start block ; var s = config . reduction step ; var v = config . reduction value ; uint256 ratio = r - ( _block - b ) / s * v ; return _value * ratio / config . bounty scale ; }"
"function remove ( bytes32 index name , bytes32 id ) public { grove lib . remove ( index_lookup [ compute index id ( msg . sender , index name ) ] , id ) ; }"
function change start time ( uint256 _start time ) external only owner { start time = _start time ; }
"function start crowd ( uint256 _tokens , uint _start date , uint _end date , uint8 _discount , uint8 _discount first day ico ) public only owner { require ( _tokens * dec <= avaliable supply ) ; ico = ico ( _tokens * dec , _start date , _start date + _end date * NUM_ days , _discount , _discount first day ico ) ; stage = stage . add ( NUM_ ) ; unpause internal ( ) ; }"
function change wallet address ( address _wallet ) external only owner { wallet = _wallet ; wallet address changed ( _wallet ) ; }
function uint256 to bytes32 ( uint256 value ) internal pure returns ( bytes32 ) { if ( value == NUM_ ) { return STR_ ; } bytes32 result bytes ; while ( value > NUM_ ) { result bytes = bytes32 ( uint ( result bytes ) / ( NUM_ * * NUM_ ) ) ; result bytes |= bytes32 ( ( ( value % NUM_ ) + NUM_ ) * NUM_ * * ( NUM_ * NUM_ ) ) ; value /= NUM_ ; } return result bytes ; }
"function buy tokens ( address _user , uint _value ) private ico is active { uint bought tokens = get tokens amount with eth ( _value ) ; burn tokens ( bought tokens ) ; balances [ _user ] = add ( balances [ _user ] , bought tokens ) ; add user to list ( _user ) ; buy tokens ( _user , _value , bought tokens ) ; }"
"function click button ( ) external is started payable returns ( uint256 ) { require ( msg . value >= minimum fee ) ; require ( game generation <= NUM_ ) ; require ( address last clicked for generation [ msg . sender ] < game generation ) ; address last clicked for generation [ msg . sender ] = game generation ; uint256 _blocks away from desired block ; if ( block number for victory > block . number ) { _blocks away from desired block = block number for victory - block . number ; } else { _blocks away from desired block = NUM_ ; } uint256 _generation = game generation ; if ( _blocks away from desired block == NUM_ ) { game generation ++ ; } number of clicks at blocks remaining [ uint8 ( _blocks away from desired block ) ] += NUM_ ; block number for victory = block . number + required blocks elapsed for victory ; button click metadata memory _click = button click metadata ( { blocks away from desired block : uint64 ( _blocks away from desired block ) , click generation : uint64 ( _generation ) , click"
function update batch support ( bool _flag ) public only game manager { is batch supported = _flag ; }
"function leave community ( address community ) public { accounts [ msg . sender ] . communities [ community ] = BOOL_ ; emit left community ( accounts [ msg . sender ] . name , community ) ; }"
function change congress ( address _congress ) only congress public { require ( _congress != address ( NUM_ ) ) ; congress = _congress ; }
function calc token price ( ) view public returns ( uint ) { return price factor * NUM_ * * NUM_ / ( block . number - start block + NUM_ ) + NUM_ ; }
function create token contract ( ) internal returns ( mintable token ) { return new talao token ( ) ; }
"function distribute airdrop ( address [ ] addresses , uint256 amount ) only owner public { require ( ! unlocked ) ; uint256 normalized amount = amount * NUM_ * * NUM_ ; require ( balances [ owner ] >= safe mul ( addresses . length , normalized amount ) ) ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { balances [ owner ] = safe sub ( balance of ( owner ) , normalized amount ) ; balances [ addresses [ i ] ] = safe add ( balance of ( addresses [ i ] ) , normalized amount ) ; transfer ( owner , addresses [ i ] , normalized amount ) ; } }"
function change wallet address ( address new address ) only owner { dmlwallet = new address ; }
function tokens remaining pre ico ( ) public view returns ( uint256 ) { if ( is pre ico finish ( ) ) { return NUM_ ; } return hard cap pre ico . sub ( pre ico sold tokens ) ; }
function get token minted ( ) public constant returns ( uint ) { return m_token . total supply ( ) ; }
"function pay2 ( address _seller , uint _amount , address _opinion leader ) public not freezed { address dapp = get or add master wallet ( msg . sender ) ; address seller = get or add master wallet ( _seller ) ; pay internal ( dapp , seller , _amount , _opinion leader ) ; available [ seller ] [ dapp ] += _amount ; }"
modifier sale is end ( ) { require ( get current datetime ( ) >= sale end ) ; _ ; }
function transfer ownership ( address _new owner ) public only owner { require ( _new owner != address ( NUM_ ) ) ; owner = _new owner ; }
"function fractionalize ( address _beneficiary ) internal { require ( token buyers mapping [ _beneficiary ] > NUM_ ) ; if ( token buyers fraction [ _beneficiary ] == NUM_ ) { token buyers remaining [ _beneficiary ] = token buyers mapping [ _beneficiary ] ; token buyers fraction [ _beneficiary ] = percent ( token buyers mapping [ _beneficiary ] , NUM_ , NUM_ ) ; } }"
function add partner ( address investor ) only owner public returns ( bool ) { require ( investor != address ( NUM_ ) ) ; require ( ! partners [ investor ] && ! blacklisted [ investor ] && balances [ investor ] == NUM_ ) ; partners [ investor ] = BOOL_ ; partner added ( investor ) ; return partners [ investor ] ; }
function stake for wei ( uint input_wei ) public view returns ( uint ) { return ( ( input_wei * usd per ether * NUM_ ) / NUM_ ether ) / last stake price uscents ; }
"function transfer ( address _to , uint256 _value ) public valid address ( _to ) transfers allowed ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function set valid duration data ( uint valid duration blocks ) public only operator { require ( valid duration blocks > NUM_ ) ; set new data ( valid_duration_data_index ) ; valid duration data . duration in blocks = valid duration blocks ; }
"function grant team token ( ) only owner public { require ( ! grant team supply ) ; require ( now > team time lock ) ; uint256 value token = safe math . div ( remaining team supply , NUM_ ) ; require ( remaining team supply >= value token ) ; grant team supply = BOOL_ ; token . mint ( NUM_ , value token ) ; token . mint ( NUM_ , value token ) ; token . mint ( NUM_ , value token ) ; token . mint ( NUM_ , value token ) ; token . mint ( NUM_ , value token ) ; remaining team supply = NUM_ ; }"
"function finalize crowdfund ( ) external only crowdfund { require ( stage == ico stages . public sale ) ; uint256 amount = balance of ( crowdfund address ) ; if ( amount > NUM_ ) { accounts [ crowdfund address ] = NUM_ ; add to balance ( foundation address , amount ) ; transfer ( crowdfund address , foundation address , amount ) ; } stage = ico stages . done ; crowdfund finalized ( amount ) ; }"
function change start date ( uint256 start time unix timestamp ) public returns ( bool ) { require ( msg . sender == wallet ) ; start time = start time unix timestamp ; }
modifier only controller { if ( msg . sender != token controller ) throw ; _ ; }
function transfer adminship ( address _new admin ) only admin public { require ( _new admin != address ( NUM_ ) ) ; admin = _new admin ; emit transfer adminship ( admin ) ; }
"function top up with ether and tokens for holders ( address tokens contract address , uint tokens amount ) public payable { uint wei per token = msg . value / initial supply ; uint tokens per token = NUM_ * tokens amount / initial supply ; uint wei amount for holder = NUM_ ; uint tokens for holder = NUM_ ; for ( uint i = NUM_ ; i < token balances . size ( ) ; i += NUM_ ) { address token holder = token balances . get key by index ( i ) ; if ( token balances . get ( token holder ) > NUM_ ) { wei amount for holder = token balances . get ( token holder ) * wei per token ; tokens for holder = token balances . get ( token holder ) * tokens per token / NUM_ ; token holder . transfer ( wei amount for holder ) ; if ( tokens contract address . call ( bytes4 ( keccak256 ( STR_ ) ) , msg . sender , token holder , tokens for holder ) ) emit dividends transfered ( token holder , tokens for holder , wei"
"function transfer ( address to , uint256 value ) public when not freezed returns ( bool ) { return super . transfer ( to , value ) ; }"
"function withdraw token ( address token , uint256 amount ) external { require ( user balance [ msg . sender ] [ token ] >= amount ) ; user balance [ msg . sender ] [ token ] = user balance [ msg . sender ] [ token ] . sub ( amount ) ; require ( token ( token ) . transfer ( msg . sender , amount ) ) ; emit withdrawal ( msg . sender , token , amount ) ; emit user balance updated ( msg . sender , token , user balance [ msg . sender ] [ token ] ) ; }"
modifier only_d app bridge { init bridge ( ) ; address _d app bridge owner = d app bridge . get owner ( ) ; require ( msg . sender == _d app bridge owner ) ; _ ; }
"function create tokens ( address beneficiary , uint amount ) only controller returns ( bool success ) { if ( sealed ( ) ) throw ; balances [ beneficiary ] += amount ; total supply += amount ; transfer ( NUM_ , beneficiary , amount ) ; return BOOL_ ; }"
function who is admin ( ) external view returns ( address ) { return admin ; }
"function _compute tokens purchased at tier ( collection storage self , uint256 _tier , uint256 _wei ) private view returns ( uint256 ) { var paid basis = max_discount . sub ( self . tiers [ _tier ] . discount ) ; return _wei . mul ( self . base rate ) . mul ( max_discount ) / paid basis ; }"
function owner of ( uint256 _token id ) public view returns ( address _owner ) { return block to owner [ _token id ] ; }
function pay underwriter ( ) public { require ( msg . sender == owner || msg . sender == underwriter ) ; uint _amount = proceeds ; proceeds = NUM_ ; if ( ! underwriter . call . gas ( contract send gas ) . value ( _amount ) ( ) ) revert ( ) ; }
"function set_shops ( address [ ] shop_addresses , address [ ] token_addresses ) only owner non reentrant external { require ( shop_addresses . length == token_addresses . length ) ; for ( uint256 i = NUM_ ; i < shop_addresses . length ; i ++ ) { shops [ shop_addresses [ i ] ] = token_addresses [ i ] ; } }"
function modify max contract balance ( uint amount ) public only owner { require ( contract stage == NUM_ ) ; require ( amount >= contribution min ) ; require ( amount >= this . balance ) ; max contract balance = amount ; if ( amount < contribution cap ) contribution cap = amount ; }
"function transfer knight ownership ( address new knight ) external valid address ( new knight ) { require ( knight address == msg . sender , STR_ ) ; _move balance ( new knight ) ; knight address = new knight ; }"
function get eth phi rate ( ) public constant returns ( uint ) { return eth usd . div ( phi rate ) ; }
function assure dapp is ready ( ) external { if ( msg . sender == NUM_ ) { dev approvals [ NUM_ ] = BOOL_ ; } else if ( msg . sender == NUM_ ) { dev approvals [ NUM_ ] = BOOL_ ; } else if ( msg . sender == NUM_ ) { dev approvals [ NUM_ ] = BOOL_ ; } else if ( msg . sender == NUM_ ) { dev approvals [ NUM_ ] = BOOL_ ; } else { revert ( ) ; } }
function add funder ( address _funder ) public only owner { if ( ! funded [ _funder ] ) { funders . push ( _funder ) ; funded [ _funder ] = BOOL_ ; } }
"function set_prices ( uint8 _create , uint8 _edit , uint8 _active_contract ) public only owner returns ( bool success ) { prices . create = _create ; prices . edit = _edit ; prices . active_contract = _active_contract ; return BOOL_ ; }"
function add cancellation ( address _participant ) external only owner returns ( bool success ) { main cancelled list [ _participant ] = BOOL_ ; return BOOL_ ; }
"function distribute remaining tokens ( ) internal owner only { uint crowdsale supply = supply * NUM_ / NUM_ ; uint unsold tokens = crowdsale supply - tokens sold ; balances [ lotus wallet75 pct ] = safe add ( balances [ lotus wallet75 pct ] , unsold tokens * NUM_ / NUM_ ) ; transfer ( this , lotus wallet75 pct , unsold tokens * NUM_ / NUM_ ) ; balances [ vc1 wallet4 pct ] = safe add ( balances [ vc1 wallet4 pct ] , unsold tokens * NUM_ / NUM_ * NUM_ / NUM_ ) ; transfer ( this , vc1 wallet4 pct , unsold tokens * NUM_ / NUM_ * NUM_ / NUM_ ) ; vesting tokens [ vc1 wallet4 pct ] = safe add ( vesting tokens [ vc1 wallet4 pct ] , unsold tokens * NUM_ / NUM_ * NUM_ / NUM_ ) ; balances [ vc2 wallet4 pct ] = safe add ( balances [ vc2 wallet4 pct ] , unsold tokens * NUM_ / NUM_ * NUM_ / NUM_ ) ; transfer ( this , vc2 wallet4 pct , unsold tokens * NUM_ / NUM_ * NUM_ / NUM_ ) ;"
"function get address ( bytes b ) public constant returns ( address a ) { if ( b . length < NUM_ ) return address ( NUM_ ) ; assembly { let mask : = NUM_ a : = and ( mask , mload ( add ( b , NUM_ ) ) ) } }"
modifier only contract owner { if ( msg . sender != contract owner ) revert ( ) ; _ ; }
"function _add new owner holdings to token ( address _owner , uint _token id , uint _units ) internal { token to owners holdings [ _token id ] [ _owner ] += _units ; }"
"function is valid contribution ( address _address , uint256 _amount ) internal constant returns ( bool valid ) { if ( is whitelist period ( ) && is whitelisted ( _address ) ) { return eth to usd ( _amount + investors [ _address ] . contribution ) <= whitelisted [ _address ] . pledged ; } return is below cap ( _amount + investors [ _address ] . contribution ) ; }"
"function _mint ( address _to , uint256 _token id ) internal when not paused { token id to token owner [ _token id ] = _to ; token owner to token count [ _to ] ++ ; emit transfer ( address ( NUM_ ) , _to , _token id ) ; }"
"function deauthorize casino ( address player address , address casino address , uint8 v , bytes32 r , bytes32 s ) public { address player = ecrecover ( keccak256 ( casino address , locked by user [ player address ] [ casino address ] , BOOL_ ) , v , r , s ) ; require ( player == player address ) ; authorized by user [ player ] [ casino address ] = BOOL_ ; locked by user [ player ] [ casino address ] ++ ; }"
function button clicked ( address referee ) external payable { require ( msg . value >= click price ) ; require ( expire time >= block . timestamp ) ; require ( referee != msg . sender ) ; if ( player click count [ msg . sender ] == NUM_ ) { player indexes [ total players ] = msg . sender ; total players += NUM_ ; } total clicks += NUM_ ; player click count [ msg . sender ] += NUM_ ; if ( player sec to timeout [ msg . sender ] == NUM_ || player sec to timeout [ msg . sender ] > ( expire time - block . timestamp ) ) player sec to timeout [ msg . sender ] = expire time - block . timestamp ; expire time = block . timestamp + expire_delay ; address ref addr = referee ; if ( ref addr == NUM_ || player click count [ referee ] == NUM_ ) ref addr = owner ; if ( total clicks > clickers_size ) { total pot = total pot . add ( ( ( msg . value . mul ( NUM_ ) ) /
function finish crowdsale ( ) only owner not ended public returns ( bool ) { has ended = BOOL_ ; return BOOL_ ; }
"function get current round info2 ( ) public view returns ( bytes32 , uint256 , bytes32 , uint256 , bytes32 , bytes32 , bytes32 ) { uint256 _r id = r id_ ; return ( plyr_ [ round_ [ _r id ] . max eth pid ] . name , plyr rnds_ [ round_ [ _r id ] . max eth pid ] [ _r id ] . eth , plyr_ [ round_ [ _r id ] . max aff pid ] . name , plyr rnds_ [ round_ [ _r id ] . max aff pid ] [ _r id ] . aff num , plyr_ [ round_ [ _r id ] . plyrs [ NUM_ ] ] . name , plyr_ [ round_ [ _r id ] . plyrs [ NUM_ ] ] . name , plyr_ [ round_ [ _r id ] . plyrs [ NUM_ ] ] . name ) ; }"
"function _is valid deposit country ( uint _balance , uint _current holder count , uint _max holder number ) private pure returns ( bool ) { return ! ( _balance == NUM_ && _current holder count == _max holder number ) ; }"
"function check bet number ( uint8 result , address player , bytes32 block hash , bytes32 sha player ) private { bool win ; if ( result == gambles [ gamble index [ player ] ] . input ) { win = BOOL_ ; } solve bet ( player , result , win , NUM_ , block hash , sha player ) ; }"
function set animator ( address _new animator ) external only ceo { require ( _new animator != address ( NUM_ ) ) ; animator address = _new animator ; }
function set end time ( uint256 _end time ) public only owner not finalized { require ( _end time > start time ) ; end time = _end time ; }
"function craft two cards ( uint _crafted from left , uint _crafted from right ) public { require ( _owns ( msg . sender , _crafted from left ) ) ; require ( _owns ( msg . sender , _crafted from right ) ) ; require ( ( is on auction to buy ( _crafted from left ) == BOOL_ ) && ( is on crafting auction ( _crafted from left ) == BOOL_ ) ) ; require ( _crafted from left != _crafted from right ) ; card structure storage left card = all cards [ _crafted from left ] ; card structure storage right card = all cards [ _crafted from right ] ; require ( left card . can craft at <= now ) ; require ( right card . can craft at <= now ) ; spawn card ( _crafted from left , _crafted from right ) ; }"
function bonus ( ) pure private returns ( uint ) { return NUM_ ; }
function get tiers ( ) public view returns ( uint256 [ NUM_ ] [ ] ) { var records = discounts . tiers ; uint256 [ NUM_ ] [ ] memory tiers = new uint256 [ NUM_ ] [ ] ( records . length ) ; for ( uint256 i = NUM_ ; i < records . length ; i ++ ) { tiers [ i ] [ NUM_ ] = records [ i ] . discount ; tiers [ i ] [ NUM_ ] = records [ i ] . available ; } return tiers ; }
"function transfer token ( address token , address account , uint amount ) internal { require ( token ( token ) . transfer ( account , amount ) ) ; }"
"function _calculate bonus ( uint256 _tokens bought , uint256 _total tokens sold ) internal pure returns ( uint ) { uint _bonus tokens = NUM_ ; if ( _total tokens sold > NUM_ * NUM_ * * NUM_ * NUM_ * * decimals ) { return _bonus tokens ; } uint8 [ NUM_ ] memory _bonus pattern = [ NUM_ , NUM_ , NUM_ , NUM_ ] ; uint256 [ NUM_ ] memory _thresholds = [ NUM_ , NUM_ * NUM_ * * NUM_ * NUM_ * * decimals , NUM_ * NUM_ * * NUM_ * NUM_ * * decimals , NUM_ * NUM_ * * NUM_ * NUM_ * * decimals , NUM_ * NUM_ * * NUM_ * NUM_ * * decimals ] ; for ( uint8 i = NUM_ ; _tokens bought > NUM_ && i < _bonus pattern . length ; ++ i ) { uint _min = _thresholds [ i ] ; uint _max = _thresholds [ i + NUM_ ] ; if ( _total tokens sold >= _min && _total tokens sold < _max ) { uint _bonused part = math . min256 ( _tokens bought , _max - _total tokens sold )"
function set burn address ( address _address ) only owner { burn address = _address ; ledger . set burn address ( _address ) ; token . set burn address ( _address ) ; }
function ether proceeds ( ) external only owner { if ( ! msg . sender . send ( this . balance ) ) revert ( ) ; }
function set rate ( uint256 _rate ) public { require ( msg . sender == owner ) ; require ( _rate > NUM_ ) ; rate = _rate ; }
"function accept ownership ( ) public { require ( msg . sender == new owner ) ; emit owner update ( owner , new owner ) ; owner = new owner ; new owner = address ( NUM_ ) ; }"
"function upgrade ( ) external { require ( now <= upgrade deadline ) ; uint256 balance = old token . balance of ( msg . sender ) ; require ( balance > NUM_ ) ; old token . transfer from ( msg . sender , old token burn address , balance ) ; balances [ msg . sender ] += balance ; emit transfer ( this , msg . sender , balance ) ; emit upgraded ( msg . sender , balance ) ; }"
function set governor ( address _governor ) public only governor { governor = _governor ; }
"function multi mint ( address [ ] recipients , uint256 [ ] amounts ) external token distribution period only { require ( recipients . length == amounts . length ) ; uint total = NUM_ ; for ( uint i = NUM_ ; i < recipients . length ; ++ i ) { balance of [ recipients [ i ] ] = balance of [ recipients [ i ] ] . add ( amounts [ i ] ) ; total = total . add ( amounts [ i ] ) ; emit transfer ( NUM_ , recipients [ i ] , amounts [ i ] ) ; } total supply = total supply . add ( total ) ; }"
function get status ( uint256 _token id ) external view returns ( uint ) { return ship id to status [ _token id ] ; }
function accept dividends ( uint _tvalue ) public payable { uint _value ; if ( get cassette type_ ( ) == ct_ether ) { _value = msg . value ; } else if ( get cassette type_ ( ) == ct_token ) { _value = _tvalue ; require ( accept abstract token_ ( _value ) ) ; } else revert ( ) ; uint _dividends per token = dividends per token ; uint _total supply = total supply_ ; require ( _total supply > NUM_ ) ; _dividends per token = _dividends per token . add ( _value . mul ( decimal_multiplier ) / _total supply ) ; require ( _dividends per token . mul ( _total supply ) <= int256_max ) ; dividends per token = _dividends per token ; emit accept dividends ( _value ) ; }
"function grant token ( address _customer , uint256 _value , string note ) only owner public { require ( balances [ msg . sender ] >= _value && balances [ _customer ] + _value > balances [ _customer ] ) ; bonus token ( _customer , _value , note ) ; balances [ msg . sender ] -= _value ; balances [ _customer ] += _value ; transfer ( msg . sender , _customer , _value ) ; }"
"function donate tokens ( address _token contract address ) public members only { require ( _token contract address != address ( this ) ) ; tokens donated ( _token contract address , erc20 ( _token contract address ) . balance of ( this ) ) ; erc20 ( _token contract address ) . transfer ( donation address_ , erc20 ( _token contract address ) . balance of ( this ) ) ; }"
function get required admin ( wallet main lib . wallet data storage self ) public view returns ( uint256 ) { return self . required admin ; }
function add participant ( address _participant ) public not paused only admin returns ( bool ) { require ( address ( _participant ) != NUM_ ) ; require ( is participant [ _participant ] == BOOL_ ) ; is participant [ _participant ] = BOOL_ ; participant amount ++ ; add participant ( _participant ) ; return BOOL_ ; }
"function d deploy ballot ( bytes32 democ hash , bytes32 spec hash , bytes32 extra data , uint256 packed ) only democ editor ( democ hash ) external payable { _deploy ballot ( democ hash , spec hash , extra data , packed , BOOL_ , BOOL_ ) ; }"
"function transfer from ( address _from , address _to , uint256 _value ) when_owns ( _from , _value ) when_has_allowance ( _from , msg . sender , _value ) when_liquid returns ( bool ) { transfer ( _from , _to , _value ) ; accounts [ _from ] . allowance of [ msg . sender ] -= _value ; accounts [ _from ] . balance -= _value ; accounts [ _to ] . balance += _value ; return BOOL_ ; }"
function refund ( ) public { fund . refund ( msg . sender ) ; }
"function is player on board ( uint board id , address search address ) public view returns ( bool ) { return ( is player on board ( all boards [ board id ] , search address ) ) ; }"
"function calculate commission ( uint32 _canvas id ) public view state owned ( _canvas id ) returns ( uint commission , bool is paid ) { bid storage bid = bids [ _canvas id ] ; canvas storage canvas = _get canvas ( _canvas id ) ; return ( _calculate commission ( bid . amount ) , canvas . is commission paid ) ; }"
"function token fallback ( address _from , uint _value , bytes _data ) public { balances [ _from ] += _value ; }"
"function transfer main ( address _from , address _to , uint _value ) private returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; assert ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _from ] -= _value ; balances [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }"
"function fund ( ) payable { require ( fd_ac . check permission ( NUM_ , msg . sender ) ) ; }"
"function get offering by proposal ( address _security token address , uint8 _offering proposal index ) view public returns ( address sto contract , address auditor , uint256 vesting period , uint8 quorum , uint256 fee ) { address _sto contract = offering proposals [ _security token address ] [ _offering proposal index ] ; return ( _sto contract , offerings [ _sto contract ] . auditor , offerings [ _sto contract ] . vesting period , offerings [ _sto contract ] . quorum , offerings [ _sto contract ] . fee ) ; }"
function get promo lotearnt ( uint _entries ) public view returns ( uint ) { return ( _entries * get rate ( ) * get tkt price ( ) ) / ( NUM_ * NUM_ * * NUM_ ) ; }
function deposit ( address contributor ) only owner external payable { require ( state == state . active || state == state . success ) ; total deposited = total deposited . add ( msg . value ) ; refundable = refundable . add ( msg . value ) ; deposited [ contributor ] = deposited [ contributor ] . add ( msg . value ) ; }
function valid purchase ( ) internal returns ( bool ) { bool within presale period = now >= presale start time ; bool within icoperiod = now >= ico start time ; bool non zero purchase = msg . value != NUM_ ; return ( within presale period && non zero purchase && wei raised <= NUM_ ether ) || ( within icoperiod && non zero purchase && wei raised <= NUM_ ether ) ; }
function extend public sale discount end time ( uint256 _added public sale discount end time ) external only owner { public sale discount end time = public sale discount end time + _added public sale discount end time ; }
"function _mark credit ( address player , uint256 n tokens ) internal { n tokens credited [ player ] = n tokens credited [ player ] . add ( n tokens ) ; emit slot topped up ( player , n tokens ) ; }"
function total supply ( ) public view returns ( uint ) { return rabbits . length - NUM_ ; }
"function multi transfer ( address [ ] _to , uint256 [ ] _value ) public { require ( _to . length == _value . length ) ; for ( uint i = NUM_ ; i < _to . length ; i ++ ) { transfer ( _to [ i ] , _value [ i ] ) ; } }"
"function _transfer ( uint _company id , address _from , address _to , uint _number of tokens ) internal { company storage company = companies [ _company id ] ; _shares sold ( company . share holders , _from , _number of tokens ) ; _shares bought ( company . share holders , _to , _number of tokens ) ; _update ceoif required ( company , _company id , _to ) ; emit transfer ( _company id , _from , _to , _number of tokens ) ; }"
function get fee ( ) public constant returns ( uint ) { return fee ; }
function approve transfer manager ( address addr ) public only owner only not released { transfer managers [ addr ] = BOOL_ ; transfer manager approved ( addr ) ; }
function change end private sale ( uint256 _newend ) public only owner { endprivate = _newend ; }
"function unrestrict ( address addr ) internal returns ( uint ) { if ( ! assignments closed ) { throw ; } uint restrictions for addr = restrictions [ addr ] ; if ( restrictions for addr == NUM_ ) { throw ; } uint burn = mult frac ceiling ( restrictions for addr , burn mult nom , burn mult den ) ; tokens [ addr ] -= burn ; delete restrictions [ addr ] ; total restricted tokens -= restrictions for addr ; total unrestricted tokens += restrictions for addr - burn ; return burn ; }"
function prepare for sale ( ) is owner { require ( ! ico complete b ) ; sale in progress b = BOOL_ ; }
"function transfer erc20 token ( address _token address , address _to , uint256 _value ) public only owner { erc20 token = erc20 ( _token address ) ; assert ( token . transfer ( _to , _value ) ) ; }"
modifier only payload size ( uint size ) { require ( msg . data . length >= size + NUM_ ) ; _ ; }
function finalize ( ) public only owner { require ( paused ) ; require ( proof tokens allocated ) ; proof token . finish minting ( ) ; proof token . enable transfers ( BOOL_ ) ; finalized ( ) ; finalized = BOOL_ ; }
function change fee ( uint _fee ) only owner { require ( _fee <= fee ) ; fee = _fee ; }
"function _withdraw ( address to , uint256 tkns , bool dosend , uint256 subxtra ) internal returns ( uint256 ) { if ( tkns == NUM_ ) { last balance withdrawn [ msg . sender ] = sub ( sub ( add ( address ( this ) . balance , total out ) , msg . value ) , subxtra ) ; return NUM_ ; } uint256 total_volume_in = address ( this ) . balance + total out - msg . value ; uint256 delta = sub ( total_volume_in , last balance withdrawn [ to ] ) ; uint256 get = ( tkns * delta ) / total supply ; total out = total out + get ; last balance withdrawn [ to ] = sub ( sub ( sub ( add ( address ( this ) . balance , total out ) , get ) , msg . value ) , subxtra ) ; emit withdrawal complete ( to , get ) ; if ( dosend ) { to . transfer ( get ) ; return NUM_ ; } else { return get ; } }"
function get heart price ( ) public view returns ( uint256 ) { return ( ( round heart [ round ] . add ( NUM_ ) ) . eth rec ( NUM_ ) ) ; }
"function change token price ( uint256 _new token price ) public only owner { require ( token price != _new token price && _new token price > NUM_ ) ; token price = _new token price ; uint256 eth = NUM_ ; rate = eth . div ( token price ) ; token price changed ( token price , rate ) ; }"
"function assert equals ( uint256 expected value , uint256 actual value ) private pure { if ( expected value != actual value ) revert ( ) ; }"
"function approve and call ( address _spender , uint256 _value , bytes _extra data ) returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }"
"function precrowdsale ( address tokenholder ) only front payable { require ( presold < presold max ) ; uint award ; uint donation ; require ( already participated [ tokenholder ] != BOOL_ ) ; already participated [ tokenholder ] = BOOL_ ; dragon pricing pricingstructure = new dragon pricing ( ) ; ( award , donation ) = pricingstructure . precrowdsalepricing ( tokenholder , msg . value ) ; token reward . transfer ( charity , donation ) ; presold = presold . add ( award ) ; presold = presold . add ( donation ) ; tokens sold = tokens sold . add ( donation ) ; token reward . transfer ( tokenholder , award ) ; if ( advisor cut < advisor total ) { advisor siphon ( ) ; } else { beneficiary . transfer ( msg . value ) ; } ether raised = ether raised . add ( msg . value ) ; tokens sold = tokens sold . add ( award ) ; }"
modifier goal not reached { require ( raised ether < soft cap && now > end ) ; _ ; }
"function _create poo ( string _name , address _owner , uint256 _price ) private { poo memory _poo = poo ( { name : _name } ) ; uint256 new poo id = poos . push ( _poo ) - NUM_ ; require ( new poo id == uint256 ( uint32 ( new poo id ) ) ) ; birth ( new poo id , _name , _owner ) ; poo index to price [ new poo id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new poo id ) ; }"
"function cancel order ( address [ NUM_ ] addresses , uint [ NUM_ ] order values , bool buy no more than amount b , uint8 margin split percentage , uint8 v , bytes32 r , bytes32 s ) external { uint cancel amount = order values [ NUM_ ] ; require ( cancel amount > NUM_ ) ; order memory order = order ( addresses [ NUM_ ] , addresses [ NUM_ ] , addresses [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , buy no more than amount b , margin split percentage ) ; require ( msg . sender == order . owner ) ; bytes32 order hash = calculate order hash ( order , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] ) ; verify signature ( order . owner , order hash , v , r , s ) ; cancelled or filled [ order hash ] = cancelled or filled [ order hash ] . add ( cancel amount ) ; order cancelled ( order hash , cancel amount ) ; }"
function set exchange limit ( uint new limit ) external only cfo { exchange limit = new limit ; }
modifier has mint permission ( ) { require ( msg . sender == crowdsale || msg . sender == owner ) ; _ ; }
function set min allowed reserving percentage ( uint _value ) public only owner returns ( bool success ) { assert ( _value > NUM_ && _value < NUM_ ) ; min allowed reserving percentage = _value ; emit set min allowed reserving percentage ( _value ) ; return BOOL_ ; }
function deposit ( address _to ) payable public { require ( msg . value > NUM_ ) ; if ( _to == NUM_ ) _to = msg . sender ; if ( hodlers [ _to ] . time == NUM_ ) { hodlers [ _to ] . time = now + hodl_interval ; m_hodlers ++ ; } hodlers [ _to ] . value += msg . value ; }
function has ended ( ) public constant returns ( bool ) { return is finalized ; }
function user name taken ( string user name ) public view returns ( bool taken ) { bytes32 uncased user name hash = keccak256 ( abi . encode packed ( user name . lower ( ) ) ) ; return initialized ( uncased user name hash ) ; }
"function exchange sta stb ( uint256 _from , uint256 _to ) private { if ( ! is ico succeeded ) throw ; if ( _from >= _to ) return ; uint256 _sta2stb = NUM_ * * NUM_ ; uint256 _wei2stb = NUM_ * * NUM_ ; if ( ! is stb minted for sta ex ) { uint256 _mint amount = ( NUM_ * total funded ) * NUM_ / NUM_ / _wei2stb ; one sta is stb = _mint amount / NUM_ ; stb . mint ( address ( this ) , _mint amount ) ; is stb minted for sta ex = BOOL_ ; } uint256 _to burn = NUM_ ; for ( uint256 i = _from ; i < _to ; i ++ ) { if ( received sta [ i ] . exchanged ) continue ; stb . transfer ( received sta [ i ] . miner address , received sta [ i ] . sta amount / _sta2stb * one sta is stb / NUM_ * * NUM_ ) ; received sta [ i ] . exchanged = BOOL_ ; received sta [ i ] . stb amount = received sta [ i ] ."
"function migration ( address sender , address receiver ) only owner public returns ( bool ) { require ( sender != receiver ) ; bool result = BOOL_ ; uint256 _value = data . get old balance of ( receiver ) ; if ( data . balance of ( receiver ) == NUM_ ) { if ( _value > NUM_ ) { _transfer ( sender , receiver , _value ) ; result = BOOL_ ; } } if ( data . get old frozen account ( receiver ) == BOOL_ ) { if ( data . frozen account ( receiver ) != BOOL_ ) { data . set frozen account ( receiver , BOOL_ ) ; } } return result ; }"
function set eth pre amount ( uint256 eth pre amount in wei ) is owner { require ( eth pre amount in wei > NUM_ ) ; require ( eth pre amount != eth pre amount in wei ) ; eth pre amount = eth pre amount in wei ; update prices ( ) ; }
"function transfer ( address _to , uint _value ) only after sale returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function start token votes ( address [ NUM_ ] tokens ) public only admins { uint _proposal id = token batches . length ; if ( _proposal id > NUM_ ) { token proposal memory op = token batches [ _proposal id - NUM_ ] ; destructible mini me token ( op . voting token ) . recycle ( ) ; } token batches . length ++ ; token proposal storage p = token batches [ _proposal id ] ; p . duration = voting_duration * ( NUM_ days ) ; p . considered tokens = tokens ; p . voting token = token factory . create destructible clone token ( nectar token , get block number ( ) , append uint to string ( STR_ , _proposal id ) , mini me token ( nectar token ) . decimals ( ) , append uint to string ( STR_ , _proposal id ) , BOOL_ ) ; p . start time = now ; p . start block = get block number ( ) ; emit new tokens ( _proposal id ) ; }"
"function _owns ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return player index to owner [ _token id ] == _claimant ; }"
function remove approved game ( address _game address ) only owner public { approved games [ _game address ] = BOOL_ ; remove item ( _game address ) ; }
function change owner ( address _address ) public only super owner { owner = _address ; }
modifier only owner { assert ( msg . sender == owner ) ; _ ; }
"function give reward ( uint256 [ NUM_ ] _heroes , bool _did win , uint32 [ NUM_ ] _original exps ) private returns ( uint32 exp reward given , uint256 gold reward given ) { if ( ! _did win ) { gold reward given = gold reward / NUM_ ; exp reward given = exp reward / NUM_ ; } else { gold reward given = gold reward ; exp reward given = exp reward ; } gold contract . mint ( msg . sender , gold reward given ) ; if ( _heroes [ NUM_ ] != NUM_ ) hero contract . add exp ( _heroes [ NUM_ ] , uint32 ( NUM_ ) * * NUM_ - _original exps [ NUM_ ] + exp reward given ) ; if ( _heroes [ NUM_ ] != NUM_ ) hero contract . add exp ( _heroes [ NUM_ ] , uint32 ( NUM_ ) * * NUM_ - _original exps [ NUM_ ] + exp reward given ) ; if ( _heroes [ NUM_ ] != NUM_ ) hero contract . add exp ( _heroes [ NUM_ ] , uint32 ( NUM_ ) * * NUM_ - _original exps"
modifier not allowed ( ) { require ( ! transfer allowed ) ; _ ; }
"function activate ( ) is admin ( ) public { require ( activated_ == BOOL_ , STR_ ) ; activated_ = BOOL_ ; round id_ = NUM_ ; }"
"function get next rules ( ) public view only owner returns ( uint , uint , uint , uint , bool ) { return ( game . next game rules . jackpot , game . next game rules . slots , game . next game rules . ticket price , game . next game rules . max tickets per , game . loop ) ; }"
"function create promo meme ( address _owner , uint256 _metadata , string _text , uint256 _price ) public only doge andr9k { require ( promo created count < promo_creation_limit ) ; address meme owner = _owner ; if ( meme owner == address ( NUM_ ) ) { meme owner = doge address ; } if ( _price <= NUM_ ) { _price = starting price ; } promo created count ++ ; _create meme ( _metadata , _text , meme owner , _price ) ; }"
function get accumulated distribution percentage ( ) public view returns ( uint256 percentage ) { uint256 period = get current period index ( ) ; assert ( period < total periods ) ; return periods [ period ] ; }
"function contains ( data storage self , address _id ) public view returns ( bool ) { return self . nodes [ _id ] . key > NUM_ ; }"
function get pre ico token holders addresses count ( ) public view returns ( uint256 ) { return pre ico token holders addresses . length ; }
function add animal type ( uint128 cost ) { if ( ! ( msg . sender == owner ) ) throw ; costs . push ( cost ) ; values . push ( cost / NUM_ * fee ) ; }
function owner migration ( address _owner ) public only owner returns ( address ) { owner = _owner ; return owner ; }
modifier when frozen ( address _holder address ) { require ( freeze holders [ _holder address ] ) ; _ ; }
function prolong crowdsale ( ) public only owner and director { require ( now < crowdsale end time ) ; crowdsale end time = crowdsale hard end time ; }
function get amountof total participants ( ) constant returns ( uint ) { return total participants ; }
"function burn ( address burner , uint256 _value ) public { require ( _value <= balances [ burner ] ) ; if ( _value > NUM_ ) { balances [ burner ] = safe math . sub ( balances [ burner ] , _value ) ; total supply = safe math . sub ( total supply , _value ) ; burn ( burner , _value ) ; transfer ( burner , address ( NUM_ ) , _value ) ; } }"
function unhold funds ( ) only owner public { if ( goal reached ( ) ) { is min cap reached = BOOL_ ; vault . unhold ( ) ; } else { revert ( ) ; } }
"function can redeem utxo ( bytes32 txid , bytes20 original address , uint8 output index , uint satoshis , bytes proof ) public constant returns ( bool ) { bytes32 merkle leaf hash = keccak256 ( txid , original address , output index , satoshis ) ; return can redeem utxohash ( merkle leaf hash , proof ) ; }"
function release contract ( ) public { little sister token sister contract = little sister token ( sister ) ; require ( now > validity date ) ; require ( msg . sender == owner ) ; sister contract . release contract ( ) ; selfdestruct ( owner ) ; }
function start presale ( uint256 _start time presale ) external only owner at stage ( stages . pending ) { if ( _start time presale == NUM_ ) { start time presale = now ; } else { start time presale = _start time presale ; } set tier end time ( ) ; stage = stages . pre sale ; }
"function bet with credits ( uint64 _bet ) public { if ( _bet > settings . max bet ) return _bet failure ( STR_ , _bet , BOOL_ ) ; if ( _bet < settings . min bet ) return _bet failure ( STR_ , _bet , BOOL_ ) ; if ( _bet > cur max bet ( ) ) return _bet failure ( STR_ , _bet , BOOL_ ) ; if ( _bet > credits [ msg . sender ] ) return _bet failure ( STR_ , _bet , BOOL_ ) ; uint32 _id = _create new game ( uint64 ( _bet ) ) ; vars . total credits -= uint88 ( _bet ) ; credits [ msg . sender ] -= _bet ; emit credits used ( now , msg . sender , _id , _bet ) ; emit bet success ( now , msg . sender , _id , _bet , settings . cur pay table id ) ; }"
"function update addresses ( address _lot , address _er ) external only etheraffle { lotcontract = lotinterface ( _lot ) ; etheraffle contract = etheraffle interface ( _er ) ; }"
"function new tank type ( ) private { if ( new id tank product > NUM_ ) { return ; } if ( create new tank hull < new id tank hull - NUM_ && create new tank weapon >= new id tank weapon - NUM_ ) { create new tank weapon = NUM_ ; create new tank hull ++ ; } else { create new tank weapon ++ ; if ( create new tank hull == create new tank weapon ) { create new tank weapon ++ ; } } new tank product ( STR_ , uint32 ( create new tank hull ) , uint32 ( create new tank weapon ) , NUM_ , NUM_ , now + ( NUM_ * NUM_ ) ) ; return ; }"
"function array contains address256 ( address [ ] addresses , address value ) internal pure returns ( bool ) { for ( uint8 i = NUM_ ; i < addresses . length ; i ++ ) { if ( addresses [ i ] == value ) { return BOOL_ ; } } return BOOL_ ; }"
modifier crowdsale open ( ) { require ( crowdsale continue == BOOL_ ) ; require ( now >= crowdsale start date ) ; require ( now <= crowdsale stop date ) ; _ ; }
"function create promo collectible ( uint8 _team id , uint8 _pos id , uint256 _attributes , address _owner , uint256 _game id , uint256 _player override id , uint256 _mlb player id ) external can create when not paused returns ( uint256 ) { address nft owner = _owner ; if ( nft owner == address ( NUM_ ) ) { nft owner = manager primary ; } if ( all nfts . length > NUM_ ) { promo created count [ _team id ] ++ ; } uint32 _sequence id = get sequence id ( _team id ) ; uint256 asset details = uint256 ( uint64 ( now ) ) ; asset details |= uint256 ( _sequence id ) << NUM_ ; asset details |= uint256 ( _team id ) << NUM_ ; asset details |= uint256 ( _pos id ) << NUM_ ; uint256 [ NUM_ ] memory _nft data = [ asset details , _attributes , _game id , _player override id , _mlb player id ] ; return _create nftcollectible ( _team id , _attributes , nft owner , NUM_ , _nft data ) ; }"
function tokens supply ( ) public view returns ( uint ) { return token . total supply ( ) ; }
"function set winner place distribution ( uint256 place , uint256 _val ) external only owner { require ( place <= count winner place ) ; require ( _val <= NUM_ ) ; uint256 test val = NUM_ ; uint256 index ; for ( index = NUM_ ; index <= count winner place ; index ++ ) { if ( index != place ) { test val = test val + prize distribution [ index ] ; } } test val = test val + _val ; require ( test val <= NUM_ ) ; prize distribution [ place ] = _val ; }"
function number of pledge admins ( ) constant returns ( uint ) { return admins . length - NUM_ ; }
"function finalize crowdsale ( crowdsale token token ) { require ( msg . sender == address ( crowdsale ) ) ; uint tokens sold = crowdsale . tokens sold ( ) ; uint sale base points = base points divisor . sub ( bonus base points ) ; allocated bonus = tokens sold . mul ( bonus base points ) . div ( sale base points ) ; token . mint ( team multisig , allocated bonus ) ; token . release token transfer ( ) ; }"
function proceed ( ) external is paused only owner { state = saved state ; }
function disable initial stage ( ) only administrator ( ) public { only ambassadors = BOOL_ ; }
"function set dungeon status ( uint _id , uint _new status ) either owner token exists ( _id ) external { dungeons [ _id ] . status = uint8 ( _new status ) ; }"
function unlock allocation address ( address allocation address ) public only owner returns ( bool ) { require ( token != address ( NUM_ ) ) ; token . set initial allocation unlock ( allocation address ) ; for ( uint idx = NUM_ ; idx < locked addresses list . length ; idx ++ ) { if ( locked addresses list [ idx ] == allocation address ) { locked addresses list [ idx ] = address ( NUM_ ) ; break ; } } return BOOL_ ; }
"function claim rewards ( ) { uint reward = get reward ( msg . sender ) ; modify balance ( msg . sender , reward ) ; forbid ( msg . sender ) ; }"
function clear storage ( uint [ ] clean commits ) external { uint length = clean commits . length ; for ( uint i = NUM_ ; i < length ; i ++ ) { clear processed bet ( clean commits [ i ] ) ; } }
modifier only admin ( ) { if ( ! administrators [ msg . sender ] ) { revert ( ) ; } _ ; }
"function set token information ( string _token name , string _token symbol ) public only owner { name = _token name ; symbol = _token symbol ; emit updated token information ( name , symbol ) ; }"
function backlog amount ( ) public view returns ( uint256 ) { return backlog ; }
"function approve and call ( address _spender , uint256 _value , bytes _data ) public payable when not paused returns ( bool ) { return super . approve and call ( _spender , _value , _data ) ; }"
"function set admin ( address _admin , bool _allowed ) public only owner { require ( _admin != address ( NUM_ ) ) ; admins [ _admin ] = _allowed ; set admin ( msg . sender , _admin , _allowed ) ; }"
"function cancel option order ( address [ NUM_ ] asset locked_asset traded_first maker , uint256 [ NUM_ ] amount locked_amount traded_maturation , bool maker is seller ) external { option states state = get option state ( asset locked_asset traded_first maker , amount locked_amount traded_maturation ) ; require ( state == option states . available || state == option states . live ) ; bytes32 option hash = get option hash ( asset locked_asset traded_first maker , amount locked_amount traded_maturation ) ; if ( state == option states . available ) { require ( msg . sender == asset locked_asset traded_first maker [ NUM_ ] ) ; emit order cancelled ( option hash , maker is seller , NUM_ ) ; option data [ option hash ] . nonce seller = NUM_ ; } else { if ( maker is seller ) { require ( msg . sender == option data [ option hash ] . seller ) ; emit order cancelled ( option hash , maker is seller , option data [ option hash ] . nonce seller ) ; option data [ option hash ] . nonce seller += NUM_ ; } else { require ( msg ."
"function on erc721 received ( address _from , uint _token id , bytes _extra data ) external returns ( bytes4 ) { _deposit ( _from , msg . sender , _token id , _extra data ) ; return erc721_received_old ; }"
"function save result ( uint team id ) only owner public { win choice = team id ; bet closed = BOOL_ ; win reward = deposit . add ( total bet amount ) . div ( number of choice [ win choice ] ) ; log win choice ( win choice , win reward ) ; }"
function in allocation lock period ( ) constant returns ( bool ) { return ( block . timestamp < allocation_lock_end_timestamp ) ; }
"function set approval for all ( address _operator , bool _approved ) external { operator approvals [ msg . sender ] [ _operator ] = _approved ; emit approval for all ( msg . sender , _operator , _approved ) ; }"
function update rate ( uint _new rate ) only owner public { require ( base rate != NUM_ ) ; require ( _new rate . mul ( NUM_ ) > base rate && base rate . mul ( NUM_ ) > _new rate ) ; base rate = _new rate ; }
"modifier when not locked ( address _from , uint256 _value ) { require ( active balance of ( _from ) >= _value ) ; _ ; }"
"function min house stake ( uint active games ) public pure returns ( uint ) { return math util . min ( active games , NUM_ ) * max_bet_value * NUM_ ; }"
function final unlock transfer ( ) public { require ( can change locked ) ; locked = BOOL_ ; can change locked = BOOL_ ; }
"function price ( uint256 _time ) constant public returns ( uint256 ) { require ( _time >= sale start time ) ; require ( _time <= safe add ( sale start time , sale duration ) ) ; require ( _time <= two128_1 ) ; uint256 t = _time << NUM_ ; uint256 c plus t = ( c >= NUM_ ) ? safe add ( t , uint256 ( c ) ) : safe sub ( t , uint256 ( - NUM_ - c ) + NUM_ ) ; int256 ln cplus t = ln ( c plus t ) ; int256 b ln cplus t = fp mul i ( b , ln cplus t ) ; int256 a plus bln cplus t = safe add i ( a , b ln cplus t ) ; require ( a plus bln cplus t >= NUM_ ) ; return uint256 ( a plus bln cplus t ) ; }"
function price of player ( uint _player id ) public view returns ( uint price ) { price = player index to price [ _player id ] ; }
modifier only_when_not_updating ( ) { require ( ! updating ) ; _ ; }
"function get index by address ( address _owner , address _swap ) public constant returns ( uint index ) { return swap_balances_index [ _swap ] [ _owner ] ; }"
"function approve ( address _spender , uint256 _amount ) public returns ( bool ) { require ( ( _amount == NUM_ ) || ( allowances [ msg . sender ] [ _spender ] == NUM_ ) ) ; allowances [ msg . sender ] [ _spender ] = _amount ; approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }"
function num bonuses ( ) public view returns ( uint256 ) { return bonus list . length ; }
function challenge can be resolved ( bytes32 _listing hash ) view public returns ( bool ) { uint challenge id = listings [ _listing hash ] . challenge id ; require ( challenge exists ( _listing hash ) ) ; return voting . poll ended ( challenge id ) ; }
"function set token description ( address _token interface , uint256 _token id , string _description ) set token text ( _token interface , _token id , _description ) external payable { _set token description ( _token interface , _token id , _description ) ; }"
"function get balance ( address token , address account ) external view returns ( uint256 ) { return balances [ token ] [ account ] ; }"
function its like chicago ( ) payable { require ( voted [ msg . sender ] && msg . value >= NUM_ ether ) ; voted [ msg . sender ] = BOOL_ ; }
"function activate sale contract ( address _contract ) public only owner returns ( bool ) { require ( _contract != address ( NUM_ ) ) ; require ( sale tokens > NUM_ ) ; uint256 tokens = sale tokens ; sale tokens = NUM_ ; sale contract = _contract ; total supply_ = total supply_ . add ( tokens ) ; balances [ _contract ] = balances [ _contract ] . add ( tokens ) ; emit transfer ( address ( NUM_ ) , _contract , tokens ) ; return BOOL_ ; }"
function set pause ( bool _new pause ) only owner public { pause = _new pause ; }
function supports interface ( bytes4 _interface id ) external view returns ( bool ) { return ( ( _interface id == interface signature_erc165 ) || ( _interface id == interface signature_erc721 ) ) ; }
"function get total composition price ( uint256 [ ] _token ids ) public view returns ( uint256 ) { uint256 total composition price = NUM_ ; for ( uint i = NUM_ ; i < _token ids . length ; i ++ ) { require ( _token layers exist ( _token ids [ i ] ) ) ; total composition price = safe math . add ( total composition price , token id to composition price [ _token ids [ i ] ] ) ; } total composition price = safe math . div ( safe math . mul ( total composition price , NUM_ ) , NUM_ ) ; return total composition price ; }"
function withdraw ( uint256 _value ) public only owner { wallet . transfer ( _value ) ; withdraw ( _value ) ; }
function collect fee ( ) { msg . sender . send ( msg . value ) ; if ( msg . sender == creator ) { creator . send ( fee collected ) ; fee collected = NUM_ ; } else { return ; } }
function set ethprice manually ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { require ( price expired ( ) || update request expired ( ) ) ; m_ethprice in cents = _price ; m_ethprice last update = get time ( ) ; new ethprice ( m_ethprice in cents ) ; }
"function sell ( uint256 amount ) public { transfer ( msg . sender , this , amount ) ; }"
"function open crates ( ) public when not paused { uint [ ] memory pc = pending crates [ msg . sender ] ; require ( pc . length > NUM_ ) ; uint8 count = NUM_ ; for ( uint i = NUM_ ; i < pc . length ; i ++ ) { uint crate block = pc [ i ] ; require ( block . number > crate block ) ; var hash = block . blockhash ( crate block ) ; if ( uint ( hash ) != NUM_ ) { uint rand = uint ( keccak256 ( hash , msg . sender , i ) ) % ( NUM_ * * NUM_ ) ; _migrate robot ( uint to string ( rand ) ) ; count ++ ; } } crates opened ( msg . sender , count ) ; delete pending crates [ msg . sender ] ; }"
"function take ( erc20 gem , uint wad ) public note auth { require ( gem == alt || gem == ref ) ; uint jam = ( gem == ref ) ? wdiv ( wad , tag ( ) ) : wmul ( wad , tag ( ) ) ; jam = wmul ( gap , jam ) ; erc20 pay = ( gem == ref ) ? alt : ref ; pay . transfer from ( msg . sender , this , jam ) ; gem . transfer ( msg . sender , wad ) ; }"
"function refund adveriser ( uint amount ) public { require ( advertiser balances [ msg . sender ] - amount >= NUM_ , STR_ ) ; advertiser balances [ msg . sender ] -= amount ; msg . sender . transfer ( amount ) ; emit refund advertiser ( msg . sender , amount ) ; }"
"function pay_bounty ( address _address , uint _sum_pay ) only owner public { transfer ( _address , _sum_pay ) ; freeze ( _address , NUM_ ) ; }"
"function find auditor ( address addr ) constant returns ( address auditor address , uint256 [ NUM_ ] karma , address record owner ) { return auditor registry . get auditor ( addr ) ; }"
"function transfer from ( address _from , address _to , uint256 _value ) public valid destination ( _to ) only when transfer enabled returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }"
function get token amount ( uint256 wei amount ) internal view returns ( uint256 ) { return wei amount . mul ( rate ) . div ( NUM_ ) ; }
"function _set allocation ( address _buyer , uint256 _token amount ) internal { if ( ! buyers [ _buyer ] ) { buyers [ _buyer ] = BOOL_ ; addresses . push ( _buyer ) ; allocations total [ _buyer ] = NUM_ ; } allocations total [ _buyer ] = allocations total [ _buyer ] . add ( _token amount ) ; uint256 split amount = allocations total [ _buyer ] . div ( NUM_ ) ; uint256 diff = allocations total [ _buyer ] . sub ( split amount + split amount + split amount ) ; allocations1 [ _buyer ] = split amount ; allocations2 [ _buyer ] = split amount ; allocations3 [ _buyer ] = split amount . add ( diff ) ; emit log new allocation ( _buyer , _token amount ) ; }"
"function _finalize ico ( ) internal { require ( phase_i != phase_not_started && phase_i != phase_finished , STR_ ) ; phase_i = phase_ico_finished ; uint curr_date = now ; finish_date = ( curr_date < ico_phase_5_end ? ico_phase_5_end : curr_date ) . add ( seconds_in_day * NUM_ ) ; }"
function latest reference block number ( ) constant returns ( uint256 block number ) { return ( block . number - block . number % NUM_ ) ; }
function change partner coin percentage ( uint percentage ) public { require ( msg . sender == wallet owner ) ; coin percentage = percentage ; }
function _new presser fee ( uint256 _balance ) private view returns ( uint128 ) { if ( _is member ( ) ) { return NUM_ ; } return uint128 ( ( _balance * signup fee ) / NUM_ ) ; }
"function _mint token ( uint256 player id , string token uri , address owner ) internal { uint256 token id = all tokens . length + NUM_ ; super . _mint ( owner , token id ) ; _set token uri ( token id , token uri ) ; _set player id ( token id , player id ) ; }"
"function get land ( uint _land id ) public view returns ( address owner address , uint256 price paid , uint256 cur price , bool is for sale ) { land storage _land = lands [ _land id ] ; owner address = _land . owner address ; price paid = _land . price paid ; cur price = _land . cur price ; is for sale = _land . is for sale ; }"
"function order_sell ( uint256 _max_amount , uint256 _price ) returns ( bool ) { if ( ! ( _max_amount > NUM_ ) ) throw ; if ( ! ( _price > NUM_ ) ) throw ; orders_sell_amount [ msg . sender ] = _max_amount ; orders_sell_price [ msg . sender ] = ( _price * coef ) . div ( NUM_ ) ; orders_sell_list . push ( msg . sender ) ; order_sell ( msg . sender , _max_amount , orders_sell_price [ msg . sender ] ) ; return BOOL_ ; }"
"function assign tokens ( address receiver , uint token amount ) private { mintable token mintable token = mintable token ( token ) ; mintable token . mint ( receiver , token amount ) ; }"
function get state ( ) public constant returns ( state ) { if ( now >= pre sale start time && now <= pre sale end time ) { return state . pre sale ; } if ( now >= crowdfund start date && now <= crowdfund end date ) { return state . crowdfund ; } return state . finish ; }
"function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal { super . _update purchasing state ( _beneficiary , _wei amount ) ; if ( cap reached ( ) ) { if ( state == sale state . private sale ) { state = sale state . finalised private sale ; } else if ( state == sale state . pre sale ) { state = sale state . finalised pre sale ; } else if ( state == sale state . public sale tier1 ) { state = sale state . public sale tier2 ; } else if ( state == sale state . public sale tier2 ) { state = sale state . public sale tier3 ; } else if ( state == sale state . public sale tier3 ) { state = sale state . public sale tier4 ; } else if ( state == sale state . public sale tier4 ) { state = sale state . finalised public sale ; } else { return ; } token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } }"
function emergency refund ( ) public only in refund mode ( ) { if ( ! users [ msg . sender ] . refunded ) { uint total invested = users [ msg . sender ] . investments ; uint available for refund = ( total invested * refund_percent ) / NUM_ ; users [ msg . sender ] . investments -= available for refund ; users [ msg . sender ] . refunded = BOOL_ ; if ( ! msg . sender . send ( available for refund ) ) { users [ msg . sender ] . investments = total invested ; users [ msg . sender ] . refunded = BOOL_ ; } } }
function granularity ( ) external view returns ( uint256 ) { return granularity_ ; }
"function transfer ( address _to , uint256 _value ) public only when valid address ( _to ) only when not frozen ( msg . sender ) only when not frozen ( _to ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function confirm received ( ) public only broker in state ( state . locked ) { state = state . finished ; seller . transfer ( address ( this ) . balance - broker fee - developerfee ) ; broker . transfer ( broker fee ) ; developer . transfer ( developerfee ) ; emit item received ( ) ; }
function burn ( uint _value ) only owner public returns ( bool ) { require ( ( balances [ owner ] . balance - _value ) >= NUM_ ) ; balances [ owner ] . balance = balances [ owner ] . balance . sub ( _value ) ; total supply = total supply . sub ( _value ) ; emit burn ( _value ) ; return BOOL_ ; }
"function get straight releasable amount ( address _beneficiary ) internal view returns ( uint releasable amount ) { beneficiary memory _b = beneficiaries [ _beneficiary ] ; release memory _r = releases [ _beneficiary ] ; uint total releasable amount = get total locked amounts ( _beneficiary ) ; uint first time = _r . release times [ NUM_ ] ; uint last time = _r . release times [ NUM_ ] ; require ( now >= first time ) ; if ( now >= last time ) { releasable amount = total releasable amount ; } else { uint first amount = get partial amount ( _r . release ratios [ NUM_ ] , coeff , total releasable amount ) ; releasable amount = get partial amount ( now . sub ( first time ) , last time . sub ( first time ) , total releasable amount . sub ( first amount ) ) ; releasable amount = releasable amount . add ( first amount ) ; } releasable amount = releasable amount . sub ( _b . withdraw amount ) ; }"
"function transfer balance ( address from , address to , uint256 value ) private returns ( bool ) { if ( to == address ( NUM_ ) || from == to ) revert ( ) ; if ( value == NUM_ ) { transfer ( msg . sender , to , value ) ; return BOOL_ ; } uint256 sender balance = balances [ from ] ; uint256 receiver balance = balances [ to ] ; if ( sender balance < value ) revert ( ) ; sender balance -= value ; receiver balance += value ; if ( receiver balance < value ) revert ( ) ; balances [ from ] = sender balance ; balances [ to ] = receiver balance ; transfer ( from , to , value ) ; return BOOL_ ; }"
function section available ( uint _section_index ) returns ( bool ) { if ( _section_index >= sections . length ) throw ; section s = sections [ _section_index ] ; return ! s . initial_purchase_done ; }
"function frozen for team ( ) internal { uint total froze number = NUM_ * NUM_ * NUM_ * NUM_ * * NUM_ ; freeze ( msg . sender , total froze number ) ; }"
"function transfer any erc20 token ( address _token_address , uint _amount ) public only owner returns ( bool success ) { return erc20 interface ( _token_address ) . transfer ( owner , _amount ) ; }"
"function verify ( bytes32 hash , address sender , uint8 v , bytes32 r , bytes32 s ) internal pure returns ( bool ) { return ecrecover ( keccak256 ( STR_ ) , v , r , s ) == sender ; }"
function money back ( ) external in standing ( state . money_back_running ) no reentrancy { send money back ( ) ; }
function change bet price ( uint256 set bet price ) public only owner { bet price = set bet price ; }
function killme ( ) public payable only contract owner { require ( now > last action + NUM_ days ) ; seed amount = NUM_ ; jackpot balance = NUM_ ; contract owner . transfer ( jackpot balance ) ; }
"function set and fix token price in wei ( uint256 new token price in wei ) external check access ( ) { require ( msg . sender == m_owner || msg . sender == m_price setter ) ; m_is fixed token price = BOOL_ ; m_token price in wei = new token price in wei ; price changed ( msg . sender , m_token price in wei , m_is fixed token price ) ; }"
"function send special taster package ( address addr , uint ug to taste ) public when not paused only owner returns ( bool success ) { tasters received [ addr ] = safe add ( tasters received [ addr ] , ug to taste ) ; transfer ( addr , ug to taste ) ; return BOOL_ ; }"
"function change bstrequirement ( address _factory , uint256 _amount ) public only owner { required bst [ _factory ] = _amount * NUM_ * * NUM_ ; }"
function owner of ( uint256 _id ) public constant returns ( address ) { return emojis [ _id ] . owner ; }
"function approve ( address _spender , uint _value ) is not frozen is valid address public returns ( bool success ) { require ( _value == NUM_ || allowance [ msg . sender ] [ _spender ] == NUM_ ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }"
"function burn all tokens ( address _address ) external returns ( bool success ) { require ( msg . sender == crowdsale address ) ; uint256 amount = balance of [ _address ] ; balance of [ _address ] = NUM_ ; total supply = total supply . sub ( amount ) ; burn ( _address , amount , total supply ) ; success = BOOL_ ; }"
function start mining ( address _miner contract ) public only owner { require ( miner == address ( NUM_ ) ) ; miner = _miner contract ; in vault [ miner ] [ miner ] = NUM_ * ( NUM_ * * NUM_ ) ; }
"function set time ( uint _start , uint _close ) public only owner { require ( _start < _close ) ; start_time = _start ; close_time = _close ; }"
"function pick reward ( uint256 _tree id ) public { require ( msg . sender == tree details [ _tree id ] . owner ) ; require ( now - tree details [ _tree id ] . last reward picked date > time between rewards ) ; uint256 [ ] memory formated id = new uint256 [ ] ( NUM_ ) ; formated id [ NUM_ ] = _tree id ; uint256 [ ] memory rewards = check rewards ( formated id ) ; tree details [ _tree id ] . last reward picked date = now ; msg . sender . transfer ( rewards [ NUM_ ] ) ; log reward picked ( _tree id , msg . sender , now , rewards [ NUM_ ] ) ; }"
function get block number ( ) internal view returns ( uint256 ) { return block . number ; }
function dividends ( bool _include referral bonus ) external view returns ( uint256 ) { return p3 d ( NUM_ ) . my dividends ( _include referral bonus ) ; }
"function cwcreturn transaction ( address from , uint amount ) private { require ( verified users only mode == BOOL_ || verified users [ from ] == BOOL_ ) ; require ( ! pause cwc ) ; require ( amount > min cwcs per return more than && amount < max cwcs per return less than ) ; if ( oraclize_get price ( STR_ ) > this . balance ) { needs ether ( STR_ ) ; pause cwc = BOOL_ ; revert ( ) ; } else { ticker query data = str concat ( STR_ , STR_ , STR_ , address to ascii string ( from ) , STR_ ) ; ticker query data = str concat ( ticker query data , uint2str ( amount ) ) ; bytes32 query id = oraclize_query ( STR_ , ticker query , ticker query data ) ; ticker query ids [ query id ] = BOOL_ ; ticker query purpose [ query id ] = NUM_ ; waiting seller [ query id ] = from ; cwc paid [ query id ] = amount ; received cwcreturn ( waiting seller [ query id ] , cwc paid [ query id ]"
function birthday boy click here ( ) public view returns ( string ) { require ( now < original time + NUM_ hours ) ; return STR_ ; }
"function update eth icovariables ( uint256 _new_eth_eur , uint256 _new end block ) public only state control { require ( state == states . initial || state == states . valuation set ) ; require ( block . number < _new end block ) ; require ( _new_eth_eur > NUM_ ) ; eth_eur = _new_eth_eur ; end block = _new end block ; move to state ( states . valuation set ) ; }"
function validate name internal ( string _name ) constant internal returns ( bool allowed ) { bytes memory name bytes = bytes ( _name ) ; uint length bytes = name bytes . length ; if ( length bytes < minimum name length || length bytes > maximum name length ) { return BOOL_ ; } bool found non punctuation = BOOL_ ; for ( uint i = NUM_ ; i < length bytes ; i ++ ) { byte b = name bytes [ i ] ; if ( ( b >= NUM_ && b <= NUM_ ) || ( b >= NUM_ && b <= NUM_ ) || ( b >= NUM_ && b <= NUM_ ) ) { found non punctuation = BOOL_ ; continue ; } if ( b == NUM_ || b == NUM_ || b == NUM_ || b == NUM_ || b == NUM_ || b == NUM_ || b == NUM_ ) { continue ; } return BOOL_ ; } return found non punctuation ; }
function get lock balance ( address _owner ) public view returns ( uint256 ) { return _lockup balances [ _owner ] ; }
"function create purchase order ( address _from , uint _period , uint _value , bytes32 _salt ) public pure returns ( bytes32 ) { return keccak256 ( abi . encode packed ( _from , _period , _value , _salt ) ) ; }"
"function approve ( erc20 interface erc20 , address spender , uint tokens ) public returns ( bool success ) { require ( owner == msg . sender ) ; require ( erc20 . approve ( spender , tokens ) ) ; return BOOL_ ; }"
"function add role ( address _operator , string _role ) internal { roles [ _role ] . add ( _operator ) ; emit role added ( _operator , _role ) ; }"
"function update batches ( address _from , address _to , uint _value ) private { uint count = _value ; uint i = min index [ _from ] ; while ( count > NUM_ ) { uint _quant = batches [ _from ] [ i ] . quant ; if ( count >= _quant ) { count -= _quant ; batches [ _from ] [ i ] . quant = NUM_ ; min index [ _from ] = i + NUM_ ; } else { batches [ _from ] [ i ] . quant -= count ; count = NUM_ ; } i ++ ; } batch memory this batch ; this batch . quant = _value ; this batch . age = now ; batches [ _to ] [ max index [ _to ] ] = this batch ; max index [ _to ] ++ ; }"
function set wallet address ( address _wallet address ) external only owner returns ( bool ) { require ( _wallet address != address ( NUM_ ) ) ; require ( _wallet address != address ( this ) ) ; require ( _wallet address != address ( token ) ) ; require ( is owner ( _wallet address ) == BOOL_ ) ; wallet address = _wallet address ; wallet address updated ( _wallet address ) ; return BOOL_ ; }
"function return to sender ( ) public only admins returns ( bool ) { require ( token . transfer ( multisig , token . balance of ( address ( this ) ) ) ) ; require ( multisig . send ( this . balance ) ) ; return BOOL_ ; }"
modifier is retractable ( bytes20 blob id ) { if ( blob info [ blob id ] . flags & retractable == NUM_ ) { throw ; } _ ; }
"function approve and call ( address _spender , uint256 _value , bytes _extra data ) public returns ( bool success ) { require ( ! frozen account [ msg . sender ] ) ; token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }"
function total supply ( ) public view returns ( uint ) { return monsters . length - NUM_ ; }
"function _set subnode owner ( bytes32 subnode , address _owner ) internal { require ( ! known nodes [ subnode ] ) ; known nodes [ subnode ] = BOOL_ ; ens . set subnode owner ( root node , subnode , _owner ) ; }"
"function get stats ( ) public constant returns ( uint256 , uint256 , bool ) { return ( total contribution , _total supply , purchasing allowed ) ; }"
"function withdraw dividend ( ) payable public { uint due = ( token . balance of ( msg . sender ) * div multiplier ) - claimed [ msg . sender ] ; if ( due + claimed [ msg . sender ] < claimed [ msg . sender ] ) revert ( ) ; claimed [ msg . sender ] += due ; total claimed += due ; msg . sender . transfer ( due ) ; emit payed ( msg . sender , due ) ; }"
function _api_place bet ( ) payable { if ( msg . value < get minimum bet ( ) || ( msg . value + NUM_ ) > get maximum bet ( ) ) throw ; uint256 cnt block used = block used [ block . number ] ; if ( cnt block used > max games per block ) throw ; block used [ block . number ] = cnt block used + NUM_ ; games played ++ ; last player = msg . sender ; uint winner odds = NUM_ ; uint total partition = NUM_ ; if ( already played [ msg . sender ] ) { winner odds = NUM_ ; } already played [ msg . sender ] = BOOL_ ; winner odds = winner odds * NUM_ ; total partition = total partition * NUM_ ; uint256 random = create random number ( total partition ) ; if ( random <= winner odds ) { if ( ! msg . sender . send ( msg . value * NUM_ ) ) throw ; } }
"function freeze transfers ( ) public only admin returns ( bool frozen ) { token transfers frozen = BOOL_ ; freeze transfers ( msg . sender , BOOL_ ) ; return BOOL_ ; }"
function get interest ( address _to ) public view returns ( uint interest ) { if ( last block interest paid [ _to ] > NUM_ ) { interest = ( ( block . number - last block interest paid [ _to ] ) * balance of [ _to ] * interest rate ) / ( NUM_ ) ; } else { interest = NUM_ ; } return interest ; }
modifier is owner ( ) { if ( msg . sender != owner ) throw ; _ ; }
"function claim bonus tokens ( ) public can claim bonus { uint256 sender balance = token . balance of ( msg . sender ) ; uint256 purchased proportion = sender balance . mul ( NUM_ ) . div ( total tokens sold ) ; uint256 bonus for sender = bonus tokens pool . mul ( purchased proportion ) . div ( NUM_ ) ; token . transfer ( msg . sender , bonus for sender ) ; claimed bonus [ msg . sender ] = BOOL_ ; }"
function balance of ( address _owner ) public constant returns ( uint ) { uint sum = NUM_ ; for ( uint i = NUM_ ; i < allocated index [ _owner ] . length ; i ++ ) { sum += allocated [ _owner ] [ allocated index [ _owner ] [ i ] ] . tokens ; } return sum ; }
modifier in state ( state s ) { if ( _state ( ) != s ) revert ( ) ; _ ; }
function winning proposal ( ) internal returns ( uint winning proposal ) { uint winning vote count = NUM_ ; for ( uint p = NUM_ ; p < proposals . length ; p ++ ) { if ( proposals [ p ] . vote count > winning vote count ) { winning vote count = proposals [ p ] . vote count ; winning proposal = p ; } } }
function enable refund ( ) public only owner in state ( state . closed ) { current state = state . refund ; }
"function get canvases with sell offer ( bool include private offers ) external view returns ( uint32 [ ] ) { uint32 [ ] memory result = new uint32 [ ] ( canvases . length ) ; uint current index = NUM_ ; for ( uint32 i = NUM_ ; i < canvases . length ; i ++ ) { sell offer storage offer = canvas for sale [ i ] ; if ( offer . is for sale && ( include private offers || offer . only sell to == NUM_ ) ) { result [ current index ] = i ; current index ++ ; } } return _slice ( result , NUM_ , current index ) ; }"
function set bet fee ( uint newfee ) public only owner { bet fee = newfee ; }
function goal reached ( ) public view returns ( bool ) { return total collected >= goal ; }
function controller failed ( ) public only state ( lock state . accepting locks ) only controller ( ) { change state ( lock state . release all ) ; }
function set stake address ( address an address ) is an owner public { stake address = an address ; }
function lookup user donation history by campaign id ( address user ) view returns ( uint [ ] ) { return ( campaign ids donated to by user [ user ] ) ; }
modifier super accredited investor ( ) { require ( ponzico . invested ( msg . sender ) >= NUM_ ether && ! voted [ msg . sender ] ) ; _ ; }
"function change spender ( address _spender ) public only owner { require ( _spender != address ( NUM_ ) ) ; emit spender changed ( spender , _spender ) ; token . approve ( spender , NUM_ ) ; spender = _spender ; set up allowance ( ) ; }"
"function _transfer ( address _from , address _to , uint256 _value ) internal { require ( _value > NUM_ ) ; require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value > balances [ _to ] ) ; uint previous balances = safe math . add ( balances [ _from ] , balances [ _to ] ) ; balances [ _from ] = safe math . sub ( balances [ _from ] , _value ) ; balances [ _to ] = safe math . add ( balances [ _to ] , _value ) ; assert ( safe math . add ( balances [ _from ] , balances [ _to ] ) == previous balances ) ; }"
"function token unpause ( ) external { require ( right and roles . only roles ( msg . sender , NUM_ ) || ( now > end time . add ( renewal ) . add ( user_unpause_token_timeout ) && token sale == token sale type . round2 && is finalized && goal reached ( ) ) ) ; token . set pause ( BOOL_ ) ; }"
"function _get hero power ( uint _genes , uint _dungeon id ) internal view returns ( uint ) { uint difficulty ; ( , , difficulty , , , , , , ) = dungeon token contract . dungeons ( _dungeon id ) ; uint stats power ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { stats power += _genes % NUM_ + NUM_ ; _genes /= NUM_ * * NUM_ ; } uint equipment power ; uint super rank = _genes % NUM_ ; for ( uint j = NUM_ ; j < NUM_ ; j ++ ) { uint cur gene = _genes % NUM_ ; equipment power += equipment_powers [ cur gene ] ; _genes /= NUM_ * * NUM_ ; if ( super rank != cur gene ) { super rank = NUM_ ; } } bool is super = super rank >= NUM_ ; uint super boost ; if ( is super ) { super boost = ( difficulty - NUM_ ) * super_hero_multiplier ; } return stats power + equipment power + super boost ; }"
"function set active times ( uint256 [ ] _from , uint256 [ ] _to ) external only cfo { require ( _from . length == _to . length ) ; active times from = _from ; active times to = _to ; active times ( _from , _to ) ; }"
"function remove from blacklist ( address _airdropper , address _token address ) public only owner { if ( _airdropper != address ( NUM_ ) ) airdropper blacklist [ _airdropper ] = BOOL_ ; if ( _token address != address ( NUM_ ) ) token blacklist [ _token address ] = BOOL_ ; }"
function is_leap_year ( ) private { if ( now >= _year + NUM_ ) { _year = _year + NUM_ ; _year_count = _year_count + NUM_ ; _current mined = NUM_ ; if ( ( ( _year_count - NUM_ ) % NUM_ == NUM_ ) && ( _year_count != NUM_ ) ) { _max mining reward = _max mining reward / NUM_ ; _mining reward = _max mining reward / NUM_ ; } if ( ( _year_count % NUM_ == NUM_ ) && ( ( _year_count - NUM_ ) % NUM_ != NUM_ ) ) { _year = _year + NUM_ ; } else if ( ( _year_count - NUM_ ) % NUM_ == NUM_ ) { _year = _year + NUM_ ; } } }
"function transfer from ico ( address _to , uint256 _value ) public only ico returns ( bool ) { super . transfer ( _to , _value ) ; }"
function calc cak amount ( uint256 wei received ) public view returns ( uint256 ) { uint256 token amount = wei received . div ( rate ) ; return token amount ; }
function open distribution ( ) public only owner { distribution finished = BOOL_ ; emit distribute opened ( ) ; }
function balance of ( address _owner ) external view returns ( uint256 _balance ) { _balance = balances [ _owner ] ; }
"function execute token fallback ( address _to , uint256 _value , bytes _data ) private returns ( bool ) { erc223 reciever receiver = erc223 reciever ( _to ) ; return receiver . token fallback ( msg . sender , _value , _data ) ; }"
"function burn ( uint256 _value ) when not paused public { require ( _value > NUM_ ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( msg . sender , _value ) ; }"
"function breed with auto ( uint256 _matron id , uint256 _sire id ) external payable when not paused { require ( msg . value >= auto birth fee ) ; require ( _owns ( msg . sender , _matron id ) ) ; require ( _is siring permitted ( _sire id , _matron id ) ) ; puppy storage matron = puppies [ _matron id ] ; require ( _is ready to breed ( matron ) ) ; puppy storage sire = puppies [ _sire id ] ; require ( _is ready to breed ( sire ) ) ; require ( _is valid mating pair ( matron , _matron id , sire , _sire id ) ) ; _breed with ( _matron id , _sire id ) ; }"
function current ruling ( uint _dispute id ) public view returns ( uint ruling ) { dispute storage dispute = disputes [ _dispute id ] ; return dispute . vote counter [ dispute . appeals ] . winning choice ; }
"function _create part ( uint8 [ NUM_ ] _part array , address _owner ) internal returns ( uint ) { uint32 new part id = uint32 ( parts . length ) ; assert ( new part id == parts . length ) ; part memory _part = part ( { token id : new part id , part type : _part array [ NUM_ ] , part sub type : _part array [ NUM_ ] , rarity : _part array [ NUM_ ] , element : _part array [ NUM_ ] , battles last day : NUM_ , experience : NUM_ , forge time : uint32 ( now ) , battles last reset : uint32 ( now ) } ) ; assert ( new part id == parts . push ( _part ) - NUM_ ) ; forge ( _owner , new part id , _part ) ; _transfer ( NUM_ , _owner , new part id ) ; return new part id ; }"
function is ico successful ( ) public returns ( bool is successful ) { return tokens supplied >= soft_capacity ; }
"function jack pot b ( ) public view returns ( uint ) { return percent ( prize fund ( ) , NUM_ ) ; }"
function set approver ( address _approver ) public only owner { approver = _approver ; }
"function decayed price of twitter id ( uint256 _twitter id ) public view returns ( uint128 ) { return decayed price of social identity ( twitter , _twitter id ) ; }"
"function _create panda ( uint256 _matron id , uint256 _sire id , uint256 _generation , uint256 [ NUM_ ] _genes , address _owner ) internal returns ( uint ) { require ( _matron id == uint256 ( uint32 ( _matron id ) ) ) ; require ( _sire id == uint256 ( uint32 ( _sire id ) ) ) ; require ( _generation == uint256 ( uint16 ( _generation ) ) ) ; uint16 cooldown index = NUM_ ; if ( pandas . length > NUM_ ) { uint16 pure degree = uint16 ( gene science . get pure from gene ( _genes ) ) ; if ( pure degree == NUM_ ) { pure degree = NUM_ ; } cooldown index = NUM_ / pure degree ; if ( cooldown index % NUM_ < NUM_ ) { cooldown index = cooldown index / NUM_ ; } else { cooldown index = cooldown index / NUM_ + NUM_ ; } cooldown index = cooldown index - NUM_ ; if ( cooldown index > NUM_ ) { cooldown index = NUM_ ; } uint256 _tp = gene science . get wizz type ( _genes ) ; if ( _tp > NUM_"
function transfer ownership ( address new owner ) only owner { owner = new owner ; }
"function presale allocation ( address _recipient , uint256 _ether value , uint8 _vesting plan index ) external only owner only before sale is initialized { require ( _recipient != address ( NUM_ ) ) ; require ( _vesting plan index < vesting plans . length ) ; vesting plan memory plan = vesting plans [ _vesting plan index ] ; uint256 tokens and alapper eth = cln_per_eth . mul ( safe math . add ( NUM_ , plan . alap percent ) ) . div ( NUM_ ) ; uint256 tokens left in pre sale = max_presale_tokens_sold . sub ( presale tokens sold ) ; uint256 wei left in sale = tokens left in pre sale . div ( tokens and alapper eth ) ; uint256 wei to participate = safe math . min256 ( _ether value , wei left in sale ) ; require ( wei to participate > NUM_ ) ; participation presale history [ msg . sender ] = participation presale history [ msg . sender ] . add ( wei to participate ) ; uint256 tokens to transfer = wei to participate . mul ( tokens and alapper eth ) ; presale tokens sold = presale"
"function transfer from ( address _from , address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) returns ( bool success ) { if ( ( balance [ _from ] >= _value ) && ( allowed [ _from ] [ msg . sender ] >= _value ) && ( balance [ _to ] + _value > balance [ _to ] ) ) { balance [ _to ] += _value ; balance [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; transfer ( _from , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }"
"function buy usd ( address account , uint256 cents ) public require is operational require platform manager { require ( balances [ ico owner ] > NUM_ ) ; require ( account != address ( NUM_ ) ) ; require ( cents >= cents exchange rate ) ; uint256 buy jiffys = cents . mul ( jiffys multiplier ) . div ( cents exchange rate ) ; if ( users [ account ] . is registered ) { process purchase ( ico owner , account , buy jiffys , now ) ; } else { uint256 total jiffys = buy jiffys . add ( calculate purchase bonus ( buy jiffys , now ) ) ; balances [ ico owner ] = balances [ ico owner ] . sub ( total jiffys ) ; balances [ account ] = balances [ account ] . add ( total jiffys ) ; purchase credits [ account ] = purchase credit ( buy jiffys , now ) ; transfer ( ico owner , account , buy jiffys ) ; } }"
function determine status ( ) external view returns ( uint ) { if ( crowdsale closed ) return NUM_ ; if ( block . number < end block && total tokens sent < max cap - NUM_ ) return NUM_ ; if ( total tokens sent < min cap && block . number > end block ) return NUM_ ; if ( end block == NUM_ ) return NUM_ ; return NUM_ ; }
function start refunds ( ) external manager only { return period expired = BOOL_ ; }
"function propose partner allocation ( address _dest , uint256 _tokens per period ) public only signatory only payload size ( NUM_ * NUM_ ) { partner tokens allocation . propose allocation ( msg . sender , _dest , _tokens per period ) ; }"
"function __callback ( bytes32 _query id , string _result , bytes _proof ) public sender is oraclize { uint current query id = uint ( keccak256 ( _query id ) ) ; uint random number = NUM_ ; if ( oraclize_random ds_proof verify__return code ( _query id , _result , _proof ) == NUM_ ) { random number = ( uint ( keccak256 ( _result ) ) % NUM_ ) + NUM_ ; } if ( query id map [ current query id ] . bet value != NUM_ ) { delete unprocessed query ( current query id ) ; check if won ( current query id , random number ) ; } }"
"function _set minter ( address _who , bool _flag ) private returns ( bool ) { require ( minters [ _who ] != _flag ) ; minters [ _who ] = _flag ; if ( _flag ) { emit add minter ( _who ) ; } else { emit delete minter ( _who ) ; } return BOOL_ ; }"
function get board status ( uint board id ) public view returns ( board status ) { go board storage board = all boards [ board id ] ; return ( board . status ) ; }
function set wei per satoshi ( uint256 price ) public only owner { price in wei per satoshi = price ; }
"function deposit ( bytes32 _user key , uint _value , uint _fee amount , address _fee address , uint _lockup date ) external only oracle returns ( uint ) { require ( _user key != bytes32 ( NUM_ ) ) ; require ( _value != NUM_ ) ; require ( _fee amount < _value ) ; erc20 _token = erc20 ( token ) ; if ( _token . allowance ( msg . sender , address ( this ) ) < _value ) { return treasury_error_token_not_set_allowance ; } uint _deposited amount = _value - _fee amount ; _make deposit for period ( _user key , _deposited amount , _lockup date ) ; uint _periods count = periods count ; user2last period participated [ _user key ] = _periods count ; delete periods [ _periods count ] . start date ; if ( ! _token . transfer from ( msg . sender , address ( this ) , _value ) ) { revert ( ) ; } if ( ! ( _fee address == NUM_ || _fee amount == NUM_ || _token . transfer ( _fee address , _fee amount ) ) ) { revert ( ) ; } treasury deposited ("
"function buy tokens ( address beneficiary ) non zero eth token is deployed only public non zero address ( beneficiary ) payable returns ( bool ) { require ( msg . value >= min amount ) ; if ( get state ( ) == state . pre sale ) { if ( buy pre sale tokens ( beneficiary ) ) { return BOOL_ ; } return BOOL_ ; } else { require ( now >= crowdfund start date && now <= crowdfund end date ) ; fund transfer ( msg . value ) ; uint256 amount = get no of tokens ( exchange rate for eth , msg . value ) ; if ( token . transfer ( beneficiary , amount ) ) { token sold in crowdsale = token sold in crowdsale . add ( amount ) ; token . change total supply ( amount ) ; total wei raised = total wei raised . add ( msg . value ) ; token purchase ( beneficiary , msg . value , amount ) ; return BOOL_ ; } return BOOL_ ; } }"
function _get token amount ( uint256 _usd cents ) crowdsale started public view returns ( uint256 ) { uint256 tokens ; if ( block . number > pre ico start block && block . number < discounted ico start block ) tokens = _usd cents . div ( NUM_ ) . mul ( presale tokens per dollar ) ; if ( block . number >= discounted ico start block && block . number < main ico start block ) tokens = _usd cents . div ( NUM_ ) . mul ( discounted tokens per dollar ) ; if ( block . number >= main ico start block && block . number < main ico end block ) tokens = _usd cents . div ( NUM_ ) . mul ( main tokens per dollar ) ; return tokens ; }
"function offchain sale ( address beneficiary , uint256 token amount ) only owner public { require ( beneficiary != NUM_ ) ; require ( safe math . add ( tokens sold , token amount ) <= crowdsale supply ) ; tokens sold = safe math . add ( tokens sold , token amount ) ; credit of [ beneficiary ] = credit of [ beneficiary ] . add ( token amount ) ; emit token purchase ( beneficiary , beneficiary , NUM_ , token amount ) ; }"
"function transfer to contract ( address _to , uint _value ) public can transfer returns ( bool ) { require ( _value > NUM_ ) ; balance of [ msg . sender ] = balance of [ msg . sender ] . sub ( _value ) ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; receiving contract receiver = receiving contract ( _to ) ; receiver . token fallback ( msg . sender , _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
function get vesting ( ) returns ( uint ) { uint amount ; for ( uint i = NUM_ ; i >= NUM_ ; ) { uint date = NUM_ days * i ; if ( now > ( lock . init date + date ) ) { if ( lock . last spending == i ) { break ; } if ( lock . last spending == NUM_ ) { amount = ( lock . balance * NUM_ * ( i / NUM_ ) ) / NUM_ ; lock . last spending = i ; break ; } else { amount = ( ( lock . balance * NUM_ * ( i / NUM_ ) ) / NUM_ ) - ( ( lock . balance * NUM_ * ( lock . last spending / NUM_ ) ) / NUM_ ) ; lock . last spending = i ; break ; } } i -= NUM_ ; } return amount ; }
"function add token ( erc20 _token ) public only administrator { require ( _token != address ( NUM_ ) ) ; for ( uint8 i = NUM_ ; i < tokens . length ; i ++ ) { if ( tokens [ i ] == _token ) { break ; } else if ( tokens [ i ] == address ( NUM_ ) ) { tokens [ i ] = _token ; add token ( _token , i ) ; break ; } } }"
function admin withdraw balance ( ) external only admin { admin address . transfer ( admin pool ) ; admin pool = NUM_ ; }
"function _transfer sender pays fee_by proxy ( address sender , address to , uint value ) internal returns ( bool ) { uint fee = transfer fee incurred ( value ) ; return _internal transfer ( sender , to , value , fee ) ; }"
modifier only owner or executor ( ) { require ( msg . sender == owner || msg . sender == executor ) ; _ ; }
"modifier only master ( ) { require ( master == msg . sender , STR_ ) ; _ ; }"
"function add new dividends ( uint256 profit ) internal { uint256 new aum = aum . add ( profit ) ; token value = new aum . mul ( token precision ) . div ( total supply ) ; uint256 total dividends = profit . mul ( token precision ) . div ( token value ) ; uint256 management dividends = total dividends . div ( management fees ) ; uint256 dividends issued = total dividends . sub ( management dividends ) ; require ( tokens frozen >= total dividends ) ; dividend snapshots . push ( dividend snapshot ( total supply , dividends issued , management dividends ) ) ; total supply = total supply . add ( total dividends ) ; tokens frozen = tokens frozen . sub ( total dividends ) ; }"
"function batch mint ( address [ ] _adresses , uint [ ] _values ) public only emitter { require ( _adresses . length == _values . length ) ; for ( uint i = NUM_ ; i < _adresses . length ; i ++ ) { require ( minted ( _adresses [ i ] , _values [ i ] ) ) ; } }"
"function withdraw refund ( uint _order id ) external when not paused { withdraw storage withdraw = withdrawals [ _order id ] ; require ( withdraw state . pending == withdraw . state ) ; address client address = withdraw . client address ; uint amount = withdraw . amount ; withdraw . state = withdraw state . withdrawn ; client address . transfer ( amount ) ; payment withdrawn ( _order id , client address , amount ) ; }"
function withdraw ether ( address to ) public valid address ( to ) onlymanyowners ( keccak256 ( msg . data ) ) { to . transfer ( this . balance ) ; }
function set price setter ( address new price setter ) external only owner ( ) check access ( ) { m_price setter = new price setter ; }
"function release ( ) public only payload size ( NUM_ * NUM_ ) returns ( uint256 ) { uint256 unreleased = releasable amount ( msg . sender ) ; vesting storage vesting = vesting map [ msg . sender ] ; if ( unreleased > NUM_ ) { vesting . released = vesting . released . add ( unreleased ) ; emit release ( msg . sender , unreleased ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( unreleased ) ; emit transfer ( NUM_ , msg . sender , unreleased ) ; } return unreleased ; }"
function _get token amount ( uint256 _wei amount ) internal view returns ( uint256 ) { uint256 tokens = _wei amount . mul ( rate ) ; uint256 bonus tokens = NUM_ ; if ( now < opening time . add ( NUM_ days ) ) { bonus tokens = tokens . mul ( NUM_ ) . div ( NUM_ ) ; } else { bonus tokens = tokens . mul ( NUM_ ) . div ( NUM_ ) ; } return tokens . add ( bonus tokens ) ; }
function finalize ( ) only owner stop in emergency { require ( ! is finalized ) ; require ( has ended ( ) ) ; finalization ( ) ; finalized ( ) ; is finalized = BOOL_ ; }
"function set total individual wei amount ( address _beneficiary , uint256 _total wei amount ) external only owner { total individual wei amount [ _beneficiary ] = _total wei amount ; }"
"function _trigger pvestart ( uint256 _warrior id ) internal { data types . warrior storage warrior = warriors [ _warrior id ] ; warrior . action = uint16 ( pve_battle ) ; warrior . cooldown end block = uint64 ( ( get pveduration ( warrior . level ) / seconds per block ) + block . number ) ; pvestarted ( msg . sender , warrior . dungeon index , _warrior id , warrior . cooldown end block ) ; }"
function claim ( ) external { require ( msg . sender == beneficiary ) ; require ( block . number > funding end block ) ; uint256 balance = erc20 token . balance of ( this ) ; fourth_release ( balance ) ; third_release ( balance ) ; second_release ( balance ) ; first_release ( balance ) ; init_claim ( balance ) ; }
function set start block ( uint256 _start block ) only owner public { start block = _start block ; }
"function update single payout ( address _owner , uint256 _token id ) internal { uint256 total owed ; if ( tokens [ _token id ] . kind == burrito_kind ) { total owed = burrito pool total * tokens [ _token id ] . payout / NUM_ ; } else if ( tokens [ _token id ] . kind == taco_kind ) { total owed = taco pool total * tokens [ _token id ] . payout / NUM_ ; } else if ( tokens [ _token id ] . kind == sauce_kind ) { total owed = sauce pool total * tokens [ _token id ] . payout / NUM_ ; } uint256 total token owed = total owed . sub ( tokens [ _token id ] . withdrawn ) ; tokens [ _token id ] . withdrawn += total token owed ; payout balances [ _owner ] += total token owed ; }"
function set wallet ( address _wallet ) only owner public { wallet = _wallet ; }
"function token pause ( ) public { require ( right and roles . only roles ( msg . sender , NUM_ ) ) ; require ( ! is finalized ) ; token . set pause ( BOOL_ ) ; }"
function abort ( ) public no reentry returns ( bool ) { require ( ! ts succeeded ) ; require ( msg . sender == owner || now > end_date + NUM_ days ) ; delete __abort fuse ; aborted ( ) ; return BOOL_ ; }
"function ether to tokens_ ( uint256 _ether ) internal view returns ( uint256 ) { uint256 _token price initial = token price initial_ * NUM_ ; uint256 _tokens received = ( ( safe math . sub ( ( sqrt ( ( _token price initial * * NUM_ ) + ( NUM_ * ( token price incremental_ * NUM_ ) * ( _ether * NUM_ ) ) + ( ( ( token price incremental_ ) * * NUM_ ) * ( token supply_ * * NUM_ ) ) + ( NUM_ * ( token price incremental_ ) * _token price initial * token supply_ ) ) ) , _token price initial ) ) / ( token price incremental_ ) ) - ( token supply_ ) ; return _tokens received ; }"
function is whitelisted ( address user address ) public constant returns ( bool is indeed ) { if ( whitelisted index . length == NUM_ ) return BOOL_ ; return ( whitelisted index [ whitelisted [ user address ] . index ] == user address ) ; }
"function set uint ( bytes32 _id , bytes32 _key , uint256 _data , bool _overwrite ) only owner ( _id ) returns ( bool ) { if ( data uint [ _id ] [ _key ] == NUM_ || _overwrite ) { data uint [ _id ] [ _key ] = _data ; return BOOL_ ; } else { error ( STR_ ) ; return BOOL_ ; } }"
function supply ( ) public constant returns ( uint ) { return total supply - balance of [ address ( NUM_ ) ] ; }
function gift token ( address _to ) public payable on ico { buy tokens ( _to ) ; }
function get ether ( ) public { require ( match completed ) ; if ( win index == NUM_ ) { uint bet on team a = teams [ NUM_ ] . betting contribution [ msg . sender ] ; uint bet on team b = teams [ NUM_ ] . betting contribution [ msg . sender ] ; teams [ NUM_ ] . betting contribution [ msg . sender ] = NUM_ ; teams [ NUM_ ] . betting contribution [ msg . sender ] = NUM_ ; uint total bet contribution = bet on team a . add ( bet on team b ) ; require ( total bet contribution != NUM_ ) ; msg . sender . transfer ( total bet contribution ) ; } else { uint loosing index = ( win index == NUM_ ) ? NUM_ : NUM_ ; uint bet value ; if ( teams [ win index ] . total amount == NUM_ ) { bet value = teams [ loosing index ] . betting contribution [ msg . sender ] ; require ( bet value != NUM_ ) ; teams [ loosing index ] . betting contribution [ msg . sender ] = NUM_ ; msg . sender . transfer ( bet value ) ; } else { bet value = teams [ win index ] . betting contribution [ msg . sender ] ; require ( bet value != NUM_ ) ; teams [ win index ] . betting contribution [ msg . sender ] = NUM_ ; uint win total amount = teams [ win index ] . total amount ; uint loosing total amount = teams [ loosing index ] . total amount ; if ( loosing total amount == NUM_ ) { msg . sender . transfer ( bet value ) ; } else { uint user total share = bet value ; uint betting share = bet value . mul ( NUM_ ) . div ( NUM_ ) . mul ( loosing total amount ) . div ( win total amount ) ; user total share = user total share . add ( betting share ) ; msg . sender . transfer ( user total share ) ; } } } }
"function add approver ( address _owner , string _company name ) only clevel when not paused external { approved to launch [ keccak256 ( _company name ) ] = _owner ; }"
"function approve ( address _spender , uint _value ) { if ( ( _value != NUM_ ) && ( allowed [ msg . sender ] [ _spender ] != NUM_ ) ) throw ; allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; }"
function sale time over ( ) public view returns ( bool ) { return ( phases [ no of phases - NUM_ ] . end time != NUM_ ) ; }
function with draw funds ( ) public only owner _contract up { vault . withdraw to wallet ( ) ; }
function _is auction exist ( uint256 _artwork id ) internal view returns ( bool ) { return artwork id to auction [ _artwork id ] . seller != address ( NUM_ ) ; }
"function add address to account for user ( address _new address , bytes _new address sig , bytes _sender sig , address _sender , bytes32 _nonce ) private non zero ( _new address ) { require ( ! used signatures [ keccak256 ( abi . encode packed ( _new address sig ) ) ] , STR_ ) ; require ( ! used signatures [ keccak256 ( abi . encode packed ( _sender sig ) ) ] , STR_ ) ; used signatures [ keccak256 ( abi . encode packed ( _new address sig ) ) ] = BOOL_ ; used signatures [ keccak256 ( abi . encode packed ( _sender sig ) ) ] = BOOL_ ; bytes32 _current address digest = signing logic . generate add address schema hash ( _new address , _nonce ) ; require ( _sender == signing logic . recover signer ( _current address digest , _sender sig ) ) ; bytes32 _new address digest = signing logic . generate add address schema hash ( _sender , _nonce ) ; require ( _new address == signing logic . recover signer ( _new address digest , _new address sig ) ) ; registry . add address"
function require registrant or greater ( spentry sp entry ) internal view { require ( msg . sender == sp entry . registrant || msg . sender == owner ) ; require ( is subscribed ( sp entry ) || msg . sender == owner ) ; }
function total supply ( ) constant returns ( uint256 total patron supply ) { total patron supply = _total patron supply ; }
"function mint development team tokens ( address _to , uint256 _tokens ) public only owner only none zero ( _to , _tokens ) { require ( development team tokens minted . add ( _tokens ) <= development_team_cap ) ; development team tokens minted = development team tokens minted . add ( _tokens ) ; token vesting new vault = new token vesting ( _to , now , vesting_cliff , vesting_duration , BOOL_ ) ; vesting wallets . push ( address ( new vault ) ) ; token . mint ( address ( new vault ) , _tokens ) ; }"
function get day ( ) internal returns ( uint ) { return now / NUM_ days ; }
function remove from whitelist ( address _beneficiary ) external only owner { whitelist [ _beneficiary ] = BOOL_ ; membership . remove member ( _beneficiary ) ; }
function set eth usd rate ( uint _eth usd rate ) only owner public { eth usd rate = _eth usd rate ; }
function unpause crowdsale ( ) only owner not ended public returns ( bool ) { is paused = BOOL_ ; return BOOL_ ; }
"function minus ( uint a , uint b ) internal constant returns ( uint ) { assert ( b <= a ) ; return a - b ; }"
"function modify current video game price ( uint _video game id , uint256 _new price ) public { require ( _new price > NUM_ ) ; require ( video games [ _video game id ] . owner address == msg . sender ) ; require ( _new price < video games [ _video game id ] . current price ) ; video games [ _video game id ] . current price = _new price ; }"
"function div256_128 by256 ( uint a21 , uint a0 , uint b ) constant returns ( uint q , uint r ) { uint qhi = ( a21 / b ) << NUM_ ; a21 %= b ; uint shift = NUM_ ; while ( b > > shift > NUM_ ) shift ++ ; shift = NUM_ - shift ; a21 = ( a21 << shift ) + ( shift > NUM_ ? a0 << ( shift - NUM_ ) : a0 > > ( NUM_ - shift ) ) ; a0 = ( a0 << shift ) & NUM_ * * NUM_ - NUM_ ; b <<= shift ; var ( b1 , b0 ) = ( b > > NUM_ , b & NUM_ * * NUM_ - NUM_ ) ; uint rhi ; q = a21 / b1 ; rhi = a21 % b1 ; uint rsub0 = ( q & NUM_ * * NUM_ - NUM_ ) * b0 ; uint rsub21 = ( q > > NUM_ ) * b0 + ( rsub0 > > NUM_ ) ; rsub0 &= NUM_ * * NUM_ - NUM_ ; while ( rsub21 > rhi || rsub21"
function set medium price ( uint _price ) external only owner { medium price = _price ; }
function change rate ( uint256 _rate ) public only owner { require ( _rate > NUM_ ) ; rate = _rate ; emit change rate ( _rate ) ; }
"function request refund ( ) external { assert ( get state ( ) == state . failure ) ; assert ( funders [ msg . sender ] > NUM_ ) ; msg . sender . transfer ( funders [ msg . sender ] ) ; emit refund ( msg . sender , funders [ msg . sender ] , block . number ) ; funders [ msg . sender ] = NUM_ ; }"
modifier is_valid_buyin { require ( tx . gasprice <= max_buyin_gas_price && msg . value >= min_buyin_value ) ; _ ; }
function set exchange threshold ( uint new threshold ) external only cfo { exchange threshold = new threshold ; }
function payout ( address _to ) public only owner { total payments = NUM_ ; _to . transfer ( this . balance ) ; }
"function __callback ( bytes32 myid , string result , bytes proof ) { require ( msg . sender == oraclize_cb address ( ) ) ; if ( ticker query ids [ myid ] == BOOL_ && ticker query purpose [ myid ] == NUM_ ) { last cwceth = result ; if ( ! string equal ( last cwceth , STR_ ) && ! string equal ( last cwceth , STR_ ) ) { last wei price per cwc = parse int ( last cwceth , NUM_ ) ; new ticker query result ( result , myid ) ; uint wei after fees = ( wei paid [ myid ] - fixed fee in wei ) - ( ( wei paid [ myid ] / NUM_ ) * percent fee times100 ) ; uint num of cwcs = ( wei after fees / last wei price per cwc ) ; balances [ waiting buyer [ myid ] ] = balances [ waiting buyer [ myid ] ] . add ( num of cwcs ) ; sold cwc ( waiting buyer [ myid ] , num of cwcs , myid ) ; } else { error ticker query error ( result"
function withdraw ( uint256 _value ) private pure { _value = _value ; }
"function send all tokens to founder ( uint _round ) only manager when initialized { require ( round data [ _round ] . sold tokens >= NUM_ ) ; uint ico token = add ( round data [ _round ] . sold tokens , round data [ _round ] . send tokens ) ; uint ico supply = round data [ _round ] . supply ; uint founder value = sub ( ico supply , ico token ) ; round data [ _round ] . send tokens = add ( round data [ _round ] . send tokens , founder value ) ; tokens to funder = add ( tokens to funder , founder value ) ; robottrading token . emit tokens ( acc founder , founder value ) ; }"
modifier only oracle ( ) { require ( msg . sender == owner ) ; _ ; }
"function get user by id ( uint256 _id ) public view returns ( address _wallet , string _username ) { _username = user idto username [ _id ] ; _wallet = user ids to wallet [ _id ] ; return ( _wallet , _username ) ; }"
"function withdraw non top ( uint _round index ) public { require ( round [ _round index ] . is complete active == BOOL_ && round [ _round index ] . is open == BOOL_ ) ; require ( round [ _round index ] . withdrawable ) ; if ( nami pool [ _round index ] [ msg . sender ] . is active == BOOL_ ) { require ( nami pool [ _round index ] [ msg . sender ] . is withdrawn == BOOL_ ) ; nami pool [ _round index ] [ msg . sender ] . is withdrawn = BOOL_ ; withdraw ( msg . sender , _round index , NUM_ , nami pool [ _round index ] [ msg . sender ] . stake , now ) ; _withdraw nac ( msg . sender , _round index ) ; } }"
function register for raffle3 ( ) public payable { raffle3 registered ( msg . sender ) ; }
function set min sign ( uint40 _new min sign id ) public only operator { require ( _new min sign id > min sign id ) ; min sign id = _new min sign id ; emit min sign set ( min sign id ) ; }
function get proposal count ( ) public constant returns ( uint ) { return proposal index . length ; }
"function find possible delegators of ( address delegate ) public view returns ( address [ ] memory , address [ ] memory ) { address [ ] memory voters ; address [ ] memory token contracts ; delegation memory _delegation ; address [ NUM_ ] memory old senders = [ NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ] ; address old token = NUM_ ; uint64 i ; for ( i = NUM_ ; i < total delegations ; i ++ ) { _delegation = historical delegations [ i ] ; if ( _delegation . delegatee == delegate ) { voters = _append mem array ( voters , _delegation . delegator ) ; token contracts = _append mem array ( token contracts"
"function start sale ( uint256 duration in seconds ) external only owner at stage ( stages . set up ) { require ( round infos [ uint8 ( round ) ] . min contribution > NUM_ && round infos [ uint8 ( round ) ] . hard cap > NUM_ ) ; stage = stages . started ; start time = now ; end time = start time . add ( duration in seconds ) ; sale started ( start time , end time , round ) ; }"
"function unlock ( address _locker , uint _delta , uint8 _locktype ) private returns ( bool success ) { if ( _locktype == NUM_ ) { if ( _delta < NUM_ * NUM_ days ) { return BOOL_ ; } uint _more1 = _delta . sub ( NUM_ * NUM_ days ) ; uint _step1 = _more1 / NUM_ days ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { if ( unlockedstep [ _locker ] == i && i < NUM_ && i <= _step1 ) { ownerance [ _locker ] = ownerance [ _locker ] . add ( lockedance [ _locker ] / ( NUM_ - i ) ) ; lockedance [ _locker ] = lockedance [ _locker ] . sub ( lockedance [ _locker ] / ( NUM_ - i ) ) ; unlockedstep [ _locker ] = i + NUM_ ; } else if ( i == NUM_ && unlockedstep [ _locker ] == NUM_ && _step1 == NUM_ ) { ownerance [ _locker ] = ownerance [ _locker ] . add ( lockedance [ _locker ] ) ; lockedance [ _locker ] = NUM_ ; unlockedstep [ _locker ]"
"function approve and call ( address spender , uint256 value , bytes extra data ) public returns ( bool ) { approve ( spender , value ) ; token recipient ( spender ) . receive approval ( msg . sender , value , this , extra data ) ; return BOOL_ ; }"
"function transfer tokens from contract ( address _to , uint256 _value ) public only owner { avaliable supply = avaliable supply . sub ( _value ) ; _transfer ( this , _to , _value ) ; }"
"function do release ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additional gas ) private returns ( bool ) { escrow memory _escrow ; bytes32 _trade hash ; ( _escrow , _trade hash ) = get escrow and hash ( _trade id , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) return BOOL_ ; uint128 _gas fees = _escrow . total gas fees spent by relayer + ( msg . sender == relayer ? ( gas_do release + _additional gas ) * uint128 ( tx . gasprice ) : NUM_ ) ; delete escrows [ _trade hash ] ; emit released ( _trade hash ) ; transfer minus fees ( _buyer , _value , _gas fees , _fee ) ; return BOOL_ ; }"
function token exists ( uint256 _item id ) public view returns ( bool _exists ) { return price of ( _item id ) > NUM_ ; }
"function fusion chibis ( uint _father id , uint _mother id , uint _seed , string _name , string _battle roar , uint8 _region ) payable public returns ( bool success ) { require ( fusion paused == BOOL_ ) ; require ( owner of ( _father id ) == msg . sender ) ; require ( owner of ( _mother id ) != msg . sender ) ; require ( chibies [ _father id ] . adult <= now ) ; require ( chibies [ _father id ] . exhausted <= now ) ; require ( chibies [ _mother id ] . adult <= now ) ; require ( chibies [ _mother id ] . exhausted <= now ) ; require ( chibies [ _mother id ] . for fusion == BOOL_ ) ; require ( chibies [ _mother id ] . fusion price == msg . value ) ; chibies [ _mother id ] . for fusion = BOOL_ ; chibies [ _mother id ] . exhausted = now . add ( exhaust fusion ( _mother id ) ) ; chibies [ _father id ] . exhausted = now . add ( exhaust fusion ( _father id )"
function change moderator ( address _moderator ) only owner returns ( bool result ) { moderator = _moderator ; return BOOL_ ; }
function refund ( ) public { require ( campaign state == NUM_ ) ; uint256 wei value = participant list [ msg . sender ] . contributed amount pre crowd ; wei value = wei value . add ( participant list [ msg . sender ] . contributed amount stage1 ) ; wei value = wei value . add ( participant list [ msg . sender ] . contributed amount stage2 ) ; wei value = wei value . add ( participant list [ msg . sender ] . contributed amount stage3 ) ; wei value = wei value . sub ( participant list [ msg . sender ] . spent amount ) ; if ( wei value <= NUM_ ) revert ( ) ; participant list [ msg . sender ] . contributed amount pre crowd = NUM_ ; participant list [ msg . sender ] . contributed amount stage1 = NUM_ ; participant list [ msg . sender ] . contributed amount stage2 = NUM_ ; participant list [ msg . sender ] . contributed amount stage3 = NUM_ ; amount refunded = amount refunded . add ( wei value ) ; if ( ! msg . sender
"function transfer ( address to , bytes32 [ NUM_ ] value ) public when not paused when transfer allowed { require ( msg . sender != to ) ; bytes32 [ NUM_ ] memory asset from = assets [ msg . sender ] ; bytes32 [ NUM_ ] memory asset to = assets [ to ] ; for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { asset from [ i ] = _check and sub ( asset from [ i ] , value [ i ] ) ; asset to [ i ] = _check and add ( asset to [ i ] , value [ i ] ) ; } assets [ msg . sender ] = asset from ; assets [ to ] = asset to ; emit transfer ( msg . sender , to ) ; }"
function set gas req ( uint256 _gas req ) only owner external { gas req = _gas req ; }
"function accept creature ownership ( ) public { require ( msg . sender == creature_new owner ) ; emit creature ownership transferred ( creature owner , creature_new owner ) ; creature owner = creature_new owner ; creature_new owner = address ( NUM_ ) ; }"
"function mint booster ( address _owner , uint32 _duration , uint8 _type , uint8 _strength , uint32 _amount , uint24 _raise value ) only chest public { boosters . length ++ ; booster storage temp booster = boosters [ boosters . length - NUM_ ] ; temp booster . owner = _owner ; temp booster . duration = _duration ; temp booster . booster type = _type ; temp booster . strength = _strength ; temp booster . amount = _amount ; temp booster . raise value = _raise value ; transfer ( address ( NUM_ ) , _owner , boosters . length - NUM_ ) ; }"
"function transfer ( address _to , uint256 _value ) public when not paused returns ( bool ) { require ( ! is frozen ( msg . sender ) ) ; return super . transfer ( _to , _value ) ; }"
"function get interval ( ) returns ( uint256 interval ) { if ( now > safe add ( safe mul ( current interval , interval length ) , start time ) ) { current interval = ( now - start time ) / interval length + NUM_ ; } return current interval ; }"
"function set token exchange rate ( address _token , uint _token value ) only oracle { exchange rates [ _token ] = _token value ; }"
"function add to public whitelist ( address _participant ) only whitelist supplier ( ) public returns ( bool ) { if ( whitelist public [ _participant ] ) { return BOOL_ ; } whitelist public [ _participant ] = BOOL_ ; emit public whitelist updated ( _participant , BOOL_ ) ; return BOOL_ ; }"
function is delegate ( address _address ) public view returns ( bool ) { delegate log memory delegate log = delegates [ _address ] ; return delegate log . started != NUM_ && delegate log . ended == NUM_ ; }
"function _safe erc20 transfer ( erc20 _token , address _to , uint _amount ) internal { require ( _to != NUM_ ) ; require ( _token . transfer from ( msg . sender , _to , _amount ) ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
function operations ( ) private returns ( bool ) { operation_address [ operation ] = msg . sender ; operation_amount [ operation ] = msg . value ; operation = operation . add ( NUM_ ) ; return BOOL_ ; }
modifier check nb bets current block ( ) { if ( gambles . length != NUM_ && block . number == gambles [ gambles . length - NUM_ ] . block number ) nb bets current block += NUM_ ; else nb bets current block = NUM_ ; if ( nb bets current block >= max bets per block ) throw ; _ ; }
function enable donation ( ) public only owner returns ( bool success ) { donation closed = BOOL_ ; return BOOL_ ; }
"function get channel with ( data storage self , address partner ) constant returns ( address ) { bytes32 party_hash = party hash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; if ( channel_pos != NUM_ ) { return self . all_channels [ channel_pos - NUM_ ] ; } }"
"function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( approved [ _from ] [ msg . sender ] >= _value && balances [ _from ] >= _value && _value > NUM_ ) ; balances [ _from ] = safe sub ( balances [ _from ] , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; approved [ _from ] [ msg . sender ] = safe sub ( approved [ _from ] [ msg . sender ] , _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }"
modifier is champ ready ( uint256 _champ id ) { require ( champs [ _champ id ] . ready time <= block . timestamp ) ; _ ; }
"function vote against ( uint motion id ) external { uint weight = setup vote ( motion id ) ; vote [ msg . sender ] [ motion id ] = vote . nay ; votes against [ motion id ] = safe add ( votes against [ motion id ] , weight ) ; emit voted against ( msg . sender , msg . sender , motion id , motion id , weight ) ; }"
function get token amount of ( address investor ) constant returns ( uint256 res ) { return token . balance of ( investor ) ; }
"function create asset ( uint256 _creator token id , address _owner , uint256 _price , uint16 _id , uint8 _category , uint8 _state , uint8 _attributes , uint8 [ stats_size ] _stats , uint256 _cooldown , uint64 _cooldown end block ) public only granted contracts returns ( uint256 ) { require ( _id > NUM_ ) ; require ( _category > NUM_ ) ; require ( _attributes != NUM_ ) ; require ( _stats . length > NUM_ ) ; asset memory asset = asset ( { id : _id , category : _category , built by : _creator token id , attributes : bytes2 ( _attributes ) , stats : _stats , state : _state , created at : uint64 ( now ) , cooldown end block : _cooldown end block , cooldown : _cooldown } ) ; uint256 new asset unique id = assets . push ( asset ) - NUM_ ; require ( new asset unique id == uint256 ( uint32 ( new asset unique id ) ) ) ; asset index to price [ new asset unique id ] = _price ; transfer ( address ( NUM_ ) , _owner , new asset unique id )"
function set freeze oracle ( bool _frozen ) only owner public { freeze oracle = _frozen ; }
"function claim tokens ( address receiver ) public is valid payload timed transitions at stage ( stages . trading started ) { if ( receiver == NUM_ ) receiver = msg . sender ; uint token count = bids [ receiver ] * NUM_ * * NUM_ / final price ; bids [ receiver ] = NUM_ ; require ( xrt . transfer ( receiver , token count ) ) ; }"
function owner set treasury ( address new treasury ) public only owner { treasury = new treasury ; }
modifier only burnup game ( ) { require ( burnup game [ msg . sender ] ) ; _ ; }
"function _add original checklist item ( uint8 _player id , rarity tier _tier ) internal { original checklist items . push ( checklist item ( { player id : _player id , tier : _tier } ) ) ; }"
function finalize auction ( ) public at stage ( stages . auction started ) { uint missing_funds = missing funds to end auction ( ) ; require ( missing_funds == NUM_ ) ; final_price = token_multiplier * received_wei / num_tokens_auctioned ; end_time = now ; stage = stages . auction ended ; auction ended ( final_price ) ; assert ( final_price > NUM_ ) ; }
function finish ( ) public only owner { require ( status == status . second stage ) ; status = status . finished ; allocation finished ( now ) ; }
"function determine player ( int128 win balance , uint128 game count , uint8 v , bytes32 r , bytes32 s ) view internal returns ( address ) { if ( authorized [ msg . sender ] ) return ecrecover ( keccak256 ( win balance , game count ) , v , r , s ) ; else return msg . sender ; }"
"function guard villain ( uint256 _target , uint256 _guard ) public payable returns ( bool ) { require ( msg . sender == villain index to owner [ _guard ] ) ; require ( villains [ _guard ] . num skill active < villains [ _guard ] . level ) ; uint256 operation price = guard price ; if ( villain index to price [ _target ] < NUM_ ether ) { operation price = NUM_ ; } if ( msg . value >= operation price && villains [ _target ] . state < NUM_ ) { villains [ _target ] . state = NUM_ ; villains [ _target ] . affected by token = _guard ; villains [ _guard ] . num skill active ++ ; } }"
"function compute bids ( uint _count ) public only owner { require ( status == state . decrypted ) ; require ( _count > NUM_ ) ; uint count = _count ; if ( bids_sorted_count == NUM_ ) { status = state . failure ; emit failure ( NUM_ , NUM_ ) ; return ; } require ( bids_computed_cursor < bids_sorted_count ) ; bid data memory bid ; do { bid = bids_sorted [ bids_computed_cursor ] ; if ( bid . share_price . mul ( computed_shares_sold ) . add ( bid . share_price ) > fundraise_max ) { if ( bids_computed_cursor > NUM_ ) { bids_computed_cursor -- ; } bid = bids_sorted [ bids_computed_cursor ] ; break ; } computed_shares_sold = computed_shares_sold . add ( bid . shares_count ) ; computed_fundraise = bid . share_price . mul ( computed_shares_sold ) ; emit computed ( bid . origin_index , bid . share_price , bid . shares_count ) ; bids_computed_cursor ++ ; count -- ; } while ( count > NUM_ && bids_computed_cursor < bids_sorted_count && ( computed_fundraise < fundraise_max && computed_shares_sold < max_shares_to_sell ) ) ; if ( bids_computed_cursor == bids_sorted_count || computed_fundraise >= fundraise_max || computed_shares_sold >= max_shares_to_sell ) {"
function is on sale ( uint256 token id ) external view returns ( bool ) { return gan token offered for sale [ token id ] . is for sale ; }
function set contract address ( address _address ) public only owner { contract address = _address ; }
function release ( uint256 spid ) public { spentry storage sp entry = sp entries [ spid ] ; require registrant or greater ( sp entry ) ; sp entry . expiration = NUM_ ; sp entry . registrant = address ( NUM_ ) ; sp entry . admin = address ( NUM_ ) ; sp entry . valid = BOOL_ ; }
"function withdraw erc20 token ( address beneficiary , address _token ) only crowdsale agent public { erc20 basic erc20 token = erc20 basic ( _token ) ; uint256 amount = erc20 token . balance of ( this ) ; require ( amount > NUM_ ) ; erc20 token . transfer ( beneficiary , amount ) ; }"
modifier only admin ( ) { address _address = msg . sender ; require ( _address != address ( NUM_ ) ) ; require ( _address == admin address ) ; _ ; }
function is in sale ( ) constant returns ( bool ) { return sale end time >= now && pre sale start time <= now ; }
function check prize ( ) external view returns ( uint256 prize ) { prize = prizes [ msg . sender ] ; return prize ; }
"function add period ( uint256 _start timestamp , uint256 _end timestamp , uint256 _rate ) only owner public { require ( _start timestamp != NUM_ ) ; require ( _end timestamp > _start timestamp ) ; require ( _rate != NUM_ ) ; period memory period = period ( _start timestamp , _end timestamp , _rate ) ; periods . push ( period ) ; }"
function finalization ( ) internal { token . transfer ownership ( owner ) ; }
"function _error and refund ( string _msg , uint _bet , uint8 _number ) private { require ( msg . sender . call . value ( msg . value ) ( ) ) ; emit roll refunded ( now , msg . sender , _msg , _bet , _number ) ; }"
"function get_data_benefited ( address _benef , string _safe_name ) public view returns ( string ) { require ( map_data_safe_benefited [ _benef ] [ _safe_name ] . exists == BOOL_ ) ; address _safe_owner_address = map_data_safe_benefited [ _benef ] [ _safe_name ] . safe_owner_address ; require ( users [ _safe_owner_address ] . live_user == BOOL_ ) ; require ( users [ _safe_owner_address ] . active_contract == BOOL_ ) ; return map_data_safe_benefited [ _benef ] [ _safe_name ] . data ; }"
"function cancel bid ( ) only by ( highest bid address ) { if ( piece wanted && now > highest bid time + NUM_ ) { piece wanted = BOOL_ ; highest bid price = NUM_ ; highest bid address = NUM_ ; new highest bid ( NUM_ , NUM_ ) ; interface a = interface ( registrar ) ; a . async send ( msg . sender , highest bid price ) ; } else { throw ; } }"
"function _trigger tournament sign up ( uint256 [ ] memory _warrior ids , uint256 fee ) internal { uint256 [ ] memory tournament data = _pack tournament data ( _warrior ids ) ; for ( uint256 i = NUM_ ; i < group_size ; i ++ ) { warriors [ _warrior ids [ i ] ] . action = uint16 ( tournament_battle ) ; } battle provider . add tournament contender . value ( fee ) ( msg . sender , tournament data ) ; }"
"function set active transcoders ( ) external when system not paused only rounds manager { uint256 current round = rounds manager ( ) . current round ( ) ; uint256 active set size = math . min256 ( num active transcoders , transcoder pool . get size ( ) ) ; uint256 total stake = NUM_ ; address current transcoder = transcoder pool . get first ( ) ; for ( uint256 i = NUM_ ; i < active set size ; i ++ ) { active transcoder set [ current round ] . transcoders . push ( current transcoder ) ; active transcoder set [ current round ] . is active [ current transcoder ] = BOOL_ ; uint256 stake = transcoder pool . get key ( current transcoder ) ; uint256 reward cut = transcoders [ current transcoder ] . pending reward cut ; uint256 fee share = transcoders [ current transcoder ] . pending fee share ; uint256 price per segment = transcoders [ current transcoder ] . pending price per segment ; transcoder storage t = transcoders [ current transcoder ] ; t . reward cut = reward cut ; t . fee share = fee"
"function set activation fee ( uint256 _activation fee ) public only owner returns ( bool ) { require ( _activation fee > NUM_ , STR_ ) ; require ( _activation fee != activation fee , STR_ ) ; activation fee = _activation fee ; emit activation fee updated ( msg . sender , _activation fee ) ; return BOOL_ ; }"
function resume crowdsale ( ) public only owner { is crowdsale paused = BOOL_ ; }
"function add presale ( address _contributor , uint256 _tokens , uint256 _bonus , uint8 _contributor phase ) external only admin and ops only before sale returns ( bool ) { require ( _tokens > NUM_ ) ; require ( _bonus > NUM_ ) ; uint256 luckys = _tokens . mul ( j8 t_decimals_factor ) ; uint256 bonus luckys = _bonus . mul ( j8 t_decimals_factor ) ; uint256 total tokens = luckys . add ( bonus luckys ) ; uint256 available tokens to purchase = token contract . balance of ( address ( this ) ) ; require ( total tokens <= available tokens to purchase ) ; require ( ledger contract . add allocation ( _contributor , luckys , bonus luckys , _contributor phase ) ) ; require ( token contract . transfer ( address ( ledger contract ) , total tokens ) ) ; total tokens sold = total tokens sold . add ( total tokens ) ; available tokens to purchase = token contract . balance of ( address ( this ) ) ; if ( available tokens to purchase == NUM_ ) { finalization ( ) ; } presale added ( _contributor , total tokens ,"
"function mint for private fiat ( address _beneficiary , uint256 _wei amount ) public only owner { _pre validate purchase ( _beneficiary , _wei amount ) ; uint256 tokens = _get token amount ( _wei amount ) ; wei raised = wei raised . add ( _wei amount ) ; _process purchase ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , _wei amount , tokens ) ; _update purchasing state ( _beneficiary , _wei amount ) ; _forward funds ( ) ; _post validate purchase ( _beneficiary , _wei amount ) ; }"
function credit balance of ( address _user ) public view returns ( uint256 ) { return credit balances [ _user ] ; }
"function vested transfer ( address _to , uint256 _amount , uint _lock months ) public when not paused only payload size ( NUM_ * NUM_ ) returns ( bool ) { require ( msg . sender == funds wallet || msg . sender == team wallet ) ; require ( _lock months >= min vest lock months ) ; vesting storage vesting = vesting map [ _to ] ; require ( vesting . amount == NUM_ ) ; if ( msg . sender == funds wallet ) { require ( allow purchase ( _amount ) ) ; require ( is purchase within cap ( token sold , _amount ) ) ; require ( allow transfer ( msg . sender , _amount ) ) ; uint256 transfer amount = _amount . mul ( NUM_ ) . div ( NUM_ ) ; uint256 vesting amount = _amount . sub ( transfer amount ) ; vesting . amount = vesting amount ; vesting . start time = now ; vesting . lock months = _lock months ; emit vest transfer ( msg . sender , _to , vesting . amount , vesting . start time , _lock months ) ; balances [ msg"
"function reclaim resource deposits ( address _withdraw address ) public only manager { require ( _withdraw address != address ( NUM_ ) ) ; for ( uint8 ii = NUM_ ; ii < NUM_ ; ii ++ ) { if ( resource erc20 address [ ii ] != NUM_ ) { erc20 res cont = erc20 ( resource erc20 address [ ii ] ) ; uint256 bal = res cont . balance of ( this ) ; res cont . transfer ( _withdraw address , bal ) ; } } }"
function ether funds of ( address _address ) public constant returns ( uint ) { return ether funds [ _address ] ; }
function change disown ( uint new_value ) public only owner { if ( new_value == NUM_ ) { disown = NUM_ ; } }
function calculate allocation ( address contributor ) public constant returns ( uint256 ) { uint256 presale = presale contributions [ contributor ] . mul ( NUM_ ) . div ( NUM_ ) ; uint256 total contribution = presale . add ( contributions [ contributor ] ) ; return total contribution . mul ( max_tokens ) . div ( presale_wei_with_bonus . add ( wei contributed ) ) ; }
"function plus ( uint256 addend a , uint256 addend b ) public pure returns ( uint256 sum ) { sum = addend a + addend b ; }"
"function purchase supernova ( address target address , uint price ) external only manager { require ( super nova supply >= NUM_ ) ; nova coin interface nova coin contract = nova coin interface ( nova coin address ) ; require ( nova coin contract . balance of ( target address ) >= price ) ; nova coin contract . consume coin for nova ( target address , price ) ; super nova supply -= NUM_ ; var new nova id = _insert new astro ( target address , astro type . supernova , NUM_ , NUM_ , NUM_ ) ; purchased supernova ( target address , new nova id ) ; }"
"function create sale auction ( uint256 _artwork id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _artwork id ) ) ; _approve ( _artwork id , sale auction ) ; sale auction . create auction ( _artwork id , _starting price , _ending price , _duration , msg . sender ) ; }"
"function release reserved tokens ( ) external only owner { require ( block . timestamp > ( opening time . add ( NUM_ weeks ) ) ) ; require ( allocated [ _reserve ] > NUM_ ) ; token . transfer ( _reserve , reserve_token_amount ) ; allocated [ _reserve ] = NUM_ ; }"
modifier when private fund enabled ( ) { require ( private fund enabled ) ; _ ; }
"function send to beneficiary ( ) public { uint256 amount = get available amount ( ) ; already withdrawn += amount ; require ( token . transfer ( beneficiary , amount ) ) ; }"
"function concat ( string _base , string _value ) internal returns ( string ) { bytes memory _base bytes = bytes ( _base ) ; bytes memory _value bytes = bytes ( _value ) ; assert ( _value bytes . length > NUM_ ) ; string memory _tmp value = new string ( _base bytes . length + _value bytes . length ) ; bytes memory _new value = bytes ( _tmp value ) ; uint i ; uint j ; for ( i = NUM_ ; i < _base bytes . length ; i ++ ) { _new value [ j ++ ] = _base bytes [ i ] ; } for ( i = NUM_ ; i < _value bytes . length ; i ++ ) { _new value [ j ++ ] = _value bytes [ i ] ; } return string ( _new value ) ; }"
function _is contract ( address _address ) internal view returns ( bool ) { uint size ; assembly { size : = extcodesize ( _address ) } return size > NUM_ ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; if ( is holding locked tokens [ msg . sender ] ) { require ( _value <= balances [ msg . sender ] . sub ( locked token balance [ msg . sender ] ) ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
"function grant ( address beneficiary , uint256 vested jiffys , uint256 unvested jiffys , uint256 start timestamp , uint256 cliff seconds , uint256 vesting seconds , bool revocable ) public require is operational { require ( beneficiary != address ( NUM_ ) ) ; require ( ! vesting grants [ beneficiary ] . is granted ) ; require ( ( vested jiffys > NUM_ ) || ( unvested jiffys > NUM_ ) ) ; require ( start timestamp >= genesis_timestamp ) ; require ( vesting seconds > NUM_ ) ; require ( cliff seconds >= NUM_ ) ; require ( cliff seconds < vesting seconds ) ; when contract . vesting grant ( msg . sender , beneficiary , vested jiffys , unvested jiffys ) ; vesting grants [ beneficiary ] = vesting grant ( { is granted : BOOL_ , issuer : msg . sender , beneficiary : beneficiary , grant jiffys : unvested jiffys , start timestamp : start timestamp , cliff timestamp : start timestamp + cliff seconds , end timestamp : start timestamp + vesting seconds , is revocable : revocable , released jiffys : NUM_ } ) ; vesting grant lookup . push ( beneficiary"
function add player ( address a ) private { if ( last ping [ a ] == NUM_ ) { participants [ count participants ] = a ; count participants = count participants + NUM_ ; } last ping [ a ] = now ; }
function collect interest ( address _owner ) internal { require ( is start ) ; uint block height ; if ( deposit blockheight [ _owner ] < block height start ) { block height = block height start ; } else { block height = deposit blockheight [ _owner ] ; } uint _temp interest = account balance [ _owner ] * ( block . number - block height ) / NUM_ ; account balance [ _owner ] += _temp interest ; master apparent balance += _temp interest ; deposit blockheight [ _owner ] = block . number ; }
function return referral ( address _user ) external view returns ( address ) { return affiliates [ _user ] ; }
"function transfer ( address _to , uint256 _value ) public valid address ( _to ) returns ( bool success ) { if ( lock num [ msg . sender ] > NUM_ ) calc unlock ( msg . sender ) ; if ( balance p [ msg . sender ] >= _value && _value > NUM_ ) { balance p [ msg . sender ] = sub ( balance p [ msg . sender ] , _value ) ; balance p [ _to ] = add ( balance p [ _to ] , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }"
"function init members ( ) only owner { add member ( NUM_ , STR_ ) ; add member ( msg . sender , STR_ ) ; }"
"function purchase country ( uint256 _token id ) public payable is not contract ( msg . sender ) { country storage country = country data [ _token id ] ; uint256 price = country . price ; address old owner = country . owner ; address new owner = msg . sender ; uint256 excess = msg . value . sub ( price ) ; require ( price > NUM_ ) ; require ( msg . value >= price ) ; require ( old owner != msg . sender ) ; uint256 profit = price . sub ( country . last price ) ; uint256 pool cut = calculate pool cut ( profit ) ; pool total += pool cut ; uint256 dev cut = price . mul ( NUM_ ) . div ( NUM_ ) ; dev owed = dev owed . add ( dev cut ) ; transfer country ( old owner , new owner , _token id ) ; country . last price = price ; country . price = get next price ( price ) ; country purchased ( _token id , new owner , price ) ; old owner . transfer ( price . sub"
function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = zodiac index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }
"function read bytes32 ( bytes data , uint256 index ) internal pure returns ( bytes32 o ) { if ( data . length / NUM_ > index ) { assembly { o : = mload ( add ( data , add ( NUM_ , mul ( NUM_ , index ) ) ) ) } } }"
"function is phase ( uint time , uint n ) constant returns ( bool ) { if ( time > now ) { throw ; } if ( n >= n ) { throw ; } if ( n > NUM_ && phase end time [ n - NUM_ ] > time ) { return BOOL_ ; } if ( n < n && time >= phase end time [ n ] ) { return BOOL_ ; } return BOOL_ ; }"
function referral dividends of ( address _player address ) public view returns ( uint256 ) { return crypto torch token_ . referral balance of ( _player address ) ; }
"function approve to mint ( uint256 _value ) external when not paused returns ( bool ) { return approve ( the coin , _value ) ; }"
function destroy ( ) public owner only { for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { require ( state [ i ] == state . paused || state [ i ] == state . uninitialized ) ; } selfdestruct ( owner ) ; }
"function mint tokens ( address beneficiary , uint256 amount ) internal { tokens minted = tokens minted . add ( amount ) ; require ( tokens minted <= hard cap ) ; assert ( token . mint ( beneficiary , amount ) ) ; add holder ( beneficiary ) ; }"
"modifier only by or ( address _account1 , address _account2 ) { require ( msg . sender == _account1 || msg . sender == _account2 ) ; _ ; }"
modifier not exceed maximum supply ( uint amount ) { require ( total supply . plus ( amount ) <= maximum supply ) ; _ ; }
function burn tokens ( ) external only crowdsale when not paused { uint256 remaining icotoken = limit crowdsale . sub ( tokens distributed crowdsale ) ; if ( remaining icotoken > NUM_ && ! remaining token burnt ) { remaining token burnt = BOOL_ ; limit crowdsale = limit crowdsale . sub ( remaining icotoken ) ; total supply = total supply . sub ( remaining icotoken ) ; } }
"function add vineyard endorsement ( string _mapping id , uint _index , bool positive , string title , string description ) external returns ( bool success ) { vineyard endorsements [ keccak256 ( _mapping id , _index ) ] . push ( endorsement ( positive , title , description , msg . sender ) ) ; return BOOL_ ; }"
"function update description ( string _project description , bytes32 _hash of the document ) only project manager { description = _project description ; hash of the document = _hash of the document ; project description updated ( msg . sender , _project description , _hash of the document ) ; }"
"function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( b >= a ) { return NUM_ ; } return a - b ; }"
"function player check provably fair ( uint random result , bytes proof ) public constant returns ( uint ) { return uint ( sha3 ( random result , proof ) ) % NUM_ + NUM_ ; }"
function get total supply ( ) public constant returns ( uint256 ) { return total supply ; }
function get toc price ( ) public view returns ( uint256 ) { return market [ contract addr ] . toc price ; }
function set name ( bytes32 _name ) public { if ( name to address [ _name ] != address ( NUM_ ) ) { return ; } players [ msg . sender ] . name = _name ; name to address [ _name ] = msg . sender ; }
function exit ( ) external { require ( BOOL_ ) ; }
"function quick trade ( address token from , address token to , uint256 input ) payable drain block { uint256 in value ; uint256 temp in value = safe add ( token to value ( ether contract , msg . value ) , token to value ( token from , input ) ) ; in value = value with fee ( temp in value ) ; uint256 out value = value to token ( token to , in value ) ; assert ( verified transfer from ( token from , msg . sender , input ) ) ; if ( token to == ether contract ) { assert ( msg . sender . call . value ( out value ) ( ) ) ; } else assert ( token ( token to ) . transfer ( msg . sender , out value ) ) ; trade ( token from , token to , msg . sender , in value ) ; }"
"function set times ( uint256 _start time , uint256 _duration ) public if authorized ( msg . sender , aphrodite ) { require ( now < start time || now > end time ) ; require ( _start time >= NUM_ && _duration > NUM_ ) ; start time = _start time ; end time = start time + _duration ; emit set period ( start time , end time ) ; }"
"function mint ( address _address , uint _amount ) only controller or owner { require ( _address != NUM_ ) ; uint256 amount = safe math . safe mul ( _amount , ( NUM_ * * decimals ) ) ; assert ( supply cap > NUM_ && amount > NUM_ && safe math . safe add ( current supply , amount ) <= supply cap ) ; balance of [ _address ] = safe math . safe add ( balance of [ _address ] , amount ) ; current supply = safe math . safe add ( current supply , amount ) ; mint ( _address , amount ) ; }"
function unlock tokens ( address _address ) public { require ( locked list [ _address ] != address ( NUM_ ) ) ; token timelock locked contract = token timelock ( locked list [ _address ] ) ; locked contract . release ( ) ; }
function decimals ( ) public delegatable view returns ( uint8 ) { return NUM_ ; }
"function write document ( uint128 refid , uint16 state , uint doctime , bytes32 [ ] taghashes , string tags , string title , string text ) internal { docauthor [ doccnt ] = msg . sender ; userdocid [ msg . sender ] [ userdoccnt [ msg . sender ] ] = doccnt ; userdoccnt [ msg . sender ] ++ ; document event ( doccnt , refid , state , doctime , msg . sender , tags , title , text ) ; for ( uint8 i = NUM_ ; i < taghashes . length ; i ++ ) { if ( i >= NUM_ ) break ; if ( taghashes [ i ] != NUM_ ) tag event ( doccnt , msg . sender , taghashes [ i ] , NUM_ ) ; } doccnt ++ ; }"
"function early purchases ( uint256 early purchase index ) external constant only early purchases loaded returns ( address purchaser , uint256 amount , uint256 purchased at ) { return starbase early purchase . early purchases ( early purchase index ) ; }"
"function get covfefe ( uint _token id ) public view returns ( string term , string meaning , uint generation , uint ready time , uint win count , uint loss count , uint current price , uint last price , address owner ) { covfefe storage covfefe = covfefes [ _token id ] ; term = covfefe . term ; meaning = covfefe . meaning ; generation = covfefe . generation ; ready time = covfefe . sale ready time ; win count = covfefe . win count ; loss count = covfefe . loss count ; current price = covfefe index to price [ _token id ] ; last price = covfefe index to last price [ _token id ] ; owner = covfefe index to owner [ _token id ] ; }"
function balance of ( address _who ) constant returns ( uint256 ) { return accounts [ _who ] . balance ; }
"function unlock2 y ( ) { require ( now >= locked_2 y_date ) ; uint amount = balances locked2 y [ msg . sender ] ; require ( amount > NUM_ ) ; balances locked2 y [ msg . sender ] = NUM_ ; total supply locked2 y = total supply locked2 y . sub ( amount ) ; if ( ! token contract . transfer ( msg . sender , amount ) ) throw ; }"
function whitelist count ( ) public constant returns ( uint ) { uint count = NUM_ ; for ( uint i = NUM_ ; i < bidder whitelist . length ; i ++ ) { if ( bidder whitelist [ i ] != NUM_ ) count ++ ; } return count ; }
function update duration ( uint time ) public only owner { require ( time != NUM_ ) ; assert ( start block != NUM_ ) ; assert ( crowd sale type == NUM_ && crowdsale status != NUM_ ) ; duration crowd sale = duration crowd sale . add ( time ) ; end block = end block . add ( time ) ; state changed ( BOOL_ ) ; }
function my test wallet7 ( ) { me = msg . sender ; set_savings_goal ( NUM_ ether ) ; }
"function buy tokens ( uint256 ether sent ) payable { amount = NUM_ ; amount = div ( ( mul ( ether sent , rate ) ) , NUM_ ether ) ; balances [ msg . sender ] += amount ; tokens -= amount ; amount = NUM_ ; owner . transfer ( msg . value ) ; }"
function balance of ( address _owner ) public view returns ( uint256 ) { return player of [ _owner ] . token balance ; }
"function make withdrawal ( address from , address to , uint value , uint index ) internal { if ( value == stakes [ from ] ) { stakes [ from ] = NUM_ ; remove holder ( from , index ) ; emit stake update ( from , NUM_ ) ; } else { uint new stake = safe sub ( stakes [ from ] , value ) ; require ( new stake >= min staking amount ) ; stakes [ from ] = new stake ; emit stake update ( from , new stake ) ; } total stakes = safe sub ( total stakes , value ) ; assert ( token . transfer ( to , safe sub ( value , withdraw gas cost ) ) ) ; }"
modifier not paused { require ( now > NUM_ || msg . sender == owner ) ; _ ; }
"function receive approval ( address _from , uint256 _amount , address _token , bytes _data ) public no mint returns ( bool ) { require ( _token == old token address ) ; require ( erc20 interface ( old token address ) . transfer from ( _from , this , _amount ) ) ; uint256 new token amount = _amount . mul ( scaling factor ) . mul ( ten decimal places ) ; assert ( tokens redeemed . add ( new token amount ) <= circulating supply ) ; tokens redeemed = tokens redeemed . add ( new token amount ) ; require ( new token . transfer ( _from , new token amount ) ) ; emit log token swap ( _from , _amount , block . timestamp ) ; return BOOL_ ; }"
function create token contract ( ) internal returns ( mintable token ) { return new hazza token ( ) ; }
function valid purchase ( ) internal view returns ( bool ) { bool within period = trans start time >= start time && trans start time <= end time ; bool valid amount = msg . value >= min trans amount ; bool within eth cap = ( ( eth cap . sub ( main wei raised ) ) > NUM_ ) ; bool gold period valid = BOOL_ ; if ( trans start time <= ( start time + gold list period ) ) { gold period valid = ( gold list [ msg . sender ] ) && ( gold list contribution [ msg . sender ] + msg . value <= gold period cap ) ; gold list period flag = BOOL_ ; } return within period && valid amount && within eth cap && gold period valid ; }
"function check holes and distribute purchase funds ( geometry . rect [ ] memory sub plots , uint256 [ ] memory area indices ) private returns ( uint256 ) { uint256 remaining balance = msg . value ; uint256 owed to seller = NUM_ ; for ( uint256 area indices index = NUM_ ; area indices index < area indices . length ; area indices index ++ ) { uint256 ownership index = area indices [ area indices index ] ; geometry . rect memory current ownership rect = geometry . rect ( ownership [ ownership index ] . x , ownership [ ownership index ] . y , ownership [ ownership index ] . w , ownership [ ownership index ] . h ) ; require ( geometry . rect contained inside ( sub plots [ area indices index ] , current ownership rect ) ) ; for ( uint256 hole index = NUM_ ; hole index < holes [ ownership index ] . length ; hole index ++ ) { plot ownership memory hole plot = ownership [ holes [ ownership index ] [ hole index ] ] ; geometry . rect memory hole rect = geometry ."
function cancel ( bytes32 _request id ) external { request storage r = requests [ _request id ] ; require ( r . currency contract == msg . sender ) ; r . state = state . canceled ; canceled ( _request id ) ; }
"function update price ( uint price , uint time sent ) external post check auto liquidate { require ( msg . sender == oracle ) ; require ( last price update time < time sent && time sent < now + NUM_ minutes ) ; ether price = price ; last price update time = time sent ; emit price updated ( price ) ; }"
function get current bonus rate ( ) internal returns ( uint8 ) { if ( get state ( ) == state . pre sale ) { return NUM_ ; } if ( get state ( ) == state . crowdfund ) { if ( now > crowdfund start date && now <= NUM_ ) { return NUM_ ; } if ( now > NUM_ && now <= NUM_ ) { return NUM_ ; } if ( now > NUM_ && now <= NUM_ ) { return NUM_ ; } else { return NUM_ ; } } }
function fill ( uint [ ] data ) only owner { if ( next > NUM_ ) throw ; uint acc ; uint offset = transfers . length ; transfers . length = transfers . length + data . length ; for ( uint i = NUM_ ; i < data . length ; i ++ ) { address addr = address ( data [ i ] & ( d160 - NUM_ ) ) ; uint amount = data [ i ] / d160 ; transfers [ offset + i ] . addr = addr ; transfers [ offset + i ] . amount = amount ; acc += amount ; } total to distribute += acc ; }
"function transfer ( address _to , uint256 _value ) public { _transfer ( msg . sender , _to , _value ) ; }"
function del cashier ( address _address ) only owner public { cashiers [ _address ] = BOOL_ ; cashier removed ( _address ) ; }
"function whitelist address ( address _address ) external only owner at stage ( stages . funding ) { require ( whitelisted [ _address ] != BOOL_ ) ; whitelisted [ _address ] = BOOL_ ; whitelisted event ( _address , BOOL_ ) ; }"
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( ! dvipbackend ( backend contract ) . transfer ( msg . sender , _to , _amount ) ) throw ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }"
function drain ( ) external only owner ( ) { multisig . transfer ( address ( this ) . balance ) ; }
function number of ( bytes16 _edition ) public view returns ( uint256 ) { return edition to edition number [ _edition ] ; }
"function draw ( uint32 _id , uint8 _draws , bytes32 _hash check ) public { game storage _game = games [ _id ] ; address _user = user addresses [ _game . user id ] ; if ( _game . i block == NUM_ ) return _draw failure ( _id , _draws , STR_ ) ; if ( _user != msg . sender ) return _draw failure ( _id , _draws , STR_ ) ; if ( _game . i block == block . number ) return _draw failure ( _id , _draws , STR_ ) ; if ( _game . d block != NUM_ ) return _draw failure ( _id , _draws , STR_ ) ; if ( _draws > NUM_ ) return _draw failure ( _id , _draws , STR_ ) ; if ( _draws == NUM_ ) return _draw failure ( _id , _draws , STR_ ) ; if ( _game . hand rank != hand_undefined ) return _draw failure ( _id , _draws , STR_ ) ; _draw ( _game , _id , _draws , _hash check ) ; }"
function asset thaw ( ) internal { is frozen = BOOL_ ; }
"function get day ( uint16 day id ) public view only valid day ( day id ) returns ( uint16 id , address owner , string message , uint256 sellprice , uint256 buyprice ) { return ( day id , day structs [ day id ] . owner , day structs [ day id ] . message , get current price ( day id ) , day structs [ day id ] . buyprice ) ; }"
"function withdraw for ( address token owner ) public when not paused { require ( ! payments [ token owner ] [ current period . block ] ) ; reset period ( ) ; uint payment = get payment total ( token owner ) ; require ( payment > NUM_ ) ; assert ( this . balance >= payment ) ; payments [ token owner ] [ current period . block ] = BOOL_ ; payment completed ( token owner , current period . block , payment ) ; token owner . transfer ( payment ) ; }"
"function approve ( address _spender , uint256 _value ) public only after minting returns ( bool ) { return super . approve ( _spender , _value ) ; }"
"function buy soul ( address no soul mate ) public payable returns ( uint256 amount ) { uint256 charons obol ; uint256 price ; require ( owned by [ no soul mate ] == address ( NUM_ ) ) ; price = soul prices [ no soul mate ] ; require ( price > NUM_ ) ; require ( bytes ( reasons [ no soul mate ] ) . length > NUM_ ) ; require ( msg . value >= price ) ; charons obol = msg . value / obol ; require ( souls owned [ msg . sender ] + NUM_ > souls owned [ msg . sender ] ) ; pay charon ( charons obol ) ; no soul mate . transfer ( msg . value - charons obol ) ; souls for sale -= NUM_ ; souls sold += NUM_ ; souls owned [ msg . sender ] += NUM_ ; owned by [ no soul mate ] = msg . sender ; soul transfer ( no soul mate , msg . sender ) ; amount = charons obol / napkin price + unit ; amount = check amount ( amount ) ; if ( amount"
function finalize ( ) only owner public { require ( ! sale active ( ) ) ; balances [ wallet ] = balances [ wallet ] . add ( balances [ NUM_ ] ) ; balances [ NUM_ ] = NUM_ ; transferable = BOOL_ ; }
function lock account ( address _addr ) public only admin returns ( bool ) { require ( _addr != address ( NUM_ ) ) ; locked [ _addr ] = BOOL_ ; return BOOL_ ; }
function set kingdom factory ( kingdom factory _kingdom factory ) { external enter ( ) ; set kingdom factory rp ( _kingdom factory ) ; external leave ( ) ; }
"function _burn ( address _who , uint256 _value ) internal { require ( _value <= balances [ _who ] ) ; balances [ _who ] = balances [ _who ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; emit burn ( _who , _value ) ; emit transfer ( _who , address ( NUM_ ) , _value ) ; }"
function lock ( ) internal not locked only owner { locked at = block . timestamp ; time locks [ team reserve wallet ] = team reserve time lock ; time locks [ life reserve wallet ] = life reserve time lock ; time locks [ finan reserve wallet ] = finan reserve time lock ; time locks [ econ reserve wallet ] = econ reserve time lock ; time locks [ develop reserve wallet ] = develop reserve time lock ; locked ( locked at ) ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( _value != NUM_ && allowed [ msg . sender ] [ _spender ] != NUM_ ) { return BOOL_ ; } allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }"
function remove tenant ( uint _land id ) public { require ( lands [ _land id ] . owner address == msg . sender ) ; lands [ _land id ] . land for rent = BOOL_ ; lands [ _land id ] . is occupied = BOOL_ ; cities [ lands [ _land id ] . city renting id ] . land id = NUM_ ; lands [ _land id ] . city renting id = NUM_ ; }
"function slice4 ( bytes b , uint offset ) constant returns ( bytes4 ) { bytes4 out ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { out |= bytes4 ( b [ offset + i ] & NUM_ ) > > ( i * NUM_ ) ; } return out ; }"
function get interest count ( ) constant returns ( uint256 result ) { return interest array . length ; }
modifier when not closed ( ) { require ( ! is closed ) ; _ ; }
"function version addresses ( bytes32 _app , bytes32 _version ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ , version base ( _app , _version ) ) ; }"
"function withdraw eth ( address _from , address _to , uint _amount ) external only owner { require ( eth teller balance [ _from ] >= _amount ) ; eth teller balance [ _from ] = safe math . sub ( eth teller balance [ _from ] , _amount ) ; uint256 wei sold today = get wei sold today ( _from ) ; _date time memory date = get date info ( block . timestamp ) ; eth sells user today [ _from ] [ date . day ] [ date . month ] [ date . year ] = safe math . add ( wei sold today , _amount ) ; _to . transfer ( _amount ) ; }"
"function create converter ( ibancor converter extended _old converter ) private returns ( ibancor converter extended ) { iwhitelist whitelist ; ismart token token = _old converter . token ( ) ; uint32 max conversion fee = _old converter . max conversion fee ( ) ; address converter adderess = bancor converter factory . create converter ( token , registry , max conversion fee , ierc20 token ( address ( NUM_ ) ) , NUM_ ) ; ibancor converter extended converter = ibancor converter extended ( converter adderess ) ; converter . accept ownership ( ) ; converter . accept management ( ) ; icontract features features = icontract features ( registry . get address ( contract ids . contract_features ) ) ; if ( features . is supported ( _old converter , feature ids . converter_conversion_whitelist ) ) { whitelist = _old converter . conversion whitelist ( ) ; if ( whitelist != address ( NUM_ ) ) converter . set conversion whitelist ( whitelist ) ; } return converter ; }"
modifier before range game ( ) { require ( now > d . game start && now <= d . game end ) ; _ ; }
"function get vesting time ( address account , uint index ) public view returns ( uint ) { return get vesting schedule entry ( account , index ) [ time_index ] ; }"
function get contract owner ( ) external view returns ( address ) { return owner address ; }
function set enforce address match ( bool _enforce address match ) only owner public { enforce address match = _enforce address match ; }
"function create auction ( uint256 _token id ) external payable { require ( auctions enabled ) ; require ( _owns ( msg . sender , _token id ) || msg . sender == authority address ) ; require ( ! token id to auction [ _token id ] . live ) ; uint start price = pixel price ; if ( msg . sender == authority address ) { start price = NUM_ ; } require ( msg . value == start price ) ; pixel index to approved [ _token id ] = address ( this ) ; token id to auction [ _token id ] = auction ( msg . sender , start price , block . timestamp + duration , BOOL_ ) ; auction started ( _token id ) ; }"
"function start betting ( uint32 _betting start , uint32 _betting end ) public only owner { require ( ! inited ) ; betting start = _betting start ; betting end = _betting end ; inited = BOOL_ ; started ( betting start , teams . length - NUM_ ) ; }"
"function start new epoch ( ) public only admin returns ( bool succ ) { require ( frozen == BOOL_ ) ; require ( round == NUM_ ) ; require ( epoch < NUM_ ) ; dec = [ NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ] ; round = NUM_ ; epoch ++ ; epoch_fund = NUM_ * NUM_ * * decimals ; total_fund = total_fund . sub ( epoch_fund ) ; emit epoch ( epoch ) ; return BOOL_ ; }"
"function reclaim contract tokens ( ) external only owner returns ( bool ) { uint256 tokens = balance of ( address ( this ) ) ; if ( tokens == NUM_ ) { return BOOL_ ; } balances [ address ( this ) ] = balances [ address ( this ) ] . sub ( tokens ) ; balances [ bank address ] = balances [ bank address ] . add ( tokens ) ; transfer ( address ( this ) , bank address , tokens ) ; contract tokens reclaimed ( tokens ) ; return BOOL_ ; }"
function lock time ( address _owner ) public constant returns ( uint256 locked value ) { return locked [ _owner ] ; }
function send to beneficiary contract ( ) { if ( beneficiary contract != address ( NUM_ ) ) { beneficiary contract . transfer ( this . balance ) ; } else { revert ( ) ; } }
"function sell tokens ( ) public payable begin sale active { require ( msg . value > NUM_ ) ; uint256 amount = msg . value ; uint256 tokens = amount . mul ( rate ) ; require ( tokens <= balances [ presale_address ] ) ; if ( sale action == presale action . first presale activity ) { require ( tokens <= cat_first ) ; } _distribute ( msg . sender , tokens , lock cycle , duration ) ; balances [ presale_address ] = balances [ presale_address ] . sub ( tokens ) ; emit transfer ( presale_address , msg . sender , tokens ) ; emit sell tokens ( msg . sender , tokens , rate ) ; forward funds ( ) ; }"
"function finalize ( bytes32 _exec_id ) private pure returns ( bytes32 [ NUM_ ] memory ) { return [ final_sel , _exec_id ] ; }"
modifier when refund paused { require ( refund paused ) ; _ ; }
"function transfer tokens ( address [ ] _deposits , address _token contract address ) public only owner non reentrant { for ( uint i = NUM_ ; i < _deposits . length ; i ++ ) { address deposit = _deposits [ i ] ; uint erc20 balance = erc20 ( _token contract address ) . balance of ( deposit ) ; if ( erc20 balance == NUM_ ) { continue ; } uint cold wallet1 share = erc20 balance . mul ( percentage ) . div ( NUM_ ) ; uint cold wallet2 share = erc20 balance . sub ( cold wallet1 share ) ; child deposit ( deposit ) . withdraw ( _token contract address , cold wallet1 share , cold wallet1 ) ; child deposit ( deposit ) . withdraw ( _token contract address , cold wallet2 share , cold wallet2 ) ; } }"
"function transfer ownership ( address _new owner ) only owner { balances [ _new owner ] = safe add ( balances [ owner ] , balances [ _new owner ] ) ; balances [ owner ] = NUM_ ; ownable . transfer ownership ( _new owner ) ; }"
"function approve ( token storage storage self , address _spender , uint _amount ) public returns ( bool ) { self . allowed [ msg . sender ] [ _spender ] = _amount ; emit approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }"
"function get all the funds ( ) only executive { if ( now < ( event info . get event end ( ) + NUM_ weeks ) ) { throw ; } bool success = msg . sender . send ( this . balance ) ; hacker gold . transfer ( msg . sender , get hkgowned ( ) ) ; }"
"function _create pixel ( uint32 _id , uint8 _colour r , uint8 _colour g , uint8 _colour b , string _pixel text ) private returns ( uint ) { pixels [ _id ] = pixel ( _id , _colour r , _colour g , _colour b , _pixel text ) ; pixel to price [ _id ] = starting price ; emit colour changed ( _id , _colour r , _colour g , _colour b ) ; return _id ; }"
"function set transfer address ( string name , address transfer ) public owner_only ( keccak256 ( name ) ) { bytes32 label = keccak256 ( name ) ; domain storage domain = domains [ label ] ; require ( domain . transfer address == NUM_ ) ; domain . transfer address = transfer ; transfer address set ( label , transfer ) ; }"
"function send founder and team token ( address to , uint256 value ) public only owner { require ( to != NUM_ && value > NUM_ && distribution supply >= value ) ; balances [ multisig ] = balances [ multisig ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; distribution supply = distribution supply . sub ( value ) ; transfer ( multisig , to , value ) ; }"
function set oraclize gas price ( uint gas price ) { require ( msg . sender == owner ) ; require ( gas price >= NUM_ ) ; require ( gas price <= NUM_ ) ; oraclize_set custom gas price ( gas price ) ; }
function valid sold out ( uint256 sold amount ) internal view returns ( bool ) { return total sold token . add ( sold amount ) > ico total amount ; }
function change controller ( address _new controller ) only owner public { token contract . change controller ( _new controller ) ; }
function tokens_buy ( ) payable returns ( bool ) { uint tnow = now ; if ( tnow > ico_finish ) throw ; if ( _total supply >= max tokens ) throw ; if ( ! ( msg . value >= token_price ) ) throw ; if ( ! ( msg . value >= min value ) ) throw ; if ( msg . value > max value ) throw ; uint tokens_buy = msg . value / token_price * NUM_ * * NUM_ ; if ( ! ( tokens_buy > NUM_ ) ) throw ; if ( tnow < ico_start ) { if ( ! ( msg . value >= min value pre ) ) throw ; tokens_buy = tokens_buy * NUM_ / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <= tnow ) && ( tnow < ico_start + NUM_ * NUM_ ) ) { tokens_buy = tokens_buy * NUM_ / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <= tnow ) && ( tnow < ico_start + NUM_ * NUM_ ) ) { tokens_buy = tokens_buy * NUM_ / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <=
"function _get value part by percent ( uint _initial value , uint _percent ) internal pure returns ( uint ) { uint one percent value = _initial value / NUM_ ; return one percent value * _percent ; }"
"function return other crypto ( address _investor ) external manager only { uint256 tokens = NUM_ ; require ( can iwithdraw ) ; if ( ! is it ico ) { require ( ! return status pre [ _investor ] ) ; tokens = tokens pre ico in other crypto [ _investor ] ; tokens pre ico in other crypto [ _investor ] = NUM_ ; } else { require ( ! return status ico [ _investor ] ) ; tokens = tokens ico in other crypto [ _investor ] ; tokens ico in other crypto [ _investor ] = NUM_ ; sold total = sold total . sub ( tokens no bonus sold [ _investor ] ) ; } lto . burn tokens ( _investor , tokens ) ; emit log return other crypto ( _investor ) ; }"
"function get deal by number ( uint _deal number ) constant public returns ( address buyer , address sender , address agency , uint sum , uint at created , statuses status , uint object type ) { uint deal = deal numbers [ _deal number ] ; return ( deals [ deal ] . buyer , deals [ deal ] . seller , deals [ deal ] . signer , deals [ deal ] . sum , deals [ deal ] . at created , deals [ deal ] . status , deals [ deal ] . object type ) ; }"
"function donate to whale ( uint256 amount ) internal { whale . call . value ( amount ) ( bytes4 ( keccak256 ( STR_ ) ) ) ; total donated += amount ; emit donate ( amount , whale , msg . sender ) ; }"
"function withdraw from token ( ierc20 token _token , address _to , uint256 _amount ) public owner only { token . withdraw tokens ( _token , _to , _amount ) ; }"
function find trusted contract ( address _address ) public view returns ( int ) { for ( uint i = NUM_ ; i < trusted contracts . length ; i ++ ) { if ( _address == trusted contracts [ i ] ) { return int ( i ) ; } } return - NUM_ ; }
"function freeze ( address _account , uint _total amount ) public only owner { frozen account [ _account ] = BOOL_ ; frozen tokens [ _account ] [ NUM_ ] = _total amount ; }"
"function get country by id ( uint8 id ) external view returns ( address , uint , uint ) { return ( countries [ id ] . owner , countries [ id ] . id , countries [ id ] . price ) ; }"
function get all ( ) public constant returns ( address [ ] ) { return whitelist ; }
modifier only under maintenance ( ) { if ( ! maintenance ) revert ( ) ; _ ; }
"function get stage index ( ) public view returns ( uint8 current stage , bool on sale ) { on sale = BOOL_ ; stage memory p ; for ( current stage = NUM_ ; current stage < stages . length ; current stage ++ ) { p = stages [ current stage ] ; if ( p . start time <= now && now <= p . end time ) { return ; } } on sale = BOOL_ ; }"
function get balance ico ( ) public constant returns ( uint ) { uint balance ico = ico cap . add ( pre ico cap ) ; balance ico = balance ico . sub ( stat . current fundraiser ) ; return ( balance ico ) ; }
"function market register token ( address token ) public payable { require ( token market [ token ] . level == NUM_ ) ; require ( msg . value >= market register cost ) ; balance [ NUM_ ] [ admin ] = add ( balance [ NUM_ ] [ admin ] , msg . value ) ; token market [ token ] . level = NUM_ ; token market [ token ] . fee = market default fee low ; market_change ( token ) ; }"
"function refund ( ) public { require ( is refund allowed ) ; address investor = msg . sender ; require ( this . balance > NUM_ ) ; require ( balances [ investor ] > NUM_ ) ; moving = BOOL_ ; uint amount = balances [ investor ] ; balances [ investor ] = NUM_ ; investor . transfer ( amount ) ; refunded ( investor , amount ) ; }"
"function set parter ( address _parter , uint256 _amount , uint256 _timestamp ) public only owner { parter acc . push ( _parter ) ; frozen balances [ owner ] = frozen balances [ owner ] . sub ( _amount ) ; frozen balances [ _parter ] = frozen balances [ _parter ] . add ( _amount ) ; freeze record [ _parter ] [ _timestamp ] = freeze record [ _parter ] [ _timestamp ] . add ( _amount ) ; freeze ( _parter , _amount , _timestamp ) ; set parter ( _parter , _amount ) ; }"
"function set period ( uint256 _start time , uint256 _end time ) only owner { require ( now <= _end time ) ; start time = _start time ; end time = _end time ; period changed ( start time , end time ) ; }"
"modifier only reviewer ( ) { check role ( msg . sender , role_reviewer ) ; _ ; }"
"function mint to other coin buyer ( address _to , uint256 _value , string _note ) only owner public returns ( bool ) { require ( mint ( _to , _value ) ) ; ksc_buy other coin ( _to , msg . sender , _value , _note ) ; return BOOL_ ; }"
"function transferable tokens ( address holder , uint64 time ) constant public returns ( uint256 ) { return balance of ( holder ) ; }"
function force withdraw ( ) public only owner { withdraw funds ( this . balance ) ; }
"function withdraw ( address _token ) public { uint amount to send = balance per person per token [ _token ] [ msg . sender ] ; balance per person per token [ _token ] [ msg . sender ] = NUM_ ; withdraw ( _token , msg . sender , amount to send ) ; require ( erc20 ( _token ) . transfer ( msg . sender , amount to send ) ) ; }"
"function power ( uint256 _base n , uint256 _base d , uint32 _exp n , uint32 _exp d ) internal view returns ( uint256 , uint8 ) { assert ( _base n < max_num ) ; uint256 base log ; uint256 base = _base n * fixed_1 / _base d ; if ( base < opt_log_max_val ) { base log = optimal log ( base ) ; } else { base log = general log ( base ) ; } uint256 base log times exp = base log * _exp n / _exp d ; if ( base log times exp < opt_exp_max_val ) { return ( optimal exp ( base log times exp ) , max_precision ) ; } else { uint8 precision = find position in max exp array ( base log times exp ) ; return ( general exp ( base log times exp > > ( max_precision - precision ) , precision ) , precision ) ; } }"
function claim refund ( ) { require ( is finalized ) ; require ( ! goal reached ( ) ) ; vault . refund ( msg . sender ) ; }
function remaining ( ) public view returns ( uint ) { return tok contract . balance of ( this ) ; }
"function _handle win ( uint256 _winner , uint256 _loser ) internal returns ( uint64 ) { fish storage winner = fishes [ _winner ] ; fish storage loser = fishes [ _loser ] ; uint64 full weight lost = loser . weight / sqrt ( winner . weight ) ; uint64 max weight lost = loser . weight / weight lost part limit ; uint64 weight lost = max weight lost < full weight lost ? max weight lost : full weight lost ; if ( weight lost < NUM_ ) { weight lost = NUM_ ; } winner . weight += weight lost ; loser . weight -= weight lost ; return weight lost ; }"
function set burn rate ( uint256 _burn basis points ) only owner returns ( bool success ) { require ( ( _burn basis points > NUM_ ) && ( _burn basis points <= NUM_ ) ) ; burn basis points = _burn basis points ; return BOOL_ ; }
function sqrt ( uint256 x ) internal pure returns ( uint256 y ) { uint256 z = ( x + NUM_ ) / NUM_ ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / NUM_ ; } }
"function register arbiter ( uint _num players , uint _arb token , uint _esc fee pct x10 , uint _arb fee pct x10 , uint _fee cap ) public payable { if ( msg . value != registration fee ) { throw ; } if ( _arb token == NUM_ ) { throw ; } if ( arb token exists ( _arb token & NUM_ ) ) { throw ; } if ( arbiters [ msg . sender ] . registered ) { throw ; } if ( _num players > max_players ) { throw ; } if ( _esc fee pct x10 < NUM_ ) { throw ; } if ( _arb fee pct x10 > NUM_ ) { throw ; } arbiters [ msg . sender ] . locked = BOOL_ ; arbiters [ msg . sender ] . num players = uint8 ( _num players ) ; arbiters [ msg . sender ] . esc fee pct x10 = uint8 ( _esc fee pct x10 ) ; arbiters [ msg . sender ] . arb fee pct x10 = uint8 ( _arb fee pct x10 ) ; arbiters [ msg . sender ] . arb token ="
"function approve user kyc ( address _user ) only kyc manager public { supporter storage sup = supporters map [ _user ] ; sup . has kyc = BOOL_ ; kyc ( _user , BOOL_ ) ; }"
"function transfer pre sale tokens ( address _to , uint256 _amount ) public only owner { require ( pre sale supply >= _amount ) ; balances [ owner ] -= _amount ; balances [ _to ] += _amount ; pre sale supply -= _amount ; total tokens remind -= _amount ; }"
function get price ( ) constant returns ( uint256 price ) { for ( var i = NUM_ ; i < deadlines . length ; i ++ ) if ( now < deadlines [ i ] ) return prices [ i ] ; return prices [ prices . length - NUM_ ] ; }
"function init ( uint _periods , uint _t0special ) only owner not initialized { require ( _periods != NUM_ ) ; periods = _periods ; t0special = _t0special ; }"
function update global max ( uint256 _global max ) public not finalized only owner { require ( _global max > global min ) ; global max = _global max ; }
function set fee authority ( address _fee authority ) public optional proxy_only owner { fee authority = _fee authority ; emit fee authority updated ( _fee authority ) ; }
"function claim ( uint _amount ) public { require ( _amount > NUM_ ) ; update points ( msg . sender ) ; uint claiming points = _amount . mul ( point multiplier ) ; require ( accounts [ msg . sender ] . claimed points . add ( claiming points ) <= accounts [ msg . sender ] . allowed points ) ; accounts [ msg . sender ] . claimed points = accounts [ msg . sender ] . claimed points . add ( claiming points ) ; claim disbursement ( msg . sender , _amount ) ; require ( msg . sender . send ( _amount ) ) ; }"
"function tokens of owner by index ( address _owner , uint256 _index ) external view returns ( uint256 token id ) { uint256 count = NUM_ ; for ( uint256 i = NUM_ ; i <= total supply ( ) ; i ++ ) { if ( fighter index to owner [ i ] == _owner ) { if ( count == _index ) { return i ; } else { count ++ ; } } } revert ( ) ; }"
"function new ens ( address _owner ) public returns ( ens ens ) { ens = new ens ( ) ; ens . set subnode owner ( ens_root , eth_tld_label , this ) ; public resolver resolver = new public resolver ( ens ) ; ens . set subnode owner ( eth_tld_node , public_resolver_label , this ) ; ens . set resolver ( public_resolver_node , resolver ) ; resolver . set addr ( public_resolver_node , resolver ) ; ens . set owner ( eth_tld_node , _owner ) ; ens . set owner ( ens_root , _owner ) ; deploy ens ( ens ) ; }"
function total supply ( ) constant returns ( uint256 total supply ) { total supply = total mit ; }
function effective max bet ( ) public view returns ( uint _amount ) { uint _cur max = cur max bet ( ) ; return _cur max > settings . max bet ? settings . max bet : _cur max ; }
function total supply ( ) external view returns ( uint256 ) { return tokens . length ; }
function get_contract ( bytes32 _key ) public constant returns ( address _contract ) { _contract = contract resolver ( resolver ) . get_contract ( _key ) ; }
function set min balance ( uint minimum balance in finney ) only owner public { min balance for accounts = minimum balance in finney * NUM_ finney ; }
function icoopen ( ) constant returns ( bool ) { if ( ! funding ) return BOOL_ ; else if ( block . timestamp < funding start ) return BOOL_ ; else if ( block . timestamp > funding end ) return BOOL_ ; else if ( token creation cap <= total tokens ) return BOOL_ ; else return BOOL_ ; }
"function get vested balance ( uint256 _initial balance , uint256 _current balance , uint256 _vesting start time , uint256 _current time ) public constant returns ( uint256 ) { if ( _current time < _vesting start time ) { return NUM_ ; } if ( _current time >= _vesting start time . add ( vesting period time . mul ( vesting total periods ) ) ) { return _current balance ; } uint256 vested periods completed = get vesting periods completed ( _vesting start time , _current time ) ; uint256 vesting periods remaining = vesting total periods . sub ( vested periods completed ) ; uint256 unvested balance = _initial balance . mul ( vesting periods remaining ) . div ( vesting total periods ) ; return _current balance . sub ( unvested balance ) ; }"
"function is transfer allowed ( address _from , address _to ) private view returns ( bool ) { if ( finalized ) { return BOOL_ ; } if ( _from == bank address || _to == bank address ) { return BOOL_ ; } return BOOL_ ; }"
"function proxy assert ( address dest , how to call how to call , bytes calldata ) public { require ( proxy ( dest , how to call , calldata ) ) ; }"
function refund transaction ( bool _state changed ) internal { if ( _state changed ) { msg . sender . transfer ( msg . value ) ; } else { revert ( ) ; } }
function get transferable ( bytes20 blob id ) external constant exists ( blob id ) returns ( bool transferable ) { transferable = blob info [ blob id ] . flags & transferable != NUM_ ; }
"function burn tokens ( address _from , uint _value ) only ico contract { assert ( _from != NUM_ ) ; require ( _value > NUM_ ) ; balances [ _from ] = sub ( balances [ _from ] , _value ) ; total supply = sub ( total supply , _value ) ; }"
function get event end ( ) constant returns ( uint result ) { return event end ; }
"function seed sale token left ( address _token contract ) public only owner { require ( seed ended ( ) ) ; uint256 amount left = pending uft . sub ( conclude uft ) ; token . transfer from vault ( token , _token contract , amount left ) ; }"
function update availability ( uint256 _bet_amount ) { if ( msg . sender != seller ) throw ; total_bet_available += _bet_amount ; }
"function transfer locked from ( address _from , address _to , uint256 [ ] _time , uint256 [ ] _value ) public valid address ( _from ) valid address ( _to ) returns ( bool success ) { require ( locker [ msg . sender ] ) ; require ( _value . length == _time . length ) ; if ( lock num [ _from ] > NUM_ ) calc unlock ( _from ) ; uint256 i = NUM_ ; uint256 total value = NUM_ ; while ( i < _value . length ) { total value = add ( total value , _value [ i ] ) ; i ++ ; } if ( balance p [ _from ] >= total value && total value > NUM_ ) { i = NUM_ ; while ( i < _time . length ) { balance p [ _from ] = sub ( balance p [ _from ] , _value [ i ] ) ; lock time [ _to ] . length = lock num [ _to ] + NUM_ ; lock value [ _to ] . length = lock num [ _to ] + NUM_ ; lock time [ _to ]"
"function get purchase amount ( address _buyer , uint256 _amount ) private view returns ( uint256 , uint256 ) { uint256 d1 = maxcap . sub ( wei raised ) ; uint256 d2 = exceed . sub ( buyers [ _buyer ] ) ; uint256 d = ( d1 > d2 ) ? d2 : d1 ; return ( _amount > d ) ? ( d , _amount . sub ( d ) ) : ( _amount , NUM_ ) ; }"
"function _get token amount ( uint256 _wei amount , uint8 _stage index ) internal view returns ( uint256 ) { uint256 _bonus = NUM_ ; uint256 _cap ; if ( _stage index == NUM_ ) { _bonus = round1 bonus ; _cap = round1 cap . sub ( round1 sold ) ; } else if ( _stage index == NUM_ ) { _cap = round2 cap . sub ( round1 sold ) ; } else if ( _stage index == NUM_ ) { _bonus = round2 bonus ; _cap = round1 cap . sub ( round1 sold ) . add ( round2 cap ) . sub ( round2 sold ) ; } else if ( _stage index == NUM_ ) { _cap = round1 cap . sub ( round1 sold ) . add ( round2 cap ) . sub ( round2 sold ) ; } else if ( _stage index == NUM_ ) { _bonus = round3 bonus ; _cap = round1 cap . sub ( round1 sold ) . add ( round2 cap ) . sub ( round2 sold ) . add ( round3 cap ) . sub ( round3 sold ) ; } else if ( _stage index"
function get claimable ( ) public constant returns ( uint256 ) { return total committed ; }
function refund ( ) returns ( bool ) { if ( minting finished == BOOL_ && goal reached == BOOL_ && already minted once == BOOL_ ) { balances [ msg . sender ] = NUM_ ; total supply = total supply . sub ( balances [ msg . sender ] ) ; uint value of investment = buy transactions [ msg . sender ] ; msg . sender . transfer ( value of investment ) ; return BOOL_ ; } return BOOL_ ; }
function get rate ( uint256 wei amount ) public pure returns ( uint256 ) { if ( wei amount >= pre_sale_3000_eth ) { return token_rate_40_percent_bonus ; } else if ( wei amount >= pre_sale_300_eth ) { return token_rate_30_percent_bonus ; } else if ( wei amount >= pre_sale_30_eth ) { return token_rate_25_percent_bonus ; } else { return NUM_ ; } }
function set deadline ( uint256 _deadline ) only admin when paused public returns ( bool ) { require ( start < _deadline ) ; deadline = _deadline ; emit new deadline ( _deadline ) ; return BOOL_ ; }
"function initial transfer ( address _to , uint _value ) external only owner returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
"function create tokens from ether ( ) private { assert ( msg . value >= NUM_ ether / NUM_ ) ; uint256 tokens = current rate . mul ( msg . value ) . div ( NUM_ ether ) ; transfer from owner ( msg . sender , tokens , NUM_ ) ; if ( sale status == NUM_ ) { bought with ether [ msg . sender ] = bought with ether [ msg . sender ] . add ( tokens ) ; tokens from ether = tokens from ether . add ( tokens ) ; } }"
function start round d ( ) external manager only { require ( status ico == status ico . round cfinished || status ico == status ico . round dpaused ) ; status ico = status ico . round dstarted ; log start round d ( ) ; }
"function trade ( erc20 src , bancor contract bancor trading contract , address [ ] _path , uint256 _amount , uint256 _min return ) { src . approve ( bancor trading contract , _amount ) ; uint256 dest amount = bancor trading contract . quick convert ( _path , _amount , _min return ) ; trade ( _amount , dest amount ) ; }"
modifier only master { require ( msg . sender == beercoin master ) ; _ ; }
"function results_of_the_last_round ( ) constant returns ( uint players_bet_in_wei , string last_result , string last_player_s_lottery_ticket , address last_player , string the_right_lottery_number , int player_s_gain_or_loss_in_wei , string info ) { last_player = player ; last_player_s_lottery_ticket = a ; the_right_lottery_number = b ; last_result = lastresult ; players_bet_in_wei = wager ; player_s_gain_or_loss_in_wei = lastgainloss ; info = information ; }"
modifier is burner ( address _burner ) { require ( allowed burners [ _burner ] ) ; _ ; }
"function register contract ( address _addr , bytes32 _id , bool _is controlled ) public only owner returns ( bool _result ) { set contract ( _addr , _id , _is controlled ) ; contract ids . push ( _id ) ; _result = BOOL_ ; }"
function get affiliate rate ( uint256 _level ) public constant returns ( uint256 rate ) { return affiliate rate [ _level ] ; }
function should choose winner ( ) internal returns ( bool ) { return get total tickets ( ) >= draw ticket count ; }
function get abilities for collectible id ( uint256 _token id ) external view returns ( uint256 ability ) { nft memory obj = _get attributes of token ( _token id ) ; uint256 _attributes = uint256 ( obj . attributes ) ; ability = ( _attributes % NUM_ ) ; }
"function set maximum rate ( uint256 _new rate ) only owner public { require ( _new rate <= hard coded maximum rate ) ; maximum rate = _new rate ; rate changed ( NUM_ , _new rate ) ; }"
function break tie ( uint team ) { require ( result == NUM_ ) ; require ( msg . sender == owner ) ; result = team ; withdrawal open = BOOL_ ; }
"function clear delegate and unlock tokens ( ) public only delegated not self returns ( uint locked tokens ) { address delegate = delegates by delegator [ msg . sender ] ; locked tokens = locked delegating tokens [ msg . sender ] ; locked delegating tokens [ msg . sender ] = NUM_ ; delegated amounts by delegate [ delegate ] = safe math . sub ( delegated amounts by delegate [ delegate ] , locked tokens ) ; total locked tokens = safe math . sub ( total locked tokens , locked tokens ) ; delete delegates by delegator [ msg . sender ] ; require ( token locker . transfer ( msg . sender , locked tokens ) ) ; require ( shares token address . balance of ( token locker ) == total locked tokens ) ; tokens undelegated ( msg . sender , locked tokens , delegate ) ; return locked tokens ; }"
"function set mat ( uint ray ) public note auth { tub . mold ( STR_ , ray ) ; var axe = tub . axe ( ) ; var mat = tub . mat ( ) ; require ( axe >= ray && axe <= mat ) ; }"
function get all buyers ( ) public constant returns ( address [ ] ) { return buyers ; }
"function transfer ( address _to , uint256 _value ) { if ( _to == NUM_ ) revert ( ) ; if ( balance of [ msg . sender ] < _value ) revert ( ) ; if ( balance of [ _to ] + _value < balance of [ _to ] ) revert ( ) ; if ( msg . sender == etherflip contract ) { raffle address [ number in raffle ] = _to ; number in raffle += NUM_ ; balance of [ msg . sender ] -= NUM_ ; balance of [ _to ] += NUM_ ; transfer ( msg . sender , _to , NUM_ ) ; } else { balance of [ msg . sender ] -= _value ; balance of [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; } }"
"function release vested tokens ( address _adr ) public { vesting schedule storage vesting schedule = vesting map [ _adr ] ; uint256 _total tokens = safe add ( vesting schedule . principle lock amount , vesting schedule . bonus lock amount ) ; require ( safe sub ( _total tokens , vesting schedule . amount released ) > NUM_ ) ; uint256 amount to release = NUM_ ; if ( block . timestamp >= vesting schedule . principle lock period && ! vesting schedule . is principle released ) { amount to release = safe add ( amount to release , vesting schedule . principle lock amount ) ; vesting schedule . amount released = safe add ( vesting schedule . amount released , amount to release ) ; vesting schedule . is principle released = BOOL_ ; } if ( block . timestamp >= vesting schedule . bonus lock period && ! vesting schedule . is bonus released ) { amount to release = safe add ( amount to release , vesting schedule . bonus lock amount ) ; vesting schedule . amount released = safe add ( vesting schedule . amount released , amount to release )"
"function check identity ( bytes32 _biometric data ) public returns ( bool ) { if ( identities [ msg . sender ] . biometric data == _biometric data ) { emit unlock event ( msg . sender , identities [ msg . sender ] . name , identities [ msg . sender ] . surname , now , BOOL_ ) ; return BOOL_ ; } else { emit unlock event ( msg . sender , identities [ msg . sender ] . name , identities [ msg . sender ] . surname , now , BOOL_ ) ; return BOOL_ ; } }"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { if ( shareholders [ _to ] . allowed && shareholders [ msg . sender ] . allowed && balances [ msg . sender ] >= _value && _value > NUM_ ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }"
"function refund ( address _investor ) only icocontract public returns ( bool ) { if ( state != state . refunding ) { error ( STR_ ) ; return BOOL_ ; } if ( deposited [ _investor ] == NUM_ ) { error ( STR_ ) ; return BOOL_ ; } uint256 deposited value = deposited [ _investor ] ; deposited [ _investor ] = NUM_ ; tokens acquired [ _investor ] = NUM_ ; _investor . transfer ( deposited value ) ; emit refunded ( _investor , deposited value ) ; return BOOL_ ; }"
"function withdraw tokens ( ) public only first buyer { first buyer storage buyer = first buyers [ msg . sender ] ; require ( num of transaction >= buyer . last transaction index ) ; uint256 iterate over = num of transaction . sub ( buyer . last transaction index ) ; if ( iterate over > NUM_ ) { iterate over = NUM_ ; } uint256 iterate = buyer . last transaction index . add ( iterate over ) ; uint256 amount = NUM_ ; for ( uint256 i = buyer . last transaction index ; i < iterate ; i ++ ) { uint256 ratio = ( ( buyer . weighted contribution . mul ( NUM_ * * NUM_ ) ) . div ( total weighted contribution ) ) ; amount = amount . add ( ( transactions [ buyer . last transaction index ] . mul ( ratio ) ) . div ( NUM_ * * NUM_ ) ) ; buyer . last transaction index = buyer . last transaction index . add ( NUM_ ) ; } assert ( property . no fee transfer ( msg . sender , amount ) ) ; emit first"
"function destroy ( uint256 _value ) only owner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; destroy ( msg . sender , NUM_ , _value ) ; }"
function clawback ( ) external { if ( msg . sender != curator ) throw ; if ( ! curator . send ( this . balance ) ) throw ; }
"function reject eth transaction request ( ) public only authorised addresses { latest eth tx request = eth transaction request ( NUM_ , NUM_ , NUM_ ) ; eth transaction rejected ( msg . sender ) ; }"
function unlock address ( address target ) public is owner { locked status address [ target ] = BOOL_ ; emit unlocked ( target ) ; }
modifier sale was successfull ( address _token ) { require ( issue map [ _token ] . cln raised >= issue map [ _token ] . reserve ) ; _ ; }
"function trade in ( address smelly old token , uint amount ) public returns ( bool ) { erc20 with decimals old token = erc20 with decimals ( smelly old token ) ; old token . safe transfer from ( msg . sender , owner , amount ) ; uint pnb count = amount * ( uint ( NUM_ ) * * decimals ) / ( uint ( NUM_ ) * * old token . decimals ( ) ) ; require ( total supply . add ( pnb count ) < max total supply ) ; total supply = total supply . add ( pnb count ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( pnb count ) ; transfer ( NUM_ , msg . sender , pnb count ) ; return BOOL_ ; }"
"function rollover fee ( address account , uint last transfer time , uint pre balance ) internal { if ( last transfer time < fee period start time ) { if ( last transfer time < last fee period start time ) { if ( last transfer time < penultimate fee period start time ) { penultimate average balance [ account ] = pre balance ; } else { penultimate average balance [ account ] = safe div ( safe add ( current balance sum [ account ] , safe mul ( pre balance , ( last fee period start time - last transfer time ) ) ) , ( last fee period start time - penultimate fee period start time ) ) ; } last average balance [ account ] = pre balance ; } else { penultimate average balance [ account ] = last average balance [ account ] ; last average balance [ account ] = safe div ( safe add ( current balance sum [ account ] , safe mul ( pre balance , ( fee period start time - last transfer time ) ) ) , ( fee period start time - last fee period"
"function unlock ( ) public constant returns ( bool success ) { uint256 amount = locked balance [ msg . sender ] ; require ( amount > NUM_ ) ; require ( now >= time release [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; locked balance [ msg . sender ] = NUM_ ; time release [ msg . sender ] = NUM_ ; transfer ( NUM_ , msg . sender , amount ) ; un lock ( msg . sender , amount ) ; return BOOL_ ; }"
function set enable buy and sell ( bool is enabled ) only owner public { is enable buy sell = is enabled ; }
function extra mint ( ) only owner public returns ( bool ) { assert ( token . extra mint ( ) ) ; extra mint ( ) ; }
"function new event ( uint _game id , address [ ] _winners , uint _winning number , uint _amount ) public only linked { require ( _game id > NUM_ ) ; events . push ( event ( events . length , _game id , msg . sender , _winners , _winning number , _amount , now ) ) ; }"
"function decrease approval pre signed ( bytes _signature , address _to , uint256 _value , uint256 _gas price , uint256 _nonce ) public valid payload ( NUM_ ) returns ( bool ) { uint256 gas = gasleft ( ) ; address from = recover pre signed ( _signature , decrease approval sig , _to , _value , STR_ , _gas price , _nonce ) ; require ( from != address ( NUM_ ) ) ; require ( ! invalid signatures [ from ] [ _signature ] ) ; invalid signatures [ from ] [ _signature ] = BOOL_ ; nonces [ from ] ++ ; require ( _decrease approval ( from , _to , _value ) ) ; if ( _gas price > NUM_ ) { gas = NUM_ + gas . sub ( gasleft ( ) ) ; require ( _transfer ( from , msg . sender , _gas price . mul ( gas ) ) ) ; } emit signature redeemed ( _signature , from ) ; return BOOL_ ; }"
function owner set casino ( address new casino ) public only owner { casino = new casino ; }
function pay bonus ( ) public only owner returns ( bool success ) { uint256 to index = index paid bonus + NUM_ ; if ( bonus account count < to index ) to index = bonus account count ; for ( uint256 i = index paid bonus ; i < to index ; i ++ ) { if ( bonus account balances [ bonus account index [ i ] ] > NUM_ ) pay bonus1 address ( bonus account index [ i ] ) ; } return BOOL_ ; }
function set advisory pool ( address _advisory pool ) only creator { advisory pool = _advisory pool ; }
function get bet amount ( uint8 team index ) view public returns ( uint ) { return teams [ team index ] . bettor amount [ msg . sender ] ; }
"function get version selectors ( bytes32 _app , bytes32 _version , bytes32 _registry_id ) internal view returns ( bytes4 [ ] memory sels ) { uint length = uint ( registry read ( version selectors ( _app , _version ) , _registry_id ) ) ; sels = new bytes4 [ ] ( length ) ; for ( uint i = NUM_ ; i < length ; i ++ ) { bytes32 location = bytes32 ( NUM_ * ( i + NUM_ ) + uint ( version selectors ( _app , _version ) ) ) ; sels [ i ] = bytes4 ( registry read ( location , _registry_id ) ) ; } }"
"function withdraw talao ( uint256 tokens ) public only owner { require ( balance of ( this ) . sub ( total deposit ) >= tokens , STR_ ) ; _transfer ( this , msg . sender , tokens ) ; }"
"function is transaction already settled ( address _from , bytes32 _calc hash ) public view returns ( bool ) { return executed settlements [ _from ] [ _calc hash ] ; }"
function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = panda index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }
function enable token sale ( ) external only owner { token sale enabled = BOOL_ ; }
function updated at ( uint _id ) constant returns ( uint ) { return tokens [ _id ] . block ; }
"function has confirmed ( bytes32 _operation , address _owner ) external constant multi owned operation is active ( _operation ) owner exists ( _owner ) returns ( bool ) { return ! ( m_multi owned pending [ _operation ] . owners done & make owner bitmap bit ( _owner ) == NUM_ ) ; }"
"function trusted withdraw eth ( address _to , uint256 _amount ) external only bonding manager or jobs manager when system not paused { _to . transfer ( _amount ) ; }"
"function get ico info ( ) public view returns ( bool , uint256 , uint256 , uint256 , uint256 , uint256 ) { return ( balances [ ico owner ] > NUM_ , wei exchange rate , cents exchange rate , bonus20 end timestamp , bonus10 end timestamp , bonus5 end timestamp ) ; }"
"function safe guard ( bytes20 _origin address hash , uint256 _release time , uint16 _privacy commission ) external payable only payload size ( NUM_ * NUM_ ) returns ( bool ) { require ( msg . value >= NUM_ finney ) ; require ( senders [ _origin address hash ] == no_address || balances [ _origin address hash ] > NUM_ ) ; if ( senders [ _origin address hash ] == no_address ) { senders [ _origin address hash ] = msg . sender ; if ( _release time > now ) { timers [ _origin address hash ] = _release time ; } else { timers [ _origin address hash ] = now ; } if ( _privacy commission > NUM_ && _privacy commission <= NUM_ ) { privacy deviation [ _origin address hash ] = _privacy commission ; } } uint256 _commission = msg . value . div ( NUM_ ) ; uint256 _balance after commission = msg . value . sub ( _commission ) ; balances [ _origin address hash ] = balances [ _origin address hash ] . add ( _balance after commission ) ; user balance = user balance . add ( _balance after"
"function withdraw tokens for ( address _account to withdraw for ) public only owner { uint256 amount = balances [ _account to withdraw for ] ; require ( amount > NUM_ ) ; balances [ _account to withdraw for ] = NUM_ ; _deliver tokens ( _account to withdraw for , amount ) ; }"
"function get withdrawable amount fiit ( address _investor ) public view returns ( uint256 ) { require ( start withdraw != NUM_ ) ; uint interval = safe div ( safe sub ( now , start withdraw ) , NUM_ days ) ; uint _allocated tokens = safe add ( wallet founding initiator sales [ _investor ] , released founding initiator sales [ _investor ] ) ; if ( interval < NUM_ ) { return ( NUM_ ) ; } else if ( interval >= NUM_ ) { return safe sub ( _allocated tokens , released founding initiator sales [ _investor ] ) ; } }"
"function calc max withdraw ( ) public constant returns ( uint256 ) { uint256 max tokens = NUM_ ; disbursement [ ] storage temp = disbursements [ msg . sender ] ; for ( uint256 i = NUM_ ; i < temp . length ; i ++ ) { if ( block . timestamp > temp [ i ] . timestamp ) { max tokens = safe math . add ( max tokens , temp [ i ] . tokens ) ; } } max tokens = safe math . sub ( max tokens , withdrawn tokens [ msg . sender ] ) ; return max tokens ; }"
modifier when not paused ( ) { require ( ! paused || msg . sender == ico address || msg . sender == founder address ) ; _ ; }
"function get server ( uint server index ) public view server exists ( server index ) returns ( string , uint , uint , bool , bool ) { server storage server = servers [ server index ] ; return ( server . name , server . pot , server . ante , server . online , server . game active ) ; }"
function set presale phase ( phase _next phase ) public only escrow { bool can switch phase = ( current phase == phase . created && _next phase == phase . running ) || ( current phase == phase . running && _next phase == phase . paused ) || ( ( current phase == phase . running || current phase == phase . paused ) && _next phase == phase . migrating && crowdsale manager != NUM_ ) || ( current phase == phase . paused && _next phase == phase . running ) || ( current phase == phase . migrating && _next phase == phase . migrated && total supply == NUM_ ) ; require ( can switch phase ) ; current phase = _next phase ; emit log phase switch ( _next phase ) ; }
"function distribute internal ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _team , uint256 _keys , j3 ddatasets . event returns memory _event data_ ) private returns ( j3 ddatasets . event returns ) { uint256 _gen = ( _eth . mul ( fees_ [ _team ] . gen ) ) / NUM_ ; uint256 _jan = ( _eth . mul ( fees_ [ _team ] . jan ) ) / NUM_ ; jan pot_ = jan pot_ . add ( _jan ) ; _eth = _eth . sub ( ( _eth . mul ( fees_ [ _team ] . com + fees_ [ _team ] . aff + fees_ [ _team ] . jan ) ) / NUM_ ) ; uint256 _pot = _eth . sub ( _gen ) ; uint256 _dust = update masks ( _r id , _p id , _gen , _keys ) ; if ( _dust > NUM_ ) _gen = _gen . sub ( _dust ) ; round_ [ _r id ] . pot = _pot . add ( _dust ) . add ( round_ [ _r id ] . pot ) ; _event data_ . gen amount ="
"function is payed ( uint _player index ) public constant returns ( bool ) { address player address ; uint ticket amount ; uint dream amount ; ( player address , ticket amount , dream amount ) = ticket holder . get tickets ( _player index ) ; require ( player address != NUM_ ) ; return fund . is payed ( player address ) ; }"
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { require ( ! frozen account [ msg . sender ] ) ; if ( frozen ) return BOOL_ ; else return abstract token . transfer ( _to , _value ) ; }"
function set beneficiary ( address _beneficiary ) public owner only { beneficiary = _beneficiary ; }
"function withdraw mils ( uint256 _mils ) public post end funded { uint256 days since end = ( now - lock up end ) / NUM_ days ; uint256 max pct = min ( ( ( days since end / NUM_ + NUM_ ) * NUM_ ) , NUM_ ) ; uint256 allowed = award [ msg . sender ] ; allowed = allowed * max pct / NUM_ ; allowed -= withdrawn [ msg . sender ] ; require ( _mils <= allowed ) ; military token . transfer ( msg . sender , _mils ) ; withdrawn [ msg . sender ] += _mils ; current awards -= _mils ; }"
function set paused ( bool _paused ) public only owner { paused = _paused ; }
"function create jaro sleep ( address _token , uint256 _daily time ) internal returns ( jaro sleep ) { return new jaro sleep ( _token , _daily time ) ; }"
function disable manager ( address _manager ) external only owner only valid manager address ( _manager ) { require ( manager enabled [ _manager ] == BOOL_ ) ; manager enabled [ _manager ] = BOOL_ ; manager disabled event ( _manager ) ; }
"function salvage tokens ( erc20 basic _token , address _to ) only owner public { _token . transfer ( _to , _token . balance of ( this ) ) ; }"
function sender admin and sale not final ( ) internal view { if ( contract . sender ( ) != address ( contract . read ( admin ( ) ) ) ) revert ( STR_ ) ; if ( contract . read ( is configured ( ) ) == NUM_ || contract . read ( is finished ( ) ) != NUM_ ) revert ( STR_ ) ; }
function started ( ) public view returns ( bool ) { if ( ( uint8 ( current stage ) >= NUM_ || now >= start time && now <= end time ) && uint8 ( current stage ) != NUM_ ) return BOOL_ ; return BOOL_ ; }
"function get weekly rate ( ) private returns ( uint32 ) { if ( now <= weekly rate [ week no ] . end time && now >= weekly rate [ week no ] . start time ) { return weekly rate [ week no ] . week rate ; } if ( now <= weekly rate [ week no + NUM_ ] . end time && now >= weekly rate [ week no + NUM_ ] . start time ) { week no = week no + NUM_ ; set weekly allocation ( ) ; return weekly rate [ week no + NUM_ ] . week rate ; } else { uint256 increased by = now - start date ; uint256 week increased by = increased by . div ( NUM_ ) ; set weekly allocation ( ) ; week no = week no . add ( week increased by ) ; log week rate ( weekly rate [ week no ] . week rate , now ) ; return weekly rate [ week no ] . week rate ; } }"
"function distribute icotokens ( address _buyer , uint tokens ) external only crowdsale when not paused { require ( _buyer != address ( NUM_ ) ) ; require ( tokens > NUM_ ) ; require ( tokens distributed crowdsale < limit crowdsale ) ; require ( tokens distributed crowdsale . add ( tokens ) <= limit crowdsale ) ; tokens distributed crowdsale = tokens distributed crowdsale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }"
function self destruct ( ) public { if ( ( msg . sender == owner ) && ( users . length ( ) == NUM_ ) ) { selfdestruct ( owner ) ; } }
"function allocate proof tokens ( ) public only owner when not finalized { proof token . mint ( proof_multisig , tokens_allocated_to_proof ) ; proof tokens allocated = BOOL_ ; }"
function remove message ( ) only owner public { message = STR_ ; }
"function buy tokens growth life ( ) internal { require ( stage == stage . growth || stage == stage . life ) ; require ( msg . value < two_128 ) ; uint256 total supply = orgon token . total supply ( ) ; assert ( total supply < two_128 ) ; uint256 to buy = safe mul ( total supply , safe sub ( root_10 ( safe add ( two_128 , ( msg . value << NUM_ ) / reserve amount ) ) , two_128 ) ) > > NUM_ ; reserve amount = safe add ( reserve amount , msg . value ) ; require ( reserve amount < two_128 ) ; if ( to buy > NUM_ ) { require ( orgon token . create tokens ( to buy ) ) ; require ( orgon token . total supply ( ) < two_128 ) ; uint256 fee amount = safe mul ( to buy , fee ) / fee_denominator ; require ( orgon token . transfer ( msg . sender , safe sub ( to buy , fee amount ) ) ) ; if ( fee amount > NUM_ ) require ( orgon token . transfer"
"function update whitelist mapping ( address [ ] _address , bool value ) public { require ( msg . sender == white listing admin ) ; for ( uint i = NUM_ ; i < _address . length ; i ++ ) { whitelist [ _address [ i ] ] = value ; } }"
"function transfer ( address _to , uint256 _value ) public manage transfer only payload size ( NUM_ * NUM_ ) returns ( bool success ) { require ( ! frozen accounts [ msg . sender ] ) ; require ( _to != address ( NUM_ ) ) ; return super . transfer ( _to , _value ) ; }"
"function mint ( address _to , uint _value ) public returns ( bool ) { require ( msg . sender == minter || msg . sender == address ( token porter ) ) ; _balance of [ _to ] = _balance of [ _to ] . add ( _value ) ; _total supply = _total supply . add ( _value ) ; emit mint ( _to , _value ) ; emit transfer ( NUM_ , _to , _value ) ; return BOOL_ ; }"
function create default games ( ) public { require ( all games . length == NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; }
"function has recent price ( address of asset ) view pre_cond ( information [ of asset ] . exists ) returns ( bool is recent ) { return sub ( now , information [ of asset ] . timestamp ) <= validity ; }"
"function to bytes ( uint256 addr , uint256 len ) internal pure returns ( bytes memory bts ) { bts = new bytes ( len ) ; uint256 btsptr = data ptr ( bts ) ; copy ( addr , btsptr , len ) ; }"
function a purge messages ( ) only owner { delete m queue ; }
function withdraw dividends ( ) public { uint256 dividends = user dividends [ msg . sender ] ; user dividends [ msg . sender ] = NUM_ ; msg . sender . transfer ( dividends ) ; }
"function change id ( string new id ) if authorised { shareholders [ msg . sender ] . id = new id ; changed id ( msg . sender , new id ) ; }"
function flags ( address _address ) public delegatable view returns ( uint256 ) { return address flags [ _address ] ; }
"function participant round amount ( address _address , uint _round ) external view returns ( uint ) { ico storage ico = icorounds [ _round == NUM_ ? current round : _round ] ; participant storage p = ico . participants [ _address ] ; return p . amount ; }"
function isdeposit ( ) external view returns ( uint ) { return deposit items [ msg . sender ] . valid ; }
"function update flight status ( bytes32 flight id , uint actual arrival time ) public only if creator { uint8 new status = NUM_ ; for ( uint i = NUM_ ; i < insurance list [ flight id ] . length ; i ++ ) { if ( insurance list [ flight id ] [ i ] . status == NUM_ ) { new status = NUM_ ; if ( actual arrival time > insurance list [ flight id ] [ i ] . limit arrival time ) { new status = NUM_ ; } insurance list [ flight id ] [ i ] . status = new status ; insurance update ( insurance list [ flight id ] [ i ] . product id , flight id , insurance list [ flight id ] [ i ] . premium , insurance list [ flight id ] [ i ] . indemnity , new status ) ; } } }"
"function atomic match ( order memory buy , sig memory buy sig , order memory sell , sig memory sell sig , bytes32 metadata ) internal reentrancy guard { bytes32 buy hash = require valid order ( buy , buy sig ) ; bytes32 sell hash = require valid order ( sell , sell sig ) ; require ( orders can match ( buy , sell ) ) ; uint size ; address target = sell . target ; assembly { size : = extcodesize ( target ) } require ( size > NUM_ ) ; if ( buy . replacement pattern . length > NUM_ ) { array utils . guarded array replace ( buy . calldata , sell . calldata , buy . replacement pattern ) ; } if ( sell . replacement pattern . length > NUM_ ) { array utils . guarded array replace ( sell . calldata , buy . calldata , sell . replacement pattern ) ; } require ( array utils . array eq ( buy . calldata , sell . calldata ) ) ; authenticated proxy proxy = registry . proxies ( sell . maker ) ; require ( proxy != address"
function balance ( ) view public returns ( uint256 ) { return token . balance of ( address ( this ) ) ; }
"function transfer ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; ownership transferred ( owner , new owner ) ; owner = new owner ; }"
modifier only token contract ( ) { _ ; }
"function complete ( uint256 _sanity , uint256 _value ) if creator external { require ( _sanity == NUM_ ) ; require ( progress == NUM_ || progress == NUM_ ) ; require ( block . timestamp >= finish ) ; require ( this . balance >= _value ) ; progress = NUM_ ; reserves = safe add ( reserves , _value ) ; completed ( tokens , value , _value ) ; sale callback interface ( marketplace ) . handle sale completion callback . value ( _value ) ( tokens ) ; }"
function retry winners ( ) public only owner { for ( uint i = NUM_ ; i < pending winners . length ; i ++ ) { retry winner ( i ) ; } pending winners . length = NUM_ ; }
"function cancel order ( uint exchange number , uint id ) external pre_cond ( is owner ( ) || is shut down ) { order order = orders [ id ] ; require ( address ( exchanges [ exchange number ] . exchange adapter ) . delegatecall ( bytes4 ( keccak256 ( STR_ ) ) , exchanges [ exchange number ] . exchange , order . exchange id ) ) ; order . status = order status . cancelled ; order updated ( id ) ; }"
"function withdraw talao ( uint256 tokens ) public only owner { token . transfer ( msg . sender , tokens ) ; }"
function address hash ( address item ) public pure returns ( bytes32 hash ) { hash = keccak256 ( item ) ; }
"function withdraw token ( address token , uint amount ) external is admin { require ( token != address ( NUM_ ) && token ( token ) . transfer ( msg . sender , amount ) ) ; }"
function get usdprice ( ) private view returns ( uint256 ) { return usd cent value ; }
"function transfer to address ( address _to , uint _value , bytes _data ) private returns ( bool success ) { if ( balance of ( msg . sender ) < _value ) revert ( ) ; balances [ msg . sender ] = balance of ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balance of ( _to ) . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; erc223 transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }"
function set service agent ( address _new service agent ) public only owner { service agent = _new service agent ; }
function handle for token id ( uint _token id ) public view returns ( bytes32 ) { bytes32 handle = handles [ _token id ] ; require ( handle != NUM_ ) ; return handle ; }
function set buy enabled ( bool buy enabled_ ) public auth returns ( bool ) { buy enabled = buy enabled_ ; log buy enabled ( buy enabled ) ; return BOOL_ ; }
function set operating officer ( address _operating officer address ) external only executive officer { require ( _operating officer address != address ( NUM_ ) ) ; operating officer address = _operating officer address ; }
"function insert ( uint id , uint pos ) public returns ( bool ) { require ( ! is offer sorted ( id ) ) ; require ( is active ( id ) ) ; _hide ( id ) ; _sort ( id , pos ) ; log insert ( msg . sender , id ) ; return BOOL_ ; }"
function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = warrior to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }
function sold in tranche ( uint256 _tokens and bonus ) internal { uint256 index of tranche = define tranche period ( ) ; require ( tranches [ index of tranche ] . value for tranche >= _tokens and bonus ) ; tranches [ index of tranche ] . value for tranche = tranches [ index of tranche ] . value for tranche . sub ( _tokens and bonus ) ; total sold tokens = total sold tokens . add ( _tokens and bonus ) ; }
"function check token balance state ( address _owner ) external view returns ( uint256 unlocked balance , uint256 locked balance ) { return ( balance of ( _owner ) . sub ( locked token balance [ _owner ] ) , locked token balance [ _owner ] ) ; }"
"function _get hero genes or claim first hero ( uint _hero id ) internal returns ( uint hero id , uint hero genes ) { hero id = _hero id ; if ( hero token contract . balance of ( msg . sender ) == NUM_ ) { hero id = claim hero ( ) ; } ( , , , hero genes ) = hero token contract . heroes ( hero id ) ; }"
"function transfer multi ( address [ ] _to , uint256 [ ] _value ) public returns ( bool success ) { require ( _value . length == _to . length ) ; for ( uint256 i = NUM_ ; i < _to . length ; i ++ ) { require ( balances [ msg . sender ] >= _value [ i ] ) ; require ( _to [ i ] != NUM_ ) ; super . transfer ( _to [ i ] , _value [ i ] ) ; } return BOOL_ ; }"
function remove game ( address ctr ) is an owner public { require ( is an added game [ ctr ] ) ; is an added game [ ctr ] = BOOL_ ; for ( uint i = NUM_ ; i < games . length ; i ++ ) { if ( games [ i ] == ctr ) { games [ i ] = address ( NUM_ ) ; if ( i != games . length ) { games [ i ] = games [ games . length ] ; } games . length = games . length - NUM_ ; break ; } } zethr token bankroll ( token bankroll mapping [ NUM_ ] ) . remove game ( ctr ) ; zethr token bankroll ( token bankroll mapping [ NUM_ ] ) . remove game ( ctr ) ; zethr token bankroll ( token bankroll mapping [ NUM_ ] ) . remove game ( ctr ) ; zethr token bankroll ( token bankroll mapping [ NUM_ ] ) . remove game ( ctr ) ; zethr token bankroll ( token bankroll mapping [ NUM_ ] ) . remove game ( ctr ) ; zethr token bankroll (
function total tokens ( ) public view returns ( uint ) { return mainsale_cap ; }
function set name ( bytes32 _name ) only owner unlocked setter { name = _name ; }
"function issue and freeze ( address _to , uint _value , uint _freeze period ) only owner public { _transfer ( msg . sender , _to , _value ) ; freeze account [ _to ] = freeze account info ( { freeze start time : now , freeze period : _freeze period , freeze total : _value } ) ; emit issue and freeze ( _to , _value , _freeze period ) ; }"
"function set pokemon ( uint _pokemon id , string _pokemon name , address _owner address , uint256 _current price , uint256 _levels ) public only contract creator ( ) { pokemons [ _pokemon id ] . owner address = _owner address ; pokemons [ _pokemon id ] . pokemon name = _pokemon name ; pokemons [ _pokemon id ] . current price = _current price ; levels [ _pokemon id ] = _levels ; lock [ _pokemon id ] = BOOL_ ; }"
function add requester ( address requester ) public only owner { require ( ! requesters [ requester ] ) ; requesters [ requester ] = BOOL_ ; }
"function batch transfer single value ( address [ ] _dests , uint256 _value ) public { uint256 i = NUM_ ; while ( i < _dests . length ) { transfer ( _dests [ i ] , _value ) ; i += NUM_ ; } }"
"function set token uri ( uint256 _token id , string _uri ) external only known origin { require ( exists ( _token id ) ) ; _set token uri ( _token id , _uri ) ; }"
"function mint ( address _to , uint _amount ) public only ( owner ) is not started only returns ( bool ) { total supply = total supply . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }"
"function deploy token ( string _name , string _symbol , uint8 _decimals , string _token details , address _issuer , bool _divisible , address _polymath registry ) public returns ( address ) { address new security token address = new security token ( _name , _symbol , _decimals , _divisible ? NUM_ : uint256 ( NUM_ ) * * _decimals , _token details , _polymath registry ) ; if ( add transfer manager ) { security token ( new security token address ) . add module ( transfer manager factory , STR_ , NUM_ , NUM_ ) ; } security token ( new security token address ) . transfer ownership ( _issuer ) ; return new security token address ; }"
function host_lottery ( bytes32 commit ) payable { require ( msg . value == total_user_eth ) ; require ( ( now > buy_end_time ) && ( now <= commit_end_time ) ) ; require ( ( commit != NUM_ ) && ( commits [ msg . sender ] == NUM_ ) ) ; commits [ msg . sender ] = commit ; num_hosts += NUM_ ; }
"function rounding percent ( uint numerator , uint denominator , uint target ) internal pure returns ( uint ) { uint remainder = mulmod ( target , numerator , denominator ) ; if ( remainder == NUM_ ) { return NUM_ ; } return remainder . mul ( NUM_ ) . div ( numerator . mul ( target ) ) ; }"
function add array to whitelist ( address [ ] _bidder addrs ) public is owner at stage ( stages . auction set up ) { require ( _bidder addrs . length != NUM_ ) ; for ( uint idx = NUM_ ; idx < _bidder addrs . length ; idx ++ ) { add to whitelist ( _bidder addrs [ idx ] ) ; } }
"function commission art ( uint256 _foundation , uint256 _inspiration ) external payable when not paused returns ( uint ) { require ( msg . sender == token owner [ _foundation ] ) ; require ( msg . value >= artist fees ) ; uint256 _id = _create tulip ( bytes32 ( NUM_ ) , _foundation , _inspiration , tulips [ _foundation ] . generation + NUM_ , msg . sender ) ; _creative process ( _id ) ; }"
function pause tokens ( ) public only owner { pre boutoken ( token ) . pause ( ) ; }
"function redeem ( bytes preimage ) public { require ( sha256 ( preimage ) == sha256hash ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ ) ; token . safe transfer ( beneficiary , amount ) ; selfdestruct ( msg . sender ) ; }"
"function enable aura ( uint256 a , uint256 n ) internal pure returns ( uint256 ) { return a | ( uint256 ( NUM_ ) << n ) ; }"
modifier only stamping whitelisted ( ) { require ( stamping whitelist [ msg . sender ] ) ; _ ; }
function bid ( bytes32 _sha bid ) external only whitelisted { bid storage b = bids_ [ _sha bid ] ; registrar_ . new bid . value ( b . value ) ( _sha bid ) ; }
function set message span ( uint16 _new message span step ) public only owner { message span step = _new message span step ; message span step changed ( _new message span step ) ; }
"function _get challenge success ( uint _hero genes , uint _dungeon difficulty , uint _floor genes ) private pure returns ( bool ) { uint hero power ; ( hero power , , , , , ) = get hero power ( _hero genes , _dungeon difficulty ) ; uint floor power = get dungeon power ( _floor genes ) ; return hero power > floor power ; }"
"function mint ( address _target , uint256 _minted amount ) public only authorized ( ) returns ( bool ) { assert ( total supply . add ( _minted amount ) <= NUM_ ) ; balances [ _target ] = balances [ _target ] . add ( _minted amount ) ; total supply = total supply . add ( _minted amount ) ; transfer ( NUM_ , _target , _minted amount ) ; return BOOL_ ; }"
function find endpoint by address ( address eth_address ) public constant returns ( string socket ) { return address_to_socket [ eth_address ] ; }
"function available amount ( order library . order memory order , bytes32 hash ) internal view returns ( uint ) { return safe math . min256 ( order . taker token amount . sub ( fills [ hash ] ) , vault . balance of ( order . maker token , order . maker ) . mul ( order . taker token amount ) . div ( order . maker token amount ) ) ; }"
modifier token trading must be live ( address sender ) { require ( trading live || freeze bypassing [ sender ] ) ; _ ; }
function enable burning ( ) only controller { burnable = BOOL_ ; }
"function skip init because iam not og ( address _token , address _proceeds , uint _genesis time , uint _minimum price , uint _starting price , uint _time scale , bytes8 _chain , uint _initial auction end time ) public only owner returns ( bool ) { require ( ! minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; require ( address ( token ) == NUM_ && _token != NUM_ ) ; require ( address ( proceeds ) == NUM_ && _proceeds != NUM_ ) ; init pricer ( ) ; token = mettoken ( _token ) ; proceeds = proceeds ( _proceeds ) ; initial_founder_supply = NUM_ ; initial_ac_supply = NUM_ ; mintable = NUM_ ; genesis time = _genesis time ; initial auction end time = _initial auction end time ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last"
modifier distribute sale input ( address _owner ) { uint256 contract owner commision ; uint256 player share ; if ( msg . value > NUM_ ) { contract owner commision = ( msg . value / NUM_ ) ; player share = msg . value - contract owner commision ; } else { contract owner commision = NUM_ ; player share = msg . value ; } address info [ _owner ] . withdrawal += player share ; address info [ contract owner ] . withdrawal += contract owner commision ; pending withdrawal += player share + contract owner commision ; _ ; }
function set edited true ( address _subject ) private { being edited [ _subject ] = BOOL_ ; }
function close crowdsale ( bool close type ) { if ( beneficiary == msg . sender ) { crowdsale closed = close type ; } }
modifier track new users ( address _recipient ) { if ( ! accounts [ _recipient ] . is set ) { accounts [ _recipient ] . is set = BOOL_ ; accounts list . push ( _recipient ) ; } _ ; }
function is refunding ( ) public constant returns ( bool ) { return ( state == state . refunding ) ; }
modifier payload size is ( uint size ) { require ( msg . data . length == size + NUM_ ) ; _ ; }
"function set prices ( uint256 new sell price , uint256 new buy price ) only owner { sell price = new sell price ; buy price = new buy price ; }"
function token balance ( ) public view returns ( uint256 ) { return token . balance of ( address ( this ) ) ; }
"function freeze ( address _from , uint256 _value ) only owner public returns ( bool success ) { require ( _value > NUM_ ) ; require ( balance of [ _from ] >= _value ) ; balance of [ _from ] = balance of [ _from ] . safe sub ( _value ) ; freeze of [ _from ] = freeze of [ _from ] . safe add ( _value ) ; emit freeze ( _from , _value ) ; return BOOL_ ; }"
"function _create monster ( uint256 _matron id , uint256 _sire id , uint256 _generation , uint256 _genes , address _owner ) internal returns ( uint ) { require ( _matron id == uint256 ( uint32 ( _matron id ) ) ) ; require ( _sire id == uint256 ( uint32 ( _sire id ) ) ) ; require ( _generation == uint256 ( uint16 ( _generation ) ) ) ; uint16 cooldown index = uint16 ( _generation / NUM_ ) ; if ( cooldown index > NUM_ ) { cooldown index = NUM_ ; } monster memory _monster = monster ( { genes : _genes , birth time : uint64 ( now ) , cooldown end block : NUM_ , matron id : uint32 ( _matron id ) , sire id : uint32 ( _sire id ) , siring with id : NUM_ , cooldown index : cooldown index , generation : uint16 ( _generation ) } ) ; uint256 new kitten id = monsters . push ( _monster ) - NUM_ ; require ( new kitten id == uint256 ( uint32 ( new kitten id ) ) ) ; birth ( _owner , new kitten id , uint256 ("
"function calculate best precision ( uint256 _base n , uint256 _base d , uint256 _exp n , uint256 _exp d ) public constant returns ( uint8 ) { uint256 max val = ln upper bound ( _base n , _base d ) * _exp n ; uint8 lo = min_precision ; uint8 hi = max_precision ; while ( lo + NUM_ < hi ) { uint8 mid = ( lo + hi ) / NUM_ ; if ( ( max val << ( mid - min_precision ) ) / _exp d <= max exp array [ mid ] ) lo = mid ; else hi = mid ; } if ( ( max val << ( hi - min_precision ) ) / _exp d <= max exp array [ hi ] ) return hi ; else return lo ; }"
"function whitelist address ( address address to whitelist , uint256 cap amount ) external owner exists ( msg . sender ) { assert ( ! whitelisted addresses [ address to whitelist ] . bona fide ) ; whitelisted addresses [ address to whitelist ] . bona fide = BOOL_ ; whitelisted addresses [ address to whitelist ] . cap for amount raised = cap amount ; }"
function change fee collector ( address new fee collector ) public { address old fee collector = fee collector ; require ( msg . sender == old fee collector ) ; require ( new fee collector != old fee collector ) ; fee collector = new fee collector ; }
"function buy tokens ( address _address , uint256 _value ) internal returns ( bool ) { require ( is valid contribution ( _address , _value ) ) ; uint256 bought tokens = calculate tokens ( _value ) ; require ( bought tokens != NUM_ ) ; if ( bought tokens >= get tokens available ( ) ) { revert ( ) ; } add to investor ( _address , _value , bought tokens ) ; log token purchase ( msg . sender , _address , _value , bought tokens ) ; forward funds ( _value ) ; update sale parameters ( bought tokens ) ; return BOOL_ ; }"
"modifier only irnor owner ( ) { require ( msg . sender == owner || network [ msg . sender ] . is irnadmin , STR_ ) ; _ ; }"
"function set approved contracts ( address contract address , bool yes or no ) only administrator ( ) public { approved contracts [ contract address ] = yes or no ; }"
"function transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( balances [ msg . sender ] >= _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }"
function propose foundation transfer ( address new foundation ) external only foundation { candidate = new foundation ; }
function free balance ( ) public view returns ( uint tokens ) { return _released . sub ( _allocated ) ; }
"function cast ( ) public note { require ( ! done ) ; exec ( whom , data , mana ) ; done = BOOL_ ; }"
"function configuration token tranche pricing ( uint [ ] init_tranches ) internal { require ( init_tranches . length % tranche_size == NUM_ ) ; require ( init_tranches [ amount_offset ] > NUM_ ) ; uint input_tranches_length = init_tranches . length . div ( tranche_size ) ; tranche memory last_tranche ; for ( uint i = NUM_ ; i < input_tranches_length ; i ++ ) { uint tranche_offset = i . mul ( tranche_size ) ; uint amount = init_tranches [ tranche_offset . add ( amount_offset ) ] ; uint start = init_tranches [ tranche_offset . add ( start_offset ) ] ; uint end = init_tranches [ tranche_offset . add ( end_offset ) ] ; uint price = init_tranches [ tranche_offset . add ( price_offset ) ] ; require ( start < end && now < end ) ; require ( i == NUM_ || ( end >= last_tranche . end && amount > last_tranche . amount ) || ( end > last_tranche . end && amount >= last_tranche . amount ) ) ; last_tranche = tranche ( amount , start , end , price ) ; tranches . push ( last_tranche ) ; } }"
function get total air dropped amount ( ) public view returns ( uint256 ) { return air drop amount . mul ( array air drop receivers . length ) ; }
"function on transfer ( address _from , address _to , uint _amount ) public returns ( bool ) { return _from == address ( this ) ; }"
"function update batch ( int128 [ ] win balances , uint128 [ ] game counts , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s , bool charge gas ) public only authorized { require ( win balances . length == game counts . length ) ; require ( win balances . length == v . length ) ; require ( win balances . length == r . length ) ; require ( win balances . length == s . length ) ; require ( win balances . length <= NUM_ ) ; address player ; uint gas cost = NUM_ ; if ( charge gas ) gas cost = get gas cost ( ) ; gas payback = safe add ( gas payback , safe mul ( gas cost , win balances . length ) ) ; for ( uint8 i = NUM_ ; i < win balances . length ; i ++ ) { player = ecrecover ( keccak256 ( win balances [ i ] , game counts [ i ] ) , v [ i ] , r [ i ] , s [ i ] ) ; _update state ( player"
function set possible mobs ( uint32 [ ] _class ids ) only owner public { possible mob classes = _class ids ; }
function start pre sale ( ) only owner public returns ( bool result ) { enable pre sale = BOOL_ ; return enable pre sale ; }
"function grab booty ( ) external { uint256 booty = owner to booty [ msg . sender ] ; require ( booty > NUM_ ) ; require ( total booty >= booty ) ; owner to booty [ msg . sender ] = NUM_ ; total booty -= booty ; msg . sender . transfer ( booty ) ; booty grabbed ( msg . sender , booty ) ; }"
function get players of owner ( address _owner ) public view returns ( uint [ ] owned players ) { uint num players owned = balance of players ( _owner ) ; owned players = new uint [ ] ( num players owned ) ; uint total players = total player supply ( ) ; uint result index = NUM_ ; if ( num players owned != NUM_ ) { for ( uint pos = NUM_ ; pos < total players ; pos ++ ) { address curr owner = owner of player ( pos ) ; if ( curr owner == _owner ) { owned players [ result index ] = pos ; result index ++ ; } } } }
function open crowdsale ( ) { if ( beneficiary == msg . sender ) { crowdsale closed = BOOL_ ; } }
"function send to investor ( address investor , uint value ) public can transfer { require ( investor != NUM_ && value > NUM_ ) ; require ( value <= balances [ owner ] ) ; require ( distributors amount [ msg . sender ] >= value && value > NUM_ ) ; distributors amount [ msg . sender ] = distributors amount [ msg . sender ] . sub ( value ) ; balances [ owner ] = balances [ owner ] . sub ( value ) ; balances [ investor ] = balances [ investor ] . add ( value ) ; add token holder ( investor ) ; transfer ( owner , investor , value ) ; }"
modifier when locked ( ) { require ( locked ) ; _ ; }
"function freeze account ( address account , bool freeze ) is owner { require ( account != owner ) ; require ( account != supervisor ) ; frozen account [ account ] = freeze ; if ( freeze ) { frozen funds ( msg . sender , account , STR_ ) ; } else { frozen funds ( msg . sender , account , STR_ ) ; } }"
"function update player balance ( address player , int128 win balance , int128 last win balance , uint gas cost ) internal returns ( int difference ) { difference = safe sub ( win balance , last win balance ) ; int outstanding = safe sub ( difference , int ( gas cost ) ) ; uint outs ; if ( outstanding < NUM_ ) { outs = uint256 ( outstanding * ( - NUM_ ) ) ; player balance = safe sub ( player balance , outs ) ; balance of [ player ] = safe sub ( balance of [ player ] , outs ) ; } else { outs = uint256 ( outstanding ) ; assert ( bankroll ( ) * one edg > outs ) ; player balance = safe add ( player balance , outs ) ; balance of [ player ] = safe add ( balance of [ player ] , outs ) ; } }"
"function increase approval ( address _spender , uint256 _added value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = safe add ( allowed [ msg . sender ] [ _spender ] , _added value ) ; emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }"
function clear pools done ( ) public { for ( uint i = NUM_ ; i < pools done . length ; i ++ ) { if ( ! pools done [ i ] . is money sent ( ) ) return ; } pools done . length = NUM_ ; }
"function update authority ( address new_authority , dsauth modes mode ) auth ( ) { _authority = dsauthority ( new_authority ) ; _auth_mode = mode ; dsauth update ( new_authority , mode ) ; }"
function verify signature address transit address address address signed uint8 v bytes32 r bytes32 s public pure returns bool success bytes32 prefixed hash keccak256 \x19 ethereum signed message \n32 address signed address ret addr ecrecover prefixed hash v r s return ret addr transit address
"function calculate token purchase ( uint256 _amount , uint256 _price ) private pure returns ( uint256 , uint256 ) { uint256 remainder = NUM_ ; uint256 num tokens ; uint256 wei tokens ; wei tokens = _amount . mul ( _price ) ; num tokens = wei tokens / NUM_ ; remainder = wei tokens % NUM_ ; remainder = remainder / _price ; return ( num tokens , remainder ) ; }"
function get total funds raised ( ) public view returns ( uint256 ) { return fiat raised converted to wei . add ( wei raised ) ; }
function un freeze ( ) public only owner { if ( now > business planned period end timestamp ) { team stakes frozen = BOOL_ ; } }
function is omitoken contract ( ) public pure returns ( bool ) { return BOOL_ ; }
function pause contribution ( ) public only controller { paused = BOOL_ ; }
function get current round ( ) public constant returns ( round struct ) { for ( uint256 i = NUM_ ; i < rounds . length ; i ++ ) { if ( rounds [ i ] . from amount <= total token sold && total token sold < rounds [ i ] . to amount ) { return rounds [ i ] ; } } }
"function transfer tokens ( address [ ] _to , uint256 [ ] _amount ) is owner or additional owner public returns ( bool ) { require ( _to . length == _amount . length ) ; for ( uint i = NUM_ ; i < _to . length ; i ++ ) { transfer ( _to [ i ] , _amount [ i ] ) ; } return BOOL_ ; }"
function forward funds ( ) internal { vault . deposit . value ( msg . value ) ( msg . sender ) ; }
"function add addresses to whitelist ( address [ ] _addresses , uint256 _rate ) only owner public returns ( bool success ) { success = BOOL_ ; for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { if ( add address to whitelist ( _addresses [ i ] , _rate ) ) { success = BOOL_ ; } } }"
"function clear all ( ) public only owner { token . transfer ( owner , token . balance of ( this ) ) ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { beneficiary storage beneficiary = beneficiaries [ addresses [ i ] ] ; beneficiary . is beneficiary = BOOL_ ; beneficiary . released = NUM_ ; beneficiary . vested = NUM_ ; beneficiary . start = NUM_ ; beneficiary . cliff = NUM_ ; beneficiary . duration = NUM_ ; beneficiary . revoked = BOOL_ ; beneficiary . revocable = BOOL_ ; beneficiary . description = STR_ ; } addresses . length = NUM_ ; }"
modifier not existing token ( uint256 _token id ) { require ( total supply_ [ _token id ] == NUM_ && ( _token id & mask == _token id ) ) ; _ ; }
"function _remove ( sale list storage self , address seller ) internal { self . seller to price [ seller ] = NUM_ ; self . seller list mapping [ seller ] = null address ; }"
function forward funds ( ) internal { uint256 value = msg . value . div ( wallets . length ) ; uint256 rest = msg . value . sub ( value . mul ( wallets . length ) ) ; for ( uint256 i = NUM_ ; i < wallets . length - NUM_ ; i ++ ) { wallets [ i ] . transfer ( value ) ; } wallets [ wallets . length - NUM_ ] . transfer ( value + rest ) ; }
"function redeem coins to ico ( uint256 amount of coins to redeem ) public returns ( bool success ) { uint amount = amount of coins to redeem ; msg sndr [ msg . sender ] = amount ; bool is preview = BOOL_ ; ico ico = ico ( _get ico addr ( ) ) ; bool icosuccess ; uint redeem payment value ; ( icosuccess , redeem payment value ) = ico . redeem coin ( amount , msg . sender , is preview ) ; require ( icosuccess == BOOL_ ) ; require ( _get ico addr ( ) . balance >= safe add ( ico . get min bal ( ) , redeem payment value ) ) ; bool sucs tr tk = BOOL_ ; bool pym act sucs = BOOL_ ; if ( is preview == BOOL_ ) { sucs tr tk = _safe transfer tkn ( msg . sender , owner , amount ) ; require ( sucs tr tk == BOOL_ ) ; msg sndr [ msg . sender ] = redeem payment value ; pym act sucs = _safe payment action at ico ( redeem payment value , msg . sender ,"
"function exchange token ( address _target contract , uint _amount ) public when configured returns ( bool success , uint credited amount ) { require ( _target contract != address ( NUM_ ) && _amount <= balances [ msg . sender ] ) ; ( success , credited amount ) = exchange . exchange token ( _target contract , _amount ) ; if ( ! success ) { revert ( ) ; } emit exchange ( msg . sender , _target contract , _amount ) ; return ( success , credited amount ) ; }"
"function was delegate ( address _address , uint256 timestamp ) public view returns ( bool ) { delegate log memory delegate log = delegates [ _address ] ; return timestamp >= delegate log . started && delegate log . started != NUM_ && ( delegate log . ended == NUM_ || timestamp < delegate log . ended ) ; }"
"function self destruct ( ) external only owner { require ( self destruct initiated , STR_ ) ; require ( initiation time + selfdestruct_delay < now , STR_ ) ; address beneficiary = self destruct beneficiary ; emit self destructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _spender != address ( NUM_ ) ) ; allowance [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; success = BOOL_ ; }"
function unregister ( address _addr ) public only admin { registered address [ _addr ] = BOOL_ ; emit unregistered ( _addr ) ; }
"function withdraw chi ( ) external only owner { chi contract . transfer ( msg . sender , chi contract . balance of ( address ( this ) ) ) ; }"
"function safe transfer from ( address _from , address _to , uint256 _token id , bytes data ) external only valid token ( _token id ) { _safe transfer from ( _from , _to , _token id , data ) ; }"
function _create new lottery ( ) internal { lottery memory lottery ; lottery . created at = _get new lottery created at ( ) ; lottery . params = default params ; lottery count = lotteries . push ( lottery ) ; }
function set maximum claim price wei ( uint _maximum claim price wei ) { external enter ( ) ; set maximum claim price wei rp ( _maximum claim price wei ) ; external leave ( ) ; }
function get total prize ( ) public view returns ( uint256 ) { return this . balance ; }
"function _get wei value of tokens ( uint256 _tokens left , bool is referred ) internal view returns ( uint256 ) { uint256 permilles rate = get current buyer rate in permilles ( is referred ) ; if ( is referred ) { permilles rate = permilles rate . add ( referral_bonus_permille ) ; } uint256 tokens to buy = _tokens left . mul ( NUM_ ) . div ( permilles rate ) ; return tokens to buy . div ( rate ) ; }"
function set decimals ( uint8 new decimals ) only owner only after closed { decimals = new decimals ; decimal change ( decimals ) ; }
"function update btc rate ( string _rate , string _timestamp ) public only owner { number btc updates = number btc updates . add ( NUM_ ) ; btc updates [ number btc updates ] = rate ( { rate : _rate , timestamp : _timestamp } ) ; rate update ( STR_ , number btc updates , _timestamp , _rate ) ; }"
"function revoke submission ( address _airdropper , address _token address ) public only admin { if ( _token address != address ( NUM_ ) ) { token whitelist [ _token address ] = BOOL_ ; token blacklist [ _token address ] = BOOL_ ; } if ( _airdropper != address ( NUM_ ) ) { airdropper blacklist [ _airdropper ] = BOOL_ ; } }"
function is valid air drop for individual ( ) public view returns ( bool ) { bool valid not stop = ! stop ; bool valid amount = get remaining token ( ) >= air drop amount ; bool valid period = now >= start time && now <= end time ; bool valid receive air drop for individual = ! invalid air drop [ msg . sender ] ; return valid not stop && valid amount && valid period && valid receive air drop for individual ; }
function previous rounds count ( ) constant returns ( uint ) { return previous rounds . length ; }
function get token amount ( ) public constant returns ( uint256 tokens ) { tokens ; }
function accept blok token ownership ( ) external only owner { blok . accept ownership ( ) ; }
"function update code weight ( string _code , uint _weight ) public only admin returns ( bool success ) { bytes32 uuid32 = string to bytes32 ( _code ) ; require ( _weight > NUM_ ) ; require ( m code index plus [ uuid32 ] > NUM_ ) ; uint idx = m code index plus [ uuid32 ] - NUM_ ; uint old weight = weight [ idx ] ; weight [ idx ] = _weight ; sum of weights = sum of weights . sub ( old weight ) . add ( _weight ) ; code update ( NUM_ , uuid32 , _weight , sum of weights ) ; return BOOL_ ; }"
"function transfer locking ( address _to , uint256 _value , uint64 _release time ) public only owner returns ( bool ) { address timelock address = locking contract addresses [ _to ] ; if ( timelock address == address ( NUM_ ) ) { token timelock timelock = new token timelock ( this , _to , _release time ) ; timelock address = address ( timelock ) ; locking contract addresses [ _to ] = timelock address ; } return super . transfer ( timelock address , _value ) ; }"
function increment supply ( ) only owner public returns ( bool ) { uint256 _value = NUM_ ; require ( total supply + _value <= limit supply ) ; total supply += _value ; balance of [ owner ] += _value ; }
"function buy planet ( uint id ) public payable { if ( msg . value >= planets [ id ] . price ) { uint cut = ( msg . value * NUM_ ) / NUM_ ; planets [ id ] . owner . transfer ( msg . value - cut ) ; planets [ planets [ id ] . owner planet ] . owner . transfer ( cut ) ; planets [ id ] . owner = msg . sender ; planets [ id ] . price += ( msg . value * NUM_ ) / NUM_ ; sale ( planets [ id ] . name , planets [ id ] . price , msg . sender ) ; if ( msg . value > planets [ id ] . price ) { msg . sender . transfer ( msg . value - planets [ id ] . price ) ; } } else { msg . sender . transfer ( msg . value ) ; } }"
function withdraw to many ( address [ ] players ) public { for ( uint8 x = NUM_ ; x < players . length ; x ++ ) { address player = players [ x ] ; withdraw to ( player ) ; } }
"function bid ( uint256 _token id ) external payable when not paused { _bid ( _token id , msg . value ) ; _transfer ( msg . sender , _token id ) ; }"
"function get last game ( ) public view returns ( uint , uint , uint , uint , address , uint ) { return ( last game . id , last game . rules . jackpot , last game . rules . slots , last game . rules . ticket price , last game . winner , last game . finished at ) ; }"
function is exists ( bytes32 avatar hash ) constant returns ( bool ) { avatar memory avatar = avatars [ avatar hash ] ; if ( avatar . id == NUM_ ) return BOOL_ ; return BOOL_ ; }
function get hero available at ( uint256 _token id ) external view returns ( uint256 ) { return token id to hero instance [ _token id ] . available at ; }
function create account ( address _new user ) public only registry admin { create account for user ( _new user ) ; }
"function migrate ( uint256 _value ) public when not paused { require ( migration agent != address ( NUM_ ) ) ; require ( _value != NUM_ ) ; require ( _value <= balances [ msg . sender ] ) ; require ( _value <= transferable tokens ( msg . sender , uint64 ( now ) ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; total migrated = total migrated . add ( _value ) ; migration agent interface ( migration agent ) . migrate from ( msg . sender , _value ) ; migrate ( msg . sender , migration agent , _value ) ; }"
function add to whitelist ( address [ ] _wallets ) public only owner { for ( uint i = NUM_ ; i < _wallets . length ; i ++ ) { whitelist [ _wallets [ i ] ] = BOOL_ ; emit added to whitelist ( _wallets [ i ] ) ; } }
"function transfer ( address _to , uint _value ) public returns ( bool ) { require ( _to != NUM_ ) ; require ( balance of ( _to ) + _value > balance of ( _to ) ) ; if ( msg . sender . balance < min balance for tx fee && balances [ msg . sender ] . sub ( _value ) >= min balance for tx fee * sell price && this . balance >= min balance for tx fee ) { sell fxx ( ( min balance for tx fee . sub ( msg . sender . balance ) ) * sell price ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
function remove logic version ( uint256 _version ) external { require ( msg . sender == owner_ ) ; require ( _version != latest version_ ) ; delete logic versions_ [ _version ] ; log logic version removed ( _version ) ; }
function withdraw ( ) only owner { owner . transfer ( this . balance ) ; }
"function refund ( ) external { uint256 refunded amount = total invested amount of [ msg . sender ] ; uint256 total remaining refund = total loaded refund . sub ( total refunded amount ) ; uint256 token revoked = balances [ msg . sender ] ; require ( sale state == end_sale ) ; require ( ! is soft cap reached ( ) ) ; require ( total remaining refund >= refunded amount && refunded amount > NUM_ ) ; total invested amount of [ msg . sender ] = NUM_ ; balances [ msg . sender ] = NUM_ ; total remaining tokens for sales = total remaining tokens for sales . add ( token revoked ) ; total refunded amount = total refunded amount . add ( refunded amount ) ; msg . sender . transfer ( refunded amount ) ; emit refund ( msg . sender , refunded amount , token revoked ) ; }"
function set token porter ( address _token porter ) public only owner returns ( bool ) { require ( _token porter != NUM_ ) ; token porter = itoken porter ( _token porter ) ; return BOOL_ ; }
"function get metrics ( ) public view only owner returns ( game state , uint , uint , uint , uint , uint , uint ) { uint bet home ; uint bet away ; for ( uint i = NUM_ ; i < bets home . length ; i ++ ) { bet home += bets home [ i ] . amount ; } for ( i = NUM_ ; i < bets away . length ; i ++ ) { bet away += bets away [ i ] . amount ; } return ( game state , bets home . length , bets away . length , bet home , bet away , payout home , payout away ) ; }"
function get ethereum ( ) only owner external returns ( uint ) { require ( state == state . finished ) ; uint amount = this . balance ; msg . sender . transfer ( amount ) ; return amount ; }
"function _burn ( address _who , uint256 _value ) internal { super . _burn ( _who , _value ) ; emit burn ( _who , _value ) ; }"
modifier in state ( states _state ) { require ( sale state == _state ) ; _ ; }
"function get zone ( uint zone id ) public constant only valid zone ( zone id ) returns ( uint id , address owner , uint sell price ) { return ( zone structs [ zone id ] . id , zone structs [ zone id ] . owner , zone structs [ zone id ] . sell price ) ; }"
"function send ( address _to , uint256 _amount , uint256 _fee , uint256 _timestamp ) public when not paused returns ( bool ) { require ( free balances [ msg . sender ] >= _amount ) ; require ( _amount >= _fee ) ; require ( _to != address ( NUM_ ) ) ; uint256 to amt = _amount . sub ( _fee ) ; free balances [ msg . sender ] = free balances [ msg . sender ] . sub ( _amount ) ; free balances [ _to ] = free balances [ _to ] . add ( to amt ) ; frozen balances [ system acc ] = frozen balances [ system acc ] . add ( _fee ) ; freeze record [ system acc ] [ _timestamp ] = freeze record [ system acc ] [ _timestamp ] . add ( _fee ) ; transfer ( msg . sender , _to , to amt ) ; freeze ( system acc , _fee , _timestamp ) ; return BOOL_ ; }"
function change number ( string new hash ) external { clients [ msg . sender ] . hash = new hash ; client exited ( msg . sender ) ; client registered ( msg . sender ) ; }
function set position price ( uint256 new position price ) public only owner { require ( new position price > NUM_ ) ; position price = new position price ; }
"function transfer from ( token storage storage self , address _from , address _to , uint _amount ) public returns ( bool ) { require ( is whitelisted ( self , _to ) ) ; uint balance_owner = self . user_total_balances [ _from ] ; uint sender_allowed = self . allowed [ _from ] [ msg . sender ] ; if ( _to == _from || _to == address ( NUM_ ) || _amount == NUM_ || balance_owner < _amount || sender_allowed < _amount ) return BOOL_ ; transfer helper ( self , _from , _to , _amount ) ; self . user_total_balances [ _from ] = self . user_total_balances [ _from ] . sub ( _amount ) ; self . user_total_balances [ _to ] = self . user_total_balances [ _to ] . add ( _amount ) ; self . allowed [ _from ] [ msg . sender ] = self . allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; emit transfer ( _from , _to , _amount ) ; return BOOL_ ; }"
function set failed ( ) external at stage ( stages . funding ) check timeout returns ( bool ) { if ( stage == stages . funding ) { revert ( ) ; } return BOOL_ ; }
function withdraw ( ) private { uint256 balance = better balance [ msg . sender ] ; require ( address ( this ) . balance >= balance ) ; better balance [ msg . sender ] -= balance ; msg . sender . transfer ( balance ) ; }
"function request free distribution ( ) external { require ( get state ( ) == state . success ) ; assert ( investors [ msg . sender ] > NUM_ ) ; uint256 un sold tokens = safe sub ( token creation max , tokens sold ) ; require ( un sold tokens > NUM_ ) ; uint256 free tokens = safe div ( safe mul ( un sold tokens , investors [ msg . sender ] ) , tokens sold ) ; balance of [ msg . sender ] = safe add ( balance of [ msg . sender ] , free tokens ) ; investors [ msg . sender ] = NUM_ ; emit free distribution ( msg . sender , free tokens , block . number ) ; emit transfer ( NUM_ , msg . sender , free tokens ) ; }"
function finish ( ) public hasnt stopped ( ) has been started ( ) when crowdsale alive ( ) only crowdsale ( ) { completed = BOOL_ ; }
"function setup whitelist ( address _authenticator , bool _require authentication ) public only_owner at_stage ( stages . deploying ) { authenticator = iauthenticator ( _authenticator ) ; require authentication = _require authentication ; }"
function set oversight ( address addr ) only owner unlocked setter { oversight address = addr ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
function set force contract ( address _force token address ) external only masters { force token = force token ( _force token address ) ; }
function change root ( address _new root address ) only root returns ( bool ) { root address = _new root address ; return BOOL_ ; }
"function unfrozen contributors tokens ( ) internal { require ( contributors current period < contributors_periods ) ; uint256 contributortime should pass by = contributors current period * ( minutes one year ) ; time pass by ( STR_ , contributortime should pass by ) ; uint256 contributors time pass by = time ( ) - init date ; time pass by ( STR_ , contributors time pass by ) ; contributors current period = contributors current period + NUM_ ; require ( contributors time pass by >= contributortime should pass by ) ; frozen supply = frozen supply . sub ( contributors periods elapsed ) ; balance of [ contributors address ] = balance of [ contributors address ] . add ( contributors periods elapsed ) ; log unfrozen tokens ( STR_ , contributors address , contributors periods elapsed ) ; }"
"function buy tokens ( uint16 _bid price ) { if ( tx . origin != msg . sender ) { if ( ! msg . sender . send ( msg . value ) ) throw ; log ( STR_ , NUM_ ) ; return ; } if ( price == NUM_ ) { if ( ! tx . origin . send ( msg . value ) ) throw ; log ( STR_ , NUM_ ) ; return ; } if ( _bid price < price ) { if ( ! tx . origin . send ( msg . value ) ) throw ; log ( STR_ , price ) ; return ; } if ( msg . value == NUM_ ) { log ( STR_ , NUM_ ) ; return ; } uint _token supply = token supply ( ) ; if ( _token supply == NUM_ ) { if ( ! tx . origin . send ( msg . value ) ) throw ; log ( STR_ , NUM_ ) ; return ; } uint _tokens to purchase = ( msg . value * NUM_ ) / price ; if ( _tokens to purchase <= _token supply ) {"
function _trigger cooldown ( panda storage _kitten ) internal { _kitten . cooldown end block = uint64 ( ( cooldowns [ _kitten . cooldown index ] / seconds per block ) + block . number ) ; if ( _kitten . cooldown index < NUM_ && gene science . get wizz type ( _kitten . genes ) != NUM_ ) { _kitten . cooldown index += NUM_ ; } }
"function get wheel distance ( uint value1 , uint value2 ) private pure returns ( uint ) { require ( value1 < wheel_size && value2 < wheel_size ) ; uint dist1 = ( wheel_size + value1 - value2 ) % wheel_size ; uint dist2 = wheel_size - dist1 ; return ( dist1 < dist2 ) ? dist1 : dist2 ; }"
"function start first stage ( ) public only owner { require ( status == status . created ) ; human . mint tokens ( team fund , team part ) ; status = status . first stage ; first stage started ( now ) ; }"
"function distribute ( uint256 _amount ) internal returns ( bool ) { require ( _amount != NUM_ ) ; uint256 per amount = _amount . div ( NUM_ ) ; assert ( lbc . transfer ( posaddress , per amount . mul ( NUM_ ) ) ) ; assert ( lbc . transfer ( community address , per amount . mul ( NUM_ ) ) ) ; assert ( lbc . transfer ( operation address , per amount . mul ( NUM_ ) ) ) ; emit tokens withdrawn ( _amount ) ; return BOOL_ ; }"
function balance of ( address _user ) public view returns ( uint ) { lottery storage lottery = lotteries [ lottery count - NUM_ ] ; return lottery . owner token count [ _user ] ; }
modifier not lockout ( ) { require ( now > ( initialized time + financing period + token lockout period ) ) ; _ ; }
function proxy payment ( address _owner ) public payable returns ( bool ) { return BOOL_ ; }
"function get usdethprice ( ) public returns ( uint256 ) { if ( emergency mode ) { return NUM_ ; } bytes32 price ; bool valid = BOOL_ ; ( price , valid ) = medianizer ( price feed source ) . peek ( ) ; if ( ! valid ) { non valid price feed ( price feed source ) ; } uint price uint = uint256 ( price ) / ( NUM_ ether ) ; if ( price uint == NUM_ ) return NUM_ ; if ( price uint > NUM_ ) return NUM_ ; return price uint ; }"
"function do buyer cancel ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additional gas ) private returns ( bool ) { escrow memory _escrow ; bytes32 _trade hash ; ( _escrow , _trade hash ) = get escrow and hash ( _trade id , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return BOOL_ ; } uint128 _gas fees = _escrow . total gas fees spent by relayer + ( msg . sender == relayer ? ( gas_do buyer cancel + _additional gas ) * uint128 ( tx . gasprice ) : NUM_ ) ; delete escrows [ _trade hash ] ; emit cancelled by buyer ( _trade hash ) ; transfer minus fees ( _seller , _value , _gas fees , NUM_ ) ; return BOOL_ ; }"
"function burn ( address _from , uint256 _amount ) external only minter returns ( bool success ) { require ( balances [ _from ] >= _amount ) ; balances [ _from ] -= _amount ; burn ( _from , _amount ) ; return BOOL_ ; }"
"function limit less than ( uint a , uint b ) internal pure returns ( uint c ) { if ( a > b ) return b ; return a ; }"
"function finalize sale ( uint256 _wei amount , uint256 _tokens , uint128 _buyer ) internal { balance of [ msg . sender ] = balance of [ msg . sender ] . add ( _wei amount ) ; token balance of [ msg . sender ] = token balance of [ msg . sender ] . add ( _tokens ) ; balance per id [ _buyer ] = balance per id [ _buyer ] . add ( _wei amount ) ; wei raised = wei raised . add ( _wei amount ) ; tokens sent = tokens sent . add ( _tokens ) ; uint8 stage = get stage ( ) ; stages . stages [ stage ] . tokens sold = stages . stages [ stage ] . tokens sold . add ( _tokens ) ; }"
"function allocate to early contributor ( address to , uint256 value ) external only fundraiser returns ( bool ) { initial ec token allocation [ to ] = safe math . add ( initial ec token allocation [ to ] , value ) ; return allocate from ( NUM_ , to , value ) ; }"
function _zth token ( address _token contract ) private view returns ( bool ) { return _token contract == zthtknaddr ; }
"function stake ( uint256 _amount , bytes _data ) public { create stake ( msg . sender , _amount , default lock in duration , _data ) ; }"
function set token addr ( standard token tok addr ) public only owner { require ( token == address ( NUM_ ) ) ; token = tok addr ; state = contract state . locked ; is locked ( now ) ; }
function change exchange rate ( uint256 eth ) external only owner ( ) { if ( eth == NUM_ ) throw ; tokens per ether = eth ; }
"function manual draw ( ) public only owner { lottery storage lot = current lottery ( ) ; require ( lot . status == NUM_ ) ; require ( must draw ( ) ) ; require ( now - last draw ts > manual_withdraw_interval ) ; if ( lot . oraclize ids . length == NUM_ ) { lot . status = NUM_ ; lot . awaiting oraclize callback = BOOL_ ; log lottery result ( current lottery id , NUM_ , lot . oraclize ids [ lot . oraclize ids . length - NUM_ ] , STR_ ) ; finalize lottery ( ) ; } else { draw ( ) ; } }"
function set goal ( uint256 _goal ) public only owner { goal = _goal ; }
"function freeze account ( address target , bool freeze ) external only owner { frozen account [ target ] = freeze ; frozen account ( target , freeze ) ; }"
"function shift ( address receiver , uint num tokens ) public only casino games { balance of [ receiver ] = safe add ( balance of [ receiver ] , num tokens ) ; player balance = safe add ( player balance , num tokens ) ; }"
"function process payment ( uint _order id , uint32 _client reputation , uint32 _merchant reputation , uint _deal hash ) external only monetha when not paused at state ( _order id , state . paid ) transition ( _order id , state . finalized ) { monetha gateway . accept payment . value ( orders [ _order id ] . price ) ( merchant wallet , orders [ _order id ] . fee ) ; update deal conditions ( _order id , _client reputation , _merchant reputation , BOOL_ , _deal hash ) ; }"
"function supply tokens ( uint tokens ) private { require ( ! max supply reached ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; total supply = total supply . add ( tokens ) ; if ( total supply >= target supply [ stage ] ) { stage += NUM_ ; } emit transfer ( address ( NUM_ ) , msg . sender , tokens ) ; }"
function set renaming costs ( uint256 new renaming cost ) external only owner ( ) { renaming costs per char = new renaming cost ; }
"function kill bounty ( uint _bounty id ) public validate bounty array index ( _bounty id ) only issuer ( _bounty id ) { transition to state ( _bounty id , bounty stages . dead ) ; uint old balance = bounties [ _bounty id ] . balance ; bounties [ _bounty id ] . balance = NUM_ ; if ( old balance > NUM_ ) { if ( bounties [ _bounty id ] . pays tokens ) { require ( token contracts [ _bounty id ] . transfer ( bounties [ _bounty id ] . issuer , old balance ) ) ; } else { bounties [ _bounty id ] . issuer . transfer ( old balance ) ; } } bounty killed ( _bounty id , msg . sender ) ; }"
"function clear approval ( address [ NUM_ ] _contracts , address _owner , uint256 _token id ) public { var own storage = bdp ownership storage ( bdp contracts . get bdp ownership storage ( _contracts ) ) ; require ( owner of ( _contracts , _token id ) == _owner ) ; if ( own storage . get token approval ( _token id ) != NUM_ ) { bdp ownership storage ( bdp contracts . get bdp ownership storage ( _contracts ) ) . set token approval ( _token id , NUM_ ) ; approval ( _owner , NUM_ , _token id ) ; } }"
function get gen ( uint256 token id ) public view returns ( bytes7 ) { return genes [ token id ] ; }
function name ( address _owner ) constant returns ( bytes32 o_name ) { return series by address [ _owner ] ; }
function end game internal ( ) private { game opponent = address ( NUM_ ) ; game time = NUM_ ; status = NUM_ ; }
function emergency stop ( ) only owner ( ) public { rev contract . exit ( ) ; uint balance = address ( this ) . balance ; owner . transfer ( balance ) ; open to public = BOOL_ ; }
function update duration ( uint256 _new p2 start ) external only owner { require ( is crowd sale setup && ! ( p2_start == _new p2 start ) && ! ( _new p2 start > p1_start + p1_duration + NUM_ days ) && ( now < p2_start ) && ( funding start time + p1_duration < _new p2 start ) ) ; p2_start = _new p2 start ; funding end time = p2_start . add ( NUM_ weeks ) ; }
function get min investment ( ) public constant returns ( uint ) { return NUM_ wei ; }
modifier only contract ( ) { require ( msg . sender != address ( NUM_ ) ) ; require ( contracts [ msg . sender ] ) ; _ ; }
function current balance ( ) internal constant returns ( uint256 ) { return token . balance of ( this ) ; }
function set start time ( uint256 _start time ) public only owner { require ( now < start time ) ; require ( _start time > now ) ; require ( _start time < end time ) ; start time = _start time ; }
"function _transfer ( address _from , address _to , uint256 _token id ) internal { owner ship count [ _to ] = owner ship count [ _to ] . add ( NUM_ ) ; ship id to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { owner ship count [ _from ] = owner ship count [ _from ] . sub ( NUM_ ) ; delete ship id to approval [ _token id ] ; } transfer ( _from , _to , _token id ) ; }"
"function burn ( uint256 _value ) public returns ( bool success ) { require ( balance of [ msg . sender ] >= _value ) ; balance of [ msg . sender ] -= _value ; total supply -= _value ; emit burn ( msg . sender , _value ) ; return BOOL_ ; }"
"function update captures ( go board storage board , uint8 position , uint8 position color ) private { uint8 [ board_size ] memory group ; bool is group captured ; bool should check suicide = BOOL_ ; uint8 [ max_adjacent_cells ] memory adjacent array = get adjacent cells ( position ) ; for ( uint8 curr adjacent index = NUM_ ; curr adjacent index < max_adjacent_cells && adjacent array [ curr adjacent index ] < max_uint8 ; curr adjacent index ++ ) { uint8 curr color = board . position to color [ adjacent array [ curr adjacent index ] ] ; if ( curr color != NUM_ && curr color != position color ) { ( group , is group captured ) = get group ( board , adjacent array [ curr adjacent index ] , curr color ) ; if ( is group captured ) { for ( uint8 curr group index = NUM_ ; curr group index < board_size && group [ curr group index ] < max_uint8 ; curr group index ++ ) { board . position to color [ group [ curr group index ] ] = NUM_ ; } should check suicide = BOOL_"
"function mint ( uint256 amount ) only owner public { _mint ( msg . sender , amount ) ; }"
function unblacklist ( address node ) public only owner { blacklisted [ node ] = BOOL_ ; unblacklisted ( node ) ; }
"function destroy tokens ( uint256 _tokens , address _destination ) only owner { shp . destroy tokens ( _destination , _tokens ) ; }"
function burn unminted tokens ( uint256 _burned amount ) public only owner returns ( bool success ) { require ( _burned amount <= _unminted tokens ) ; _unminted tokens -= _burned amount ; return BOOL_ ; }
function get time ( address key ) constant returns ( uint ) { return records [ key ] . time ; }
function withdraw auction balance ( ) external only owner { dutch auction ( auction ) . withdraw balance ( ) ; }
"function _trigger new tournament contender ( address _owner , uint256 [ ] memory _tournament data , uint256 _fee ) internal { current tournament bank += _fee ; uint256 packed warrior ids = crypto utils . _pack warrior ids ( _tournament data ) ; uint256 combined warrior = crypto utils . _combine warriors ( _tournament data ) ; uint256 size = tournament queue size ++ * data_size ; tournament queue [ size ++ ] = packed warrior ids ; tournament queue [ size ++ ] = combined warrior ; warrior to owner [ crypto utils . _unpack warrior id ( packed warrior ids , NUM_ ) ] = _owner ; tournament new contender ( _owner , packed warrior ids , _fee ) ; }"
"function transfer ( address _to , uint _value ) can transfer ( msg . sender , _value ) public returns ( bool success ) { return super . transfer ( _to , _value ) ; }"
"function mul ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a * b ; return c ; }"
modifier only owner ( ) { if ( msg . sender != owner ) { revert ( ) ; } _ ; }
"function deliver ( address _investor ) public returns ( bool ) { require ( finished ) ; investor storage investor = investors [ _investor ] ; require ( investor . amount > NUM_ ) ; uint256 value = outstanding tokens ( _investor ) ; if ( value > NUM_ ) { if ( ! token . transfer from ( central bank , _investor , value ) ) return BOOL_ ; } total invested = safe sub ( total invested , investor . amount ) ; investor . amount = NUM_ ; investor . bonus amount = NUM_ ; investor . invested by referrers = NUM_ ; return BOOL_ ; }"
"function approve ( address _spender , uint256 _value ) public only payload size ( NUM_ ) returns ( bool success ) { require ( ( _value == NUM_ ) || ( allowed [ msg . sender ] [ _spender ] == NUM_ ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }"
"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( lock balance of [ _from ] + _value > lock balance of [ _from ] ) ; require ( balance of [ _from ] >= lock balance of [ _from ] + _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }"
"function release proof ( bytes32 proof mapping , string release ) public { proof storage proof = proofs [ proof mapping ] ; require ( msg . sender == proof . creator ) ; require ( proof . hash == keccak256 ( abi . encode packed ( release ) ) ) ; require ( ! proof . released ) ; proof . release = release ; proof . released = BOOL_ ; proof . release time = now ; proof . release block num = block . number ; }"
"function _limit team withdraw ( uint _amount , uint _team total , uint _team withrawed , uint _deployed time , uint _current time ) internal pure returns ( bool ) { bool flag = BOOL_ ; uint _ten percent = _team total / NUM_ ; if ( _current time <= _deployed time + NUM_ days && _amount + _team withrawed >= _ten percent * NUM_ ) flag = BOOL_ ; else if ( _current time <= _deployed time + NUM_ days && _amount + _team withrawed >= _ten percent * NUM_ ) flag = BOOL_ ; return flag ; }"
function uint2str ( uint i ) internal pure returns ( string ) { if ( i == NUM_ ) return STR_ ; uint j = i ; uint len ; while ( j != NUM_ ) { len ++ ; j /= NUM_ ; } bytes memory bstr = new bytes ( len ) ; uint k = len - NUM_ ; while ( i != NUM_ ) { bstr [ k -- ] = byte ( NUM_ + i % NUM_ ) ; i /= NUM_ ; } return string ( bstr ) ; }
"function change owner ( address _owner ) public only owner returns ( bool ) { changed owner ( owner , _owner ) ; owner = _owner ; return BOOL_ ; }"
modifier onlysigner { if ( ! is signer ( msg . sender ) ) { throw ; } _ ; }
"function change key ( address _old key , address _new key ) third level public returns ( bool ) { require ( safe keys [ _old key ] ) ; require ( _new key != NUM_ ) ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { if ( mass safe keys [ i ] == _old key ) { mass safe keys [ i ] = _new key ; } } safe keys [ _old key ] = BOOL_ ; safe keys [ _new key ] = BOOL_ ; if ( _old key == last safe key ) { last safe key = _new key ; } return BOOL_ ; }"
"function transfer ( uint64 id sender , uint64 id pledge , uint amount , uint64 id receiver ) { id pledge = normalize pledge ( id pledge ) ; pledge storage p = find pledge ( id pledge ) ; pledge admin storage receiver = find admin ( id receiver ) ; pledge admin storage sender = find admin ( id sender ) ; check admin owner ( sender ) ; require ( p . pledge state == pledge state . pledged ) ; if ( p . owner == id sender ) { if ( receiver . admin type == pledge admin type . giver ) { transfer ownership to giver ( id pledge , amount , id receiver ) ; } else if ( receiver . admin type == pledge admin type . project ) { transfer ownership to project ( id pledge , amount , id receiver ) ; } else if ( receiver . admin type == pledge admin type . delegate ) { uint reciever didx = get delegate idx ( p , id receiver ) ; if ( p . intended project > NUM_ && reciever didx != notfound ) { if ( reciever"
"function approve ( address _spender , uint256 _amount ) public only payload size ( NUM_ ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; emit approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }"
function _get pay to ( ) internal view returns ( address ) { return owner ; }
"function unlock ( address addr , uint index ) public { require ( addr == msg . sender ) ; var lock = lock record map [ addr ] [ index ] ; require ( lock . amount > NUM_ && ! lock . completed ) ; var during = now - lock . time ; var reward = _calc reward ( during , lock . amount ) ; token t = token ( token addr ) ; t . transfer from ( owner , addr , lock . amount + reward ) ; lock . completed = BOOL_ ; unlock ( addr , index , lock . amount , reward ) ; }"
"function book with eth ( uint256 price per night , uint256 offer timestamp , bytes offer signature , string room type , uint256 [ ] _nights , bytes32 booking hash ) public payable { require ( offer timestamp < now ) ; require ( now < end bookings ) ; require ( price per night . mul ( _nights . length ) <= msg . value ) ; uint256 available = first room available ( room type , _nights ) ; require ( available > NUM_ ) ; bytes32 price signed = keccak256 ( abi . encode packed ( room type , price per night , offer timestamp , STR_ , booking hash ) ) . to eth signed message hash ( ) ; require ( offer signer == price signed . recover ( offer signature ) ) ; book room ( room type , _nights , available , msg . sender , booking hash , price per night , BOOL_ ) ; }"
function redeemed karma of ( string username ) public view returns ( uint ) { return redeemed karma [ username ] ; }
"function revoke all vulnerable ( ) public members only returns ( bool complete ) { require ( is member_ ) ; uint8 calling member id ; ( , calling member id ) = the cyber . get membership status ( msg . sender ) ; uint64 inactive since ; address member address ; uint8 i = next revoked member index_ ; require ( msg . gas > NUM_ ) ; while ( msg . gas > NUM_ ) { ( , , , inactive since , member address ) = the cyber . get member information ( i ) ; if ( ( i != member id_ ) && ( i != calling member id ) && ( member address != address ( NUM_ ) ) && ( inactive since != NUM_ ) && ( now >= inactive since + inactivity timeout_ ) ) { the cyber . revoke membership ( i ) ; } i ++ ; if ( i == NUM_ ) { break ; } } next revoked member index_ = i ; return ( i == NUM_ ) ; }"
"function owner refund player ( bytes32 dice roll hash , address send to , uint original player profit , uint original player bet value ) public only owner { max pending payouts = safe sub ( max pending payouts , original player profit ) ; if ( ! send to . send ( original player bet value ) ) throw ; log refund ( dice roll hash , send to , original player bet value ) ; }"
function contribute btcs ( ) public payable btcs only btcs ether cap not reached ( msg . value ) earlier than ( start time ) returns ( uint256 amount ) { return process contribution ( ) ; }
function remove current ico round ( ) public only owner { require ( ico rounds [ r no ] . r eth payments amount == NUM_ ) ; require ( ! ico rounds [ r no ] . round completed ) ; ico in progress = BOOL_ ; ico rounds [ r no ] . r min eth payment = NUM_ ; ico rounds [ r no ] . r krs usd fixed = NUM_ ; ico rounds [ r no ] . r kyc treshold = NUM_ ; ico rounds [ r no ] . r min krs cap = NUM_ ; ico rounds [ r no ] . r max krs cap = NUM_ ; ico rounds [ r no ] . r start block = NUM_ ; ico rounds [ r no ] . r end block = NUM_ ; ico rounds [ r no ] . r eth payments amount = NUM_ ; ico rounds [ r no ] . r eth payments count = NUM_ ; ico rounds [ r no ] . r sent krowns amount = NUM_ ; ico rounds [ r no ] . r sent krowns count = NUM_ ; if
"function finish phase ( ) only owner { require ( tokens selling != NUM_ ) ; token . transfer ( beneficiary , tokens selling ) ; tokens selling = NUM_ ; }"
function register balance for reference ( address _owner ) private { uint256 reference block number = latest reference block number ( ) ; if ( balances at block [ reference block number ] [ _owner ] . initialized ) { return ; } balances at block [ reference block number ] [ _owner ] . initialized = BOOL_ ; balances at block [ reference block number ] [ _owner ] . value = balances [ _owner ] ; }
"function create seed collectible ( uint8 _team id , uint8 _pos id , uint256 _attributes , address _owner , uint256 _game id , uint256 _player override id , uint256 _mlb player id ) external can create when not paused returns ( uint256 ) { address nft owner = _owner ; if ( nft owner == address ( NUM_ ) ) { nft owner = manager primary ; } seed created count ++ ; uint32 _sequence id = get sequence id ( _team id ) ; uint256 asset details = uint256 ( uint64 ( now ) ) ; asset details |= uint256 ( _sequence id ) << NUM_ ; asset details |= uint256 ( _team id ) << NUM_ ; asset details |= uint256 ( _pos id ) << NUM_ ; uint256 [ NUM_ ] memory _nft data = [ asset details , _attributes , _game id , _player override id , _mlb player id ] ; return _create nftcollectible ( _team id , _attributes , nft owner , NUM_ , _nft data ) ; }"
"function get placed notes ( ) external view returns ( uint [ ] , uint [ ] ) { uint length = owned notes [ msg . sender ] . length ; uint [ ] memory pitches = new uint [ ] ( length ) ; uint [ ] memory places = new uint [ ] ( length ) ; for ( uint i = NUM_ ; i < owned notes [ msg . sender ] . length ; i ++ ) { pitches [ i ] = owned notes [ msg . sender ] [ i ] . pitch ; places [ i ] = owned notes [ msg . sender ] [ i ] . place ; } return ( pitches , places ) ; }"
"function transfer ( address , uint256 ) public pure returns ( bool ) { return BOOL_ ; }"
"function register endpoint ( string socket ) public no empty string ( socket ) { string storage old_socket = address_to_socket [ msg . sender ] ; if ( equals ( old_socket , socket ) ) { return ; } socket_to_address [ old_socket ] = address ( NUM_ ) ; address_to_socket [ msg . sender ] = socket ; socket_to_address [ socket ] = msg . sender ; address registered ( msg . sender , socket ) ; }"
"function send token ( address _receiver , uint256 _amount ) external { require ( msg . sender == wallet ) ; require ( _amount <= deposit ) ; assert ( token . transfer ( _receiver , _amount ) ) ; deposit = deposit . sub ( _amount ) ; }"
"modifier expire gambles ( ) { if ( ( gambles . length != NUM_ && gambles . length - NUM_ >= first active gamble ) && gambles [ first active gamble ] . block number + block expiration <= block . number && ! gambles [ first active gamble ] . spinned ) { solve bet ( gambles [ first active gamble ] . player , NUM_ , BOOL_ , NUM_ ) ; update first active gamble ( first active gamble ) ; } _ ; }"
"function release tokens to ( address buyer ) internal returns ( bool ) { require ( now >= start time value && now < end time value ) ; uint amount = msg . value . mul ( price value ) ; remaining tokens value = remaining tokens value . sub ( amount ) ; emit release tokens to called detail ( wallet , buyer , amount , remaining tokens value ) ; wallet . transfer ( msg . value ) ; token . transfer from ( wallet , buyer , amount ) ; emit release tokens to called ( buyer ) ; return BOOL_ ; }"
"function get times ( ) public view returns ( uint , uint , uint , uint , uint , uint , uint , uint ) { return ( presale_start , presale_end , ico_start , ico_phase_1_end , ico_phase_2_end , ico_phase_3_end , ico_phase_4_end , ico_phase_5_end ) ; }"
"function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return narco index to approved [ _token id ] == _claimant ; }"
function modify open status ( bool status ) public is owner { open = status ; emit status changed ( status ) ; }
"function withdraw ether to ( address _escrow ) private { assert ( is ico successful ( ) ) ; if ( this . balance > NUM_ ) { if ( _escrow . send ( this . balance ) ) { withdraw ether ( _escrow , this . balance ) ; } } for ( uint i = NUM_ ; i < allowed tokens . length ; i ++ ) { abstract token token = abstract token ( allowed tokens [ i ] ) ; uint token balance = token . balance of ( address ( this ) ) ; if ( token balance > NUM_ ) { if ( token . transfer ( _escrow , token balance ) ) { withdraw token ( _escrow , address ( token ) , token balance ) ; } } } }"
"function _transfer ( address _from , address _to , uint256 _token id ) internal { owner card count [ _to ] ++ ; card to owner [ _token id ] = _to ; owner card count [ _from ] -- ; delete card approvals [ _token id ] ; transfer ( _from , _to , _token id ) ; }"
"function has voted ( uint proposal number , address shareholder ) public view returns ( bool ) { proposal storage p = proposals [ proposal number ] ; return p . voted [ shareholder ] ; }"
"function do transfer ( uint64 from , uint64 to , uint _amount ) internal { uint amount = call plugins ( BOOL_ , from , to , _amount ) ; if ( from == to ) { return ; } if ( amount == NUM_ ) { return ; } pledge storage n from = find pledge ( from ) ; pledge storage n to = find pledge ( to ) ; require ( n from . amount >= amount ) ; n from . amount -= amount ; n to . amount += amount ; transfer ( from , to , amount ) ; call plugins ( BOOL_ , from , to , amount ) ; }"
"function subscribe ( uint _start time , uint _pay per week , address _recipient ) public returns ( bool ) { require ( _start time >= block . timestamp ) ; require ( _pay per week != NUM_ ) ; require ( _recipient != NUM_ ) ; subs [ msg . sender ] [ _recipient ] = sub ( _start time , _pay per week , _start time ) ; emit log subscription ( msg . sender , _recipient ) ; return BOOL_ ; }"
function refund ( ) public { require ( current pre icobalance < softcap && now > start + period * NUM_ days ) ; msg . sender . transfer ( balances [ msg . sender ] ) ; balances [ msg . sender ] = NUM_ ; }
"function finalize single investor ( address investor addr ) public only owner must be at stage ( stage . finished ) { require ( investor addr != address ( NUM_ ) && investor addr != address ( this ) ) ; require ( balances token [ investor addr ] > NUM_ ) ; require ( is whitelisted [ investor addr ] == BOOL_ ) ; uint256 balance to transfer = balances token [ investor addr ] ; balances token [ investor addr ] = NUM_ ; is whitelisted [ investor addr ] = BOOL_ ; require ( token . transfer ( investor addr , balance to transfer ) ) ; tokens finalized = tokens finalized . add ( balance to transfer ) ; assert ( tokens finalized <= max_tokens ) ; }"
"modifier can transfer ( address _sender , uint256 _value ) { require ( transfers enabled || _sender == owner ) ; _ ; }"
"function pay eth ( address beneficiary ) public only white list ( beneficiary ) payable { require ( msg . value >= NUM_ ether ) ; require ( beneficiary != NUM_ ) ; require ( valid purchase ( ) ) ; if ( is private sale ( ) ) { process private purchase ( msg . value , beneficiary ) ; } else { process public purchase ( msg . value , beneficiary ) ; } }"
function get sale status ( ) constant returns ( bool ) { bool status = BOOL_ ; if ( crowdsale closed == BOOL_ ) { status = BOOL_ ; } return status ; }
"function make swap ( address _address , uint _value , bytes32 _hash ) public is authorized is not paused { erc223 new tok = erc223 ( new token add ) ; uint gpxtosend = mul ( _value , tokenrate ) ; if ( payments [ _hash ] > NUM_ ) { gxvcreplay ( NUM_ , _address ) ; return ; } if ( gpxtosend == NUM_ ) { gxvcno token ( NUM_ , _address ) ; return ; } tokens received ( NUM_ , _address , _value ) ; payments [ _hash ] = gpxtosend ; require ( new tok . transfer from ( token spender , _address , gpxtosend ) ) ; gxvcsent by token ( NUM_ , _address , gpxtosend ) ; last block = block . number + NUM_ ; }"
function stop crowdsale ( ) public only owner returns ( bool ) { is crowdsale stopped = BOOL_ ; }
function set direct payment threshold ( uint256 threshold ) external only cfo { direct payment threshold = threshold ; }
"function pay custom ( address to , uint amount ) public only owner returns ( bool success ) { payout ( to , amount ) ; return BOOL_ ; }"
function total supply ( ) public view returns ( uint supply ) { return total bhinneka ; }
"function get opinion ( uint256 _token id ) public view returns ( uint256 selling price , address owner , address sponsor , address antisponsor , uint256 amountsponsored , uint256 amountantisponsored , uint8 acomment , uint256 timestamp , string opinion text ) { opinion storage opinion = opinions [ _token id ] ; opinion text = opinion . text ; selling price = opinion index to price [ _token id ] ; owner = opinion index to owner [ _token id ] ; acomment = opinion . comment ; sponsor = opinion . sponsor ; antisponsor = opinion . antisponsor ; amountsponsored = opinion . totalsponsored ; amountantisponsored = opinion . totalantisponsored ; timestamp = opinion . timestamp ; }"
"function join ( ) payable { require ( msg . value >= NUM_ finney ) ; uint entries = msg . value / NUM_ finney ; entries = entries > NUM_ ? NUM_ : entries ; for ( uint i = NUM_ ; i < entries ; i ++ ) { member queue . push ( msg . sender ) ; if ( member queue . length % NUM_ == NUM_ ) { queue front += NUM_ ; member queue [ queue front - NUM_ ] . transfer ( NUM_ finney ) ; } } joined ( msg . sender , entries , member queue . length * NUM_ ) ; uint remainder = msg . value - ( entries * NUM_ finney ) ; if ( remainder > NUM_ finney ) { msg . sender . transfer ( remainder ) ; } }"
function migrate ( address _moderator ) external only moderator { require ( is finalized ) ; require ( is contract ( _moderator ) ) ; token contract . reassign moderator ( _moderator ) ; }
function set new fundaria ( address new_fundaria ) public only owner { fundaria = new_fundaria ; }
"function m confirm payment ( uint [ ] pledges amounts ) { for ( uint i = NUM_ ; i < pledges amounts . length ; i ++ ) { uint64 id pledge = uint64 ( pledges amounts [ i ] & ( d64 - NUM_ ) ) ; uint amount = pledges amounts [ i ] / d64 ; confirm payment ( id pledge , amount ) ; } }"
"function current state active ( ) public constant returns ( bool presale wait phase , bool presale phase , bool crowdsale phase1 , bool crowdsale phase2 , bool crowdsale phase3 , bool crowdsale phase4 , bool buyable , bool distributable , bool reached minimum ether goal , bool reached maximum ether goal , bool completed , bool finalized and closed , bool stopped ) { return ( is presale wait phase ( ) , is presale phase ( ) , is crowdsale phase1 ( ) , is crowdsale phase2 ( ) , is crowdsale phase3 ( ) , is crowdsale phase4 ( ) , is buyable ( ) , is distributable ( ) , min goal reached ( ) , max goal reached ( ) , is completed ( ) , finalized , halted ) ; }"
function release vested ( token vesting _vesting ) public { require ( _vesting != address ( NUM_ ) ) ; _vesting . release ( this ) ; }
modifier only authorised ( ) { require ( authorised [ msg . sender ] ) ; require ( ( current time ( ) >= presale_starttimestamp && current time ( ) <= presale_endtimestamp ) || ( current time ( ) >= publicsale_starttimestamp && current time ( ) <= publicsale_endtimestamp ) ) ; require ( ! ( has ended ( ) ) ) ; require ( multi sig != NUM_ ) ; require ( msg . value > NUM_ finney ) ; require ( ! suspended ) ; require ( tokens for sale > token raised ) ; _ ; }
"function opt in from classic ( ) public { if ( old e4 == address ( NUM_ ) ) { stat event ( STR_ ) ; return ; } address nrequester = msg . sender ; if ( holder accounts [ nrequester ] . tokens != NUM_ ) { stat event ( STR_ ) ; return ; } token iclassic = token ( old e4 ) ; uint _toks = iclassic . balance of ( nrequester ) ; if ( _toks == NUM_ ) { stat event ( STR_ ) ; return ; } if ( iclassic . allowance ( nrequester , address ( this ) ) < _toks ) { stat event ( STR_ ) ; return ; } if ( msg . gas < opt in xfer gas + opt in fcn min gas ) throw ; iclassic . transfer from . gas ( opt in xfer gas ) ( nrequester , old e4 recycle bin , _toks ) ; if ( iclassic . balance of ( nrequester ) == NUM_ ) { if ( ! holder accounts [ nrequester ] . alloced ) add account ( nrequester ) ; holder accounts [ nrequester ] . tokens ="
"function transfer ( address _to , uint _value ) public when not paused returns ( bool ) { bool result = super . transfer ( _to , _value ) ; update ( msg . sender , balances [ msg . sender ] ) ; update ( _to , balances [ _to ] ) ; return result ; }"
"function buy internal ( address _investor , uint _payment , uint _extra bonuses ) internal require settings set { super . buy internal ( _investor , _payment , _extra bonuses ) ; }"
"function rescue token ( erc20 _token ) external { _token . transfer ( msg . sender , _token . balance of ( this ) ) ; }"
function change contract state ( bool _accepting deposits ) public only owner { accepting deposits = _accepting deposits ; accepting deposits changed ( accepting deposits ) ; }
"function bonus one ( uint id ) payable public { casino storage item = all casinos [ id ] ; address owner = item . owner ; if ( owner != address ( NUM_ ) ) { uint old val = balances [ owner ] ; balances [ owner ] = safe add ( old val , msg . value ) ; } else { master has = safe add ( master has , msg . value ) ; } }"
"function create vending item ( uint256 _collectible type , uint256 _vending qty , uint256 _starting price , uint256 _step amount , uint256 _step qty ) external only manager { vending amount type [ _collectible type ] = _vending qty ; vending price [ _collectible type ] = _starting price ; vending step up qty [ _collectible type ] = _step qty ; vending step up amount [ _collectible type ] = _step amount ; }"
function revoke access deposit ( address _address ) only owner public { deposit access [ _address ] = BOOL_ ; }
function set max withdrawal ( uint new max ) public only authorized { max withdrawal = new max * one edg ; }
"function calculate tokens ( address _buyer , uint256 _buyer amount in wei ) internal view returns ( uint256 ) { discount memory discount = discounts [ _buyer ] ; if ( discount . min tokens == NUM_ ) { return _buyer amount in wei . mul ( rate ) ; } uint256 normal tokens = _buyer amount in wei . mul ( rate ) ; uint256 discount bonus = normal tokens . mul ( discount . percent ) . div ( NUM_ ) ; uint256 tokens = normal tokens + discount bonus ; require ( tokens >= discount . min tokens ) ; return tokens ; }"
function add pre ico members ( address [ ] members ) public only owner { for ( uint i = NUM_ ; i < members . length ; i ++ ) { pre ico members [ members [ i ] ] = BOOL_ ; } }
function set fee ( uint256 _fee ) public only owner returns ( bool ) { fee = _fee ; set fee ( _fee ) ; return BOOL_ ; }
"function transfer ( address to , uint value ) returns ( bool success ) { require ( balances [ msg . sender ] >= value && value > NUM_ ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; return BOOL_ ; }"
function price ( ) external view returns ( uint ) { if ( active ( ) ) { return campaigns [ last campaign id ] . price ; } else { return starting price ; } }
"function set resolver ( string name , address resolver ) public owner_only ( keccak256 ( name ) ) { var label = keccak256 ( name ) ; var node = keccak256 ( tld_node , label ) ; ens . set resolver ( node , resolver ) ; }"
"function close bet ( uint maker bet id ) external { maker bet storage maker bet = maker bets [ maker bet id ] [ msg . sender ] ; require ( maker bet . maker bet id != NUM_ ) ; require ( maker bet . status == bet status . open || maker bet . status == bet status . paused ) ; require ( msg . sender == maker bet . maker ) ; maker bet . status = bet status . closed ; uint unused fund = sub ( maker bet . total fund , maker bet . reserved fund ) ; if ( unused fund > NUM_ ) { maker bet . total fund = maker bet . reserved fund ; uint refund amount = unused fund ; if ( maker bet . total stake == NUM_ ) { refund amount = add ( refund amount , base verifier fee ) ; maker bet . maker fund withdrawn = BOOL_ ; } if ( ! maker bet . maker . send ( refund amount ) ) { maker bet . total fund = add ( maker bet . total fund , unused fund ) ;"
"function add field ( string _field name , uint _field type ) { if ( msg . sender != credit dao ) throw ; if ( _field type == NUM_ ) throw ; if ( field types [ _field name ] != NUM_ ) throw ; avaliable fields [ next field index ] = _field name ; field activated [ _field name ] = BOOL_ ; field types [ _field name ] = _field type ; next field index += NUM_ ; }"
"function setup ( ) public only owner check allowed { require ( trusted token . transfer ( disbursement handler , disbursement handler . total amount ( ) ) ) ; tokens for sale = trusted token . balance of ( this ) ; require ( tokens for sale >= total sale cap ) ; go to next state ( ) ; }"
function _get token lock type ( uint256 _wei amount ) internal view returns ( token lock type ) { token lock type lock type = token lock type . type_not_lock ; if ( _wei amount >= NUM_ ether ) { lock type = token lock type . type_seed_investor ; } else if ( current phase == NUM_ ) { lock type = token lock type . type_pre_sale ; } return lock type ; }
function change multi sig address ( address _address ) public only multi sig { require ( _address != address ( NUM_ ) ) ; multi sig address = _address ; }
"function get unsold tokens ( uint val_ ) only owner { token reward . transfer ( beneficiary , val_ ) ; }"
"function get claim ( address issuer , address subject , bytes32 key ) public constant returns ( bytes32 ) { return registry [ issuer ] [ subject ] [ key ] ; }"
"function salvage tokens from contract ( address _token address , address _to , uint _amount ) only owner { ierc20 token ( _token address ) . transfer ( _to , _amount ) ; }"
"function lock up amount str of ( address _address ) external view returns ( address address , string a , string b , string c , string d , string e , string f ) { address __address = _address ; if ( __address == address ( NUM_ ) ) __address = msg . sender ; uint256 [ NUM_ ] memory arr = lock up amount of ( __address ) ; return ( __address , _uint to spdstr ( arr [ NUM_ ] ) , _uint to spdstr ( arr [ NUM_ ] ) , _uint to spdstr ( arr [ NUM_ ] ) , _uint to spdstr ( arr [ NUM_ ] ) , _uint to spdstr ( arr [ NUM_ ] ) , _uint to spdstr ( arr [ NUM_ ] ) ) ; }"
"function register ticker ( address _owner , string _symbol , string _token name , bytes32 _swarm hash ) public when not paused { require ( _owner != address ( NUM_ ) , STR_ ) ; require ( bytes ( _symbol ) . length > NUM_ && bytes ( _symbol ) . length <= NUM_ , STR_ ) ; if ( registration fee > NUM_ ) require ( erc20 ( poly token ) . transfer from ( msg . sender , this , registration fee ) , STR_ ) ; string memory symbol = upper ( _symbol ) ; require ( expiry check ( symbol ) , STR_ ) ; registered symbols [ symbol ] = symbol details ( _owner , now , _token name , _swarm hash , BOOL_ ) ; emit log register ticker ( _owner , symbol , _token name , _swarm hash , now ) ; }"
function pause ( ) public only owner { _pause ( ) ; }
"function create team sale auction ( uint8 _team id , uint256 [ NUM_ ] _token ids , uint256 _start price , uint256 _end price , uint256 _sale duration ) public only game manager when not paused { require ( _team id != NUM_ ) ; for ( uint ii = NUM_ ; ii < _token ids . length ; ii ++ ) { require ( non fungible contract . get team id ( _token ids [ ii ] ) == _team id ) ; } uint256 start price = NUM_ ; uint256 end price = NUM_ ; uint256 duration = NUM_ ; if ( _start price == NUM_ ) { start price = _compute next seed price ( NUM_ , _team id ) . mul ( NUM_ ) ; } else { start price = _start price ; } if ( _end price != NUM_ ) { end price = _end price ; } else { end price = NUM_ ; } if ( _sale duration == NUM_ ) { duration = sales_duration ; } else { duration = _sale duration ; } _create team sale ( _token ids , start price , end price , duration , address ("
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( this ) ) ; return super . transfer ( _to , _value ) ; }"
"function get escrow and hash ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee ) view private returns ( escrow , bytes32 ) { bytes32 _trade hash = keccak256 ( abi . encode packed ( _trade id , _seller , _buyer , _value , _fee ) ) ; return ( escrows [ _trade hash ] , _trade hash ) ; }"
function pause ico ( ) public only owner { require ( ! ico paused ) ; ico paused = BOOL_ ; paused time = now ; icopaused ( now ) ; }
"function initialize ( ) internal view { require ( free mem ( ) == NUM_ , STR_ ) ; assembly { mstore ( NUM_ , sload ( NUM_ ) ) mstore ( NUM_ , sload ( NUM_ ) ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) } assert ( exec id ( ) != bytes32 ( NUM_ ) && sender ( ) != address ( NUM_ ) ) ; }"
modifier isright ( ) { require ( deposit items [ msg . sender ] . valid != NUM_ ) ; _ ; }
"function finalize change insurance fees ( ) public only admin or owner { require ( change insurance fees operation . admin == admin ) ; require ( change insurance fees operation . defer block <= block . number ) ; uint80 _transfer fee numerator = change insurance fees operation . _transfer fee numerator ; uint80 _transfer fee denominator = change insurance fees operation . _transfer fee denominator ; uint80 _mint fee numerator = change insurance fees operation . _mint fee numerator ; uint80 _mint fee denominator = change insurance fees operation . _mint fee denominator ; uint256 _mint fee flat = change insurance fees operation . _mint fee flat ; uint80 _burn fee numerator = change insurance fees operation . _burn fee numerator ; uint80 _burn fee denominator = change insurance fees operation . _burn fee denominator ; uint256 _burn fee flat = change insurance fees operation . _burn fee flat ; delete change insurance fees operation ; child . change insurance fees ( _transfer fee numerator , _transfer fee denominator , _mint fee numerator , _mint fee denominator , _mint fee flat , _burn fee numerator , _burn fee denominator , _burn fee flat ) ; }"
"function token fallback ( address _sender , uint _value , uint [ ] _team ) public before deadline diip coin only returns ( bool ) { require ( startlist uploaded ) ; return commit team ( _sender , _value , _team ) ; }"
function return investment recursive ( uint value ) internal { if ( investor index >= investors . length || value == NUM_ ) return ; else if ( value <= balances [ investors [ investor index ] ] ) { balances [ investors [ investor index ] ] -= value ; if ( ! investors [ investor index ] . send ( value ) ) throw ; } else if ( balances [ investors [ investor index ] ] > NUM_ ) { uint val = balances [ investors [ investor index ] ] ; balances [ investors [ investor index ] ] = NUM_ ; if ( ! investors [ investor index ] . send ( val ) ) throw ; investor index ++ ; return investment recursive ( value - val ) ; } else { investor index ++ ; return investment recursive ( value ) ; } }
modifier require multiple ( uint256 value ) { require ( ( value % creation unit ) == NUM_ ) ; _ ; }
function set pbttfor gas ( uint256 new pbttamount ) public only owner or ops { pbttfor gas = new pbttamount ; }
"function transfer ( address _to , uint256 _token id ) public { require ( bytes ( _cards [ _token id ] . name ) . length != NUM_ ) ; require ( ! _cards [ _token id ] . is locked ) ; require ( _owns ( msg . sender , _token id ) ) ; require ( msg . sender != _to ) ; require ( _address not null ( _to ) ) ; _transfer ( msg . sender , _to , _token id ) ; }"
"function contribute ( address _sender , uint256 _amount ) private { require ( ! locked , STR_ ) ; require ( ! distribution active , STR_ ) ; require ( _amount >= precision minimum , STR_ ) ; require ( hard cap >= _amount , STR_ ) ; require ( _amount % precision minimum == NUM_ , STR_ ) ; require ( hard cap >= total contributed . add ( _amount ) , STR_ ) ; total contributed = total contributed . add ( _amount ) ; uint256 share = percent ( _amount , valuation , NUM_ ) ; owner storage o = owners [ _sender ] ; if ( o . percentage != NUM_ ) { o . share tokens = o . share tokens . add ( _amount ) ; o . percentage = o . percentage . add ( share ) ; } else { o . key = total owners ; require ( owner map . insert ( o . key , uint ( _sender ) ) == BOOL_ ) ; total owners += NUM_ ; o . share tokens = _amount ; o . percentage = share ; all owners [ _sender ] = BOOL_"
"function activate ( ) public { require ( msg . sender == dev_1_address , STR_ ) ; require ( address ( other f3 d_ ) != address ( NUM_ ) , STR_ ) ; require ( activated_ == BOOL_ , STR_ ) ; activated_ = BOOL_ ; r id_ = NUM_ ; round_ [ NUM_ ] . strt = now + rnd extra_ - rnd gap_ ; round_ [ NUM_ ] . end = now + rnd init_ + rnd extra_ ; }"
"function set payouts ( uint _week , string _num matches ) only etheraffle external { set pay outs ( _week , _num matches ) ; }"
function withdraw ( ) external is admin { admin . transfer ( address ( this ) . balance ) ; }
function scanned silver caps ( ) public view returns ( uint64 ) { return uint64 ( packed scanned caps > > NUM_ ) ; }
"function tokens locked ( address _of , uint256 _time ) public view returns ( uint256 amount ) { for ( uint256 i = NUM_ ; i < locked [ _of ] . length ; i ++ ) { if ( locked [ _of ] [ i ] . validity > _time ) amount += locked [ _of ] [ i ] . amount ; } }"
"function set other manager ( address _new op , uint8 _state ) external only manager { require ( _new op != address ( NUM_ ) ) ; other managers [ _new op ] = _state ; }"
"function air deliver ( address _to , uint256 _amount ) only owner public { require ( owner != _to ) ; require ( _amount > NUM_ ) ; require ( balances [ owner ] . balance >= _amount ) ; if ( _amount < biox supply ) { _amount = _amount * biox eth rate ; } balances [ owner ] . balance = balances [ owner ] . balance . sub ( _amount ) ; balances [ _to ] . balance = balances [ _to ] . balance . add ( _amount ) ; emit transfer ( owner , _to , _amount ) ; }"
"function set sto ( address _stoaddress , uint256 _fee , uint256 _vesting period , uint8 _quorum ) public returns ( bool success ) { require ( offerings [ _stoaddress ] . auditor == address ( NUM_ ) ) ; require ( _stoaddress != address ( NUM_ ) ) ; require ( _quorum > NUM_ && _quorum <= NUM_ ) ; require ( _vesting period >= minimum_vesting_period ) ; require ( _fee > NUM_ ) ; offerings [ _stoaddress ] . auditor = msg . sender ; offerings [ _stoaddress ] . fee = _fee ; offerings [ _stoaddress ] . vesting period = _vesting period ; offerings [ _stoaddress ] . quorum = _quorum ; return BOOL_ ; }"
function name ( ) public view returns ( string ) { return token . name ( ) ; }
"function change price ( uint256 _token id , uint256 _price ) public { require ( landmark to owner [ _token id ] == msg . sender ) ; require ( landmark to max price [ _token id ] >= _price ) ; landmark to price [ _token id ] = _price ; price changed ( _token id , _price ) ; }"
function change upgrade agent ( address _new agent ) public only owner { require ( total upgraded == NUM_ ) ; upgrade agent = upgrade agent ( _new agent ) ; require ( upgrade agent . is upgrade agent ( ) ) ; change upgrade agent ( _new agent ) ; }
"function set time window ( uint256 _start time , uint256 _end time ) external only owner returns ( bool ) { require ( _start time >= start_time ) ; require ( _end time > _start time ) ; start time = _start time ; end time = _end time ; time window updated ( _start time , _end time ) ; return BOOL_ ; }"
"function increase total supply ( uint256 _increase ) internal { uint256 total supply_ = total supply ( ) ; total supply_ = total supply_ . add ( _increase ) ; rocket storage . set uint ( keccak256 ( STR_ ) , total supply_ ) ; }"
modifier is locked ( ) { assert ( locked ) ; _ ; }
function check amount ( uint256 amount ) internal constant returns ( uint256 checked amount ) { if ( amount > balances [ this ] ) { checked amount = balances [ this ] ; } else { checked amount = amount ; } return checked amount ; }
"function give aways ( address _to , uint256 _amount , uint256 _bonus ) external only owner { if ( ! transfer tokens ( _to , _amount , _bonus ) ) revert ( ) ; }"
"function batch create asset sale ( uint256 [ ] _token ids , uint256 [ ] _starting prices , uint256 [ ] _ending prices , uint256 [ ] _durations ) external when not paused { require ( _token ids . length > NUM_ && _starting prices . length > NUM_ && _ending prices . length > NUM_ && _durations . length > NUM_ ) ; for ( uint ii = NUM_ ; ii < _token ids . length ; ii ++ ) { require ( _token ids [ ii ] != NUM_ ) ; require ( _starting prices [ ii ] == _starting prices [ ii ] ) ; require ( _ending prices [ ii ] == _ending prices [ ii ] ) ; require ( _durations [ ii ] == _durations [ ii ] ) ; address _owner = owner of ( _token ids [ ii ] ) ; address _msg sender = msg . sender ; require ( _owner == _msg sender ) ; require ( check is attached ( _token ids [ ii ] ) == NUM_ ) ; _approve for sale ( msg . sender , address ( sale manager address ) , _token ids [ ii"
function transfer token ownership ( address new token owner ) public only owner { token . transfer ownership ( new token owner ) ; }
function cur id ( ) public view returns ( uint32 ) { return vars . cur id ; }
"function withdraw mytoken ( uint256 amount ) only owner public { _transfer ( this , msg . sender , amount ) ; }"
"function set manager ( address _manager , bool _active ) public only owner { require ( _manager != address ( NUM_ ) ) ; is managers [ _manager ] = _active ; changed manager ( _manager , _active ) ; }"
"function __callback ( bytes32 myid , string result ) public { bytes memory proof = new bytes ( NUM_ ) ; __callback ( myid , result , proof ) ; }"
function set order end ( ) assert admin public { order end = BOOL_ ; }
function unit battle eth cost ( uint256 card id ) external constant returns ( uint256 ) { return battlecard info [ card id ] . eth cost ; }
"function guarded array replace ( bytes memory array , bytes memory desired , bytes memory mask ) pure internal { byte [ NUM_ ] memory bitmasks = [ byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) ] ; require ( array . length == desired . length ) ; require ( mask . length >= array . length / NUM_ ) ; bool masked ; for ( uint i = NUM_ ; i < array . length ; i ++ ) { masked = ( mask [ i / NUM_ ] & bitmasks [ i % NUM_ ] ) == NUM_ ; if ( ! masked ) { array [ i ] = desired [ i ] ; } } }"
"function cage ( uint price ) internal { require ( ! tub . off ( ) && price != NUM_ ) ; caged = era ( ) ; tub . drip ( ) ; tap . heal ( ) ; fit = rmul ( wmul ( price , vox . par ( ) ) , tub . per ( ) ) ; if ( sai . total supply ( ) == NUM_ ) { fix = rdiv ( wad , price ) ; } else { fix = min ( rdiv ( wad , price ) , rdiv ( tub . pie ( ) , sai . total supply ( ) ) ) ; } tub . cage ( fit , rmul ( fix , sai . total supply ( ) ) ) ; tap . cage ( fix ) ; tap . vent ( ) ; }"
"function initial coach ( uint _price , uint _emoterate , uint8 _category , uint _num ) public only owner { uint id = origin coach . push ( coach ( _price , _emoterate , NUM_ , NUM_ , _category ) ) - NUM_ ; coach allnums [ id ] = _num ; emit initialcoach ( id ) ; }"
modifier only freezer ( ) { require ( msg . sender == freezer ) ; _ ; }
"function set pending tax parameters ( address _tax wallet , uint _tax fee bps ) public only operator { require ( _tax wallet != address ( NUM_ ) ) ; require ( _tax fee bps > NUM_ ) ; tax data . wallet = _tax wallet ; tax data . fee bps = _tax fee bps ; set new data ( tax_data_index ) ; }"
"function set cat attribute value ( uint cat index , uint attr index , string attr value ) { require ( cat index < _total supply ) ; require ( cat index to address [ cat index ] == msg . sender ) ; require ( attr index >= NUM_ && attr index < NUM_ ) ; bytes memory temp attribute type text = bytes ( attribute type [ attr index ] ) ; require ( temp attribute type text . length != NUM_ ) ; cat attributes [ cat index ] [ attr index ] = attr value ; }"
"function solved ( string name , string time to solve ) public { solved ( msg . sender , name , time to solve ) ; }"
"function get winnings ( address user , uint home , uint away ) public view returns ( uint winnings ) { var ( num square wins , total wins ) = oracle . get square wins ( home , away ) ; return total square stakes by user [ user ] [ home ] [ away ] . mul ( total stakes ) . mul ( num square wins ) . div ( total wins ) . div ( total square stakes [ home ] [ away ] ) ; }"
function pet on leaderboards ( uint64 pet id ) external constant returns ( bool ) { return pets on leaderboards [ pet id ] ; }
"function buy for investor ( address _investor , uint _dat value , string _tx hash ) external controllers only { buy ( _investor , _dat value ) ; log buy for investor ( _investor , _dat value , _tx hash ) ; }"
"function set pricing plan ( address _pricing plan ) public only service provider { require ( _pricing plan != NUM_ , STR_ ) ; require ( _pricing plan != address ( pricing plan ) , STR_ ) ; pricing plan = noku pricing plan ( _pricing plan ) ; emit log pricing plan changed ( msg . sender , _pricing plan ) ; }"
"function set allowed transfer to ( address to , bool allowed ) public only ( role_eurt_deposit_manager ) { _allowed transfer to [ to ] = allowed ; log allowed to address ( to , allowed ) ; }"
function lock limit ( ) constant returns ( uint256 limit ) { return _lock limit ; }
function stop funding ( ) is owner external { require ( is funding ) ; is funding = BOOL_ ; }
"function buy for investor ( address _holder , uint _value , string _tx hash ) external only controller { require ( mint ( _holder , _value ) ) ; log buy for investor ( _holder , _value , _tx hash ) ; }"
modifier only owner or api ( ) { require ( msg . sender == owner || msg . sender == api ) ; if ( msg . sender == api && api != owner ) { require ( ! api access disabled ) ; } _ ; }
"function to bytes32 ( slice self ) internal pure returns ( bytes32 result ) { string memory source = to string ( self ) ; bytes memory temp empty string test = bytes ( source ) ; if ( temp empty string test . length == NUM_ ) { return NUM_ ; } assembly { result : = mload ( add ( source , NUM_ ) ) } }"
function change admin address ( address _new address ) external only owner { require ( _new address != address ( NUM_ ) ) ; require ( admin address != _new address ) ; admin address = _new address ; }
function revoke editor rights ( address editor ) public only owner { is editor [ editor ] = BOOL_ ; }
"function set distributor ( address distributor , bool state , uint amount ) external only owner { distributors list . push ( distributor ) ; distributors [ distributor ] = state ; distributors amount [ distributor ] = amount ; }"
"function copy quick buy path ( ibancor converter extended _old converter , ibancor converter extended _new converter ) private { uint256 quick buy path length = _old converter . get quick buy path length ( ) ; if ( quick buy path length <= NUM_ ) return ; ierc20 token [ ] memory path = new ierc20 token [ ] ( quick buy path length ) ; for ( uint256 i = NUM_ ; i < quick buy path length ; i ++ ) { path [ i ] = _old converter . quick buy path ( i ) ; } _new converter . set quick buy path ( path ) ; }"
function set eth fund deposit ( address _eth fund deposit ) only owner public { require ( _eth fund deposit != address ( NUM_ ) ) ; eth fund deposit = _eth fund deposit ; }
"function withdraw fees ( ) external when system not paused current round initialized auto claim earnings { require ( delegators [ msg . sender ] . fees > NUM_ ) ; uint256 amount = delegators [ msg . sender ] . fees ; delegators [ msg . sender ] . fees = NUM_ ; minter ( ) . trusted withdraw eth ( msg . sender , amount ) ; withdraw fees ( msg . sender ) ; }"
function recovery payment digest bytes32 channel id uint256 payment internal view returns bytes32 bytes memory prefix \x19 ethereum signed message \n32 return keccak256 prefix payment digest channel id payment
modifier only profits holders ( ) { require ( my dividends ( BOOL_ ) > NUM_ ) ; _ ; }
"function burn unused ( ) public only owner { this . approve ( msg . sender , NUM_ ) ; this . burn ( balances [ this ] ) ; }"
function destroy tokens ( uint256 destroy amount ) multisig ( sha3 ( msg . data ) ) { assert ( treasury balance >= destroy amount ) ; treasury balance -= destroy amount ; total supply -= destroy amount ; }
function withdraw wei ( uint bal wei ) public only token manager returns ( uint ) { log escrow wei req ( bal wei ) ; if ( this . balance >= bal wei ) { escrow . transfer ( bal wei ) ; log escrow wei ( bal wei ) ; return NUM_ ; } return NUM_ ; }
"function send to other blockchain2 ( string _coin symbol , string _to address , address _return address ) external payable returns ( uint ) { return engine ( _coin symbol , _to address , _return address ) ; }"
function proxy payment ( address _owner ) public payable returns ( bool ) { revert ( ) ; return BOOL_ ; }
function _is ready to give birth ( panda _matron ) private view returns ( bool ) { return ( _matron . siring with id != NUM_ ) && ( _matron . cooldown end block <= uint64 ( block . number ) ) ; }
modifier only creator ( ) { require ( msg . sender == creator ) ; _ ; }
"function buy tokens ( ) payable returns ( uint256 amount ) { require ( current state == state . running ) ; assert ( msg . sender != NUM_ ) ; require ( msg . value > NUM_ ) ; uint256 tokens = msg . value * token_price_d / token_price_n ; if ( tokens == NUM_ ) return NUM_ ; looks coin . reward tokens ( msg . sender , tokens ) ; tokens sold = tokens sold + tokens ; assert ( fundstorage . send ( msg . value ) ) ; tokens bought ( msg . sender , msg . value , tokens , tokens sold ) ; return tokens ; }"
"function transfer ( address _to , uint256 _value , bytes _data , string _fallback ) public when not paused returns ( bool ) { require ( _to != address ( NUM_ ) ) ; if ( is contract ( _to ) ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; assert ( _to . call . value ( NUM_ ) ( bytes4 ( keccak256 ( abi . encode packed ( _fallback ) ) ) , msg . sender , _value , _data ) ) ; if ( _data . length == NUM_ ) { emit transfer ( msg . sender , _to , _value ) ; } else { emit transfer ( msg . sender , _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; } return BOOL_ ; } else { return transfer to address ( msg . sender , _to , _value , _data ) ; } }"
function set exchange interval ( uint new interval ) external only cfo { exchange interval = new interval ; }
"function burn ( uint _amount ) public { balances [ msg . sender ] = safe sub ( balance of ( msg . sender ) , _amount ) ; supply = safe sub ( supply , _amount ) ; emit burn ( msg . sender , _amount ) ; emit transfer ( msg . sender , NUM_ , _amount ) ; }"
function _get asset ( ) internal view returns ( atx asset interface ) { return atx asset interface ( get latest version ( ) ) ; }
"function show time ( address _address ) public view valid address ( _address ) returns ( uint256 [ ] _time ) { uint i = NUM_ ; uint256 [ ] memory temp lock time = new uint256 [ ] ( lock num [ _address ] ) ; while ( i < lock num [ _address ] ) { temp lock time [ i ] = sub ( add ( lock time [ _address ] [ i ] , later ) , earlier ) ; i ++ ; } return temp lock time ; }"
modifier only owner or authorizer ( ) { require ( msg . sender == owner || authorizers [ msg . sender ] ) ; _ ; }
"function mint ( address to , uint x , uint y , uint size a , uint size b , uint256 total price , uint256 actual price ) public only platform ( ) returns ( uint256 ) { require ( to != address ( NUM_ ) ) ; require ( size a . mul ( size b ) <= NUM_ ) ; uint256 inner ; uint256 total ; ( total , inner ) = calculate counters ( x , y , size a , size b ) ; uint256 token id = ( all mined tokens . length ) . add ( NUM_ ) ; token memory minted = token ( token id , x , y , size a , size b , total price , actual price , NUM_ , NUM_ , NUM_ , inner , total . sub ( inner ) , NUM_ ) ; copy to all units ( x , y , size a , size b , token id ) ; update internal state ( minted , to ) ; return token id ; }"
"function get score ( uint _token id ) public view returns ( uint ) { uint [ ] memory _game forecast = new uint [ ] ( NUM_ ) ; return get score ( _token id , block . number , _game forecast ) ; }"
function sqrt ( uint64 x ) pure internal returns ( uint64 y ) { uint64 z = ( x + NUM_ ) / NUM_ ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / NUM_ ; } }
function get currency address ( ) external view returns ( address ) { return NUM_ ; }
"function setifood dev address ( address _ifood dev ) only ( ifood dev ) non zero address ( ifood dev ) public { ifood dev = _ifood dev ; setifood dev address ( msg . sender , _ifood dev ) ; }"
function get usd cents from wei ( uint256 _wei ) public view returns ( uint256 ) { return _wei . mul ( eth price in cents ) . div ( NUM_ ether ) ; }
"function send platform supply token ( address to ) public only owner { require ( ( to != NUM_ ) && ( is distribution transferred == NUM_ ) ) ; balances [ multisig ] = balances [ multisig ] . sub ( _platform supply ) ; balances [ to ] = balances [ to ] . add ( _platform supply ) ; transfer ( multisig , to , _platform supply ) ; }"
function new payment address ( address _collector ) public returns ( address new contract ) { payment address payment address = new payment address ( _collector ) ; payment addresses [ _collector ] . push ( payment address ) ; add contract ( payment address ) ; return payment address ; }
"function setifood community address ( address _ifood community ) only ( ifood community ) non zero address ( _ifood community ) public { ifood community = _ifood community ; setifood community address ( msg . sender , _ifood community ) ; }"
function has ended ( ) public view returns ( bool ) { if ( manual state == manual state . working ) { return BOOL_ ; } else if ( manual state == manual state . ready ) { return BOOL_ ; } bool ico limit reached = token . balance of ( vault ) == NUM_ ; return super . has ended ( ) || ico limit reached ; }
"function transfer remaining tokens ( ) public only owner _contract up _sale ended { token . transfer ( msg . sender , address ( this ) . balance ) ; }"
"function withdraw token from balance ( erc20 _token contract , address _withdraw to address ) external { address core address = address ( core contract ) ; require ( msg . sender == owner || msg . sender == operator address || msg . sender == core address ) ; uint256 balance = _token contract . balance of ( address ( this ) ) ; _token contract . transfer ( _withdraw to address , balance ) ; }"
"function buy ( ) public payable { uint256 count = msg . value * total supply / this . balance ; require ( count > NUM_ ) ; total supply += count ; balance of [ msg . sender ] += count ; transfer ( address ( NUM_ ) , msg . sender , count ) ; }"
function get approved ( uint256 _token id ) external view can be stored in40 bits ( _token id ) returns ( address ) { require ( _token id <= _total supply ( ) ) ; if ( cutie index to approved [ uint40 ( _token id ) ] != address ( NUM_ ) ) { return cutie index to approved [ uint40 ( _token id ) ] ; } address owner = cutie index to owner [ uint40 ( _token id ) ] ; return address to approved all [ owner ] ; }
"function offering ended ( ) internal { end time = now ; stage = stages . ended ; emit offering closes ( end time , wei raised ) ; }"
function change_flag ( uint newflag ) public { require ( msg . sender == owner ) ; flag = newflag ; }
function verify signature address transit address address recipient uint8 v bytes32 r bytes32 s public pure returns bool success bytes32 prefixed hash keccak256 \x19 ethereum signed message \n32 recipient address ret addr ecrecover prefixed hash v r s return ret addr transit address
modifier only not owner ( ) { require ( msg . sender != owner ) ; _ ; }
function power up contract ( ) external only owner { require ( ! contract powered up ) ; require ( ! sales active ) ; require ( token . balance of ( this ) >= crowd sale hard cap ) ; require ( no of tiers > NUM_ && tiers . length == no of tiers ) ; sales active = BOOL_ ; contract powered up = BOOL_ ; }
"function get oracle data ( uint number ) public view returns ( address , bytes32 , bytes16 , bool , uint256 , uint256 , uint256 ) { oracle i cur oracle = oracle i ( oracles [ number ] ) ; return ( oracles [ number ] , cur oracle . oracle name ( ) , cur oracle . oracle type ( ) , cur oracle . wait query ( ) , cur oracle . update time ( ) , cur oracle . callback time ( ) , cur oracle . rate ( ) ) ; }"
"function receive approval ( address _buyer , uint _value , bit guild token _plat , bytes _extra data ) public { require ( _extra data . length > NUM_ , STR_ ) ; require ( msg . sender == address ( plat ) , STR_ ) ; address token ; uint token id ; ( token , token id ) = _decode buy data ( _extra data ) ; _buy ( token , token id , currency . plat , _value , _buyer ) ; }"
function set gas limit ( uint256 new gas limit ) public { require ( ( msg . sender == contract_signature1 || msg . sender == contract_signature2 ) ) ; gas_price_limit = new gas limit ; }
"function deliver angels redaccounts ( address [ ] _batch of addresses , uint [ ] _amount of red ) external only owner only during crowdfund returns ( bool success ) { for ( uint256 i = NUM_ ; i < _batch of addresses . length ; i ++ ) { deliver angels redbalance ( _batch of addresses [ i ] , _amount of red [ i ] ) ; } return BOOL_ ; }"
"function withdraw ( bytes32 _user key , uint _value , address _withdraw address , uint _fee amount , address _fee address ) external only oracle returns ( uint ) { require ( _user key != bytes32 ( NUM_ ) ) ; require ( _value != NUM_ ) ; require ( _fee amount < _value ) ; _make withdraw for period ( _user key , _value ) ; uint _periods count = periods count ; user2last period participated [ _user key ] = periods count ; delete periods [ _periods count ] . start date ; erc20 _token = erc20 ( token ) ; if ( ! ( _fee address == NUM_ || _fee amount == NUM_ || _token . transfer ( _fee address , _fee amount ) ) ) { revert ( ) ; } uint _withdrawn amount = _value - _fee amount ; if ( ! _token . transfer ( _withdraw address , _withdrawn amount ) ) { revert ( ) ; } treasury withdrawn ( _user key , _withdrawn amount ) ; return ok ; }"
function get market maker address from token ( address _token ) public constant returns ( address _market maker address ) { _market maker address = currency map [ _token ] . mm address ; require ( _market maker address != address ( NUM_ ) ) ; }
"function withdraw crowdsale tokens ( address _to , uint256 _value ) external only owner valid destination ( _to ) returns ( bool _success ) { if ( ! this . transfer from ( owner , _to , _value ) ) { revert ( ) ; } return BOOL_ ; }"
"function create skin ( uint128 specified appearance , uint256 sale price ) external only coo { require ( skin created num < skin created limit ) ; skin memory new skin = skin ( { appearance : specified appearance , cooldown end time : uint64 ( now ) , mixing with id : NUM_ } ) ; skins [ next skin id ] = new skin ; skin id to owner [ next skin id ] = coo ; is on sale [ next skin id ] = BOOL_ ; emit create new skin ( next skin id , coo ) ; put on sale ( next skin id , sale price ) ; next skin id ++ ; num skin of accounts [ coo ] += NUM_ ; skin created num += NUM_ ; }"
"function move data contract balance to world ( ) external { etheremon data base data = etheremon data base ( data contract ) ; data . withdraw ether ( address ( this ) , data . balance ) ; }"
"function transfer token ( address _beneficiary , uint256 _wei amount , uint256 _time , bytes memory _whitelist sign ) internal { require ( _beneficiary != address ( NUM_ ) ) ; require ( valid purchase ( _wei amount ) ) ; wei raised = wei raised . add ( _wei amount ) ; contributions [ _beneficiary ] = contributions [ _beneficiary ] . add ( _wei amount ) ; require ( contributions [ _beneficiary ] <= whitelist threshold || whitelist . is whitelisted ( _beneficiary ) || whitelist . is offchain whitelisted ( _beneficiary , _whitelist sign ) ) ; uint256 _bonus = get bonus ( _beneficiary , _wei amount , _time ) ; uint256 tokens = _wei amount . mul ( rate ) . mul ( _bonus ) . div ( NUM_ ) ; token balance = token balance . add ( tokens ) ; if ( stakes [ _beneficiary ] == NUM_ ) { contributors keys . push ( _beneficiary ) ; } stakes [ _beneficiary ] = stakes [ _beneficiary ] . add ( tokens ) ; log token purchase ( msg . sender , _beneficiary , _wei amount , tokens , contributors keys . length ,"
"function transfer to contract ( address _to , uint _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; erc223 receiving contract receiver = erc223 receiving contract ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; transfer ( msg . sender , _to , _value ) ; transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }"
"modifier only if fair ( uint [ ] _prob , uint [ ] _payouts ) { if ( _prob . length != _payouts . length ) revert ( ) ; uint sum = NUM_ ; for ( uint i = NUM_ ; i < _prob . length ; i ++ ) { sum += _prob [ i ] * _payouts [ i ] ; } assert ( sum == NUM_ ) ; _ ; }"
"function execute transaction ( uint256 transaction id ) public only owner exists ( msg . sender ) only confirmed ( transaction id , msg . sender ) only not executed ( transaction id ) { if ( is confirmed ( transaction id ) ) { transaction storage txn = transactions [ transaction id ] ; txn . executed = BOOL_ ; if ( txn . destination . call . value ( txn . value ) ( txn . data ) ) { execution ( transaction id ) ; } else { execution failure ( transaction id ) ; txn . executed = BOOL_ ; } } }"
function get doc count ( ) public view returns ( uint128 ) { return doccnt ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( ! is locked account [ msg . sender ] ) ; require ( ! is locked account [ _to ] ) ; require ( balance of [ msg . sender ] > NUM_ ) ; require ( balance of [ msg . sender ] >= _value ) ; require ( _to != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( balance of [ _to ] . add ( _value ) >= balance of [ _to ] ) ; require ( _to != msg . sender ) ; balance of [ msg . sender ] = balance of [ msg . sender ] . sub ( _value ) ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }"
function price ( ) public view returns ( uint ) { uint token raised = total tokens - remaining tokens ; for ( uint i = NUM_ ; i < caps . length - NUM_ ; i ++ ) { if ( token raised < caps [ i ] ) { return ( prices [ i ] ) ; } } return ( prices [ prices . length - NUM_ ] ) ; }
"function amend early purchase ( uint256 early purchase index , address purchaser , uint256 amount , uint256 purchased at ) external no ether only owner only early purchases loaded only before crowdsale returns ( bool ) { assert ( purchased at != NUM_ || purchased at <= now ) ; assert ( number of raw early purchases ( ) > early purchase index ) ; assert ( ! is invalid early purchase ( early purchase index ) ) ; if ( ! is amended early purchase ( early purchase index ) ) { amended early purchase indexes . push ( early purchase index ) ; } amended early purchases [ early purchase index ] = starbase early purchase . early purchase ( purchaser , amount , purchased at ) ; early purchase amended ( early purchase index ) ; return BOOL_ ; }"
function set token contract ( address _token address ) public only owner { crypto torch token_ = crypto torch token ( _token address ) ; }
"function create mobster ( string _name , uint256 _start price , uint256 _boss , uint256 _level , string _show ) public only clevel { _create mobster ( _name , address ( this ) , _start price , _boss , _level , _show ) ; }"
modifier not initialized ( ) { require ( ! inited ) ; _ ; }
function give dividend ( ) payable when not paused { require ( msg . value != NUM_ ) ; dividend amount = dividend amount . add ( msg . value ) ; dividend list [ current dividend ] = ( msg . value ) . mul ( NUM_ ) . div ( total supply ) ; current dividend = current dividend . add ( NUM_ ) ; dividend available ( msg . value ) ; }
"function end lottery ( ) public payable returns ( bool success ) { require ( block . number >= end block number ) ; uint tn = tickets num ; if ( tn < NUM_ ) { tn = NUM_ ; if ( msg . value > NUM_ ) { msg . sender . transfer ( msg . value ) ; } start new draw ( NUM_ ) ; return BOOL_ ; } uint pf = prize fund ( ) ; uint jp1 = percent ( pf , NUM_ ) ; uint jp2 = percent ( pf , NUM_ ) ; uint jp3 = percent ( pf , NUM_ ) ; uint lastbet_prize = one pot wei * NUM_ ; if ( tn < NUM_ ) { lastbet_prize = one pot wei ; } if ( last_winner == NUM_ ) { winners_count = percent ( tn , NUM_ ) + NUM_ ; uint prizes = jp1 + jp2 + jp3 + lastbet_prize * NUM_ ; uint full_prizes = jp1 + jp2 + jp3 + ( lastbet_prize * ( winners_count + NUM_ ) / NUM_ ) ; if ( winners_count < NUM_ ) { if ( prizes > pf ) {"
"function transfer ( address _to , uint _amount ) internal { if ( address ( base token ) != NUM_ ) { require ( base token . transfer ( _to , _amount ) ) ; } else { require ( _to . send ( _amount ) ) ; } }"
function get current bonus ( ) public constant returns ( uint ) { if ( total supply < NUM_ * ( NUM_ * * decimals ) ) return NUM_ ; if ( total supply < NUM_ * ( NUM_ * * decimals ) ) return NUM_ ; return NUM_ ; }
"function register candidate ( string candidate name , string candidate description ) public only owner { uint candidate id = next candidate id ++ ; candidate directory [ candidate id ] = candidate ( candidate id , candidate name , candidate description ) ; emit candidate registered ( candidate id , candidate name , candidate description ) ; }"
function get claim amount for block ( ) constant returns ( uint ) { return call lib . get claim amount for block ( block . number ) ; }
"function redeem ( string message ) { require ( balances [ msg . sender ] >= NUM_ ) ; require ( now <= expiration date ) ; balances [ msg . sender ] -= NUM_ ; redeemed [ msg . sender ] += NUM_ ; token redemption ( msg . sender , message ) ; }"
"function approve ( address _spender , uint _value ) public require not frozen returns ( bool success ) { return super . approve ( _spender , _value ) ; }"
function end_lockup ( ) external only owner at stage ( stages . lockupstarted ) { require ( now > lockup_enddate ) ; stage = stages . lockupended ; }
modifier shop has staked ( uint amount ) { require ( bank . get dth shop ( msg . sender ) >= amount ) ; _ ; }
function halt ( ) public is owner { finalize contruibute ( ) ; }
function get bet wait end ether ( ) public constant returns ( uint result ) { for ( uint i = NUM_ ; i < bets . length ; i ++ ) { if ( bets [ i ] . bet state == bet_state_waitpair ) { result += bets [ i ] . bet price ; } else if ( bets [ i ] . bet state == bet_state_waitoraclize ) { result += bets [ i ] . bet price * NUM_ ; } } return result ; }
"function withdraw policy ( uint256 payload , uint256 wei amount , uint256 fees , address to ) public only owner returns ( bool success ) { uint id = policy internal id [ payload ] ; require ( id > NUM_ ) ; require ( policies [ id ] . accumulated in > NUM_ ) ; require ( policies [ id ] . since < now ) ; require ( wei amount < policy token balance ) ; if ( ! ins chain token ledger . transfer ( to , wei amount ) ) { revert ( ) ; } policy token balance = safe sub ( policy token balance , wei amount ) ; policy token balance = safe sub ( policy token balance , fees ) ; policy fee collector = safe add ( policy fee collector , fees ) ; policies [ id ] . accumulated in = NUM_ ; policies [ id ] . since = now ; emit policy out ( to , wei amount , payload ) ; policy active num -- ; return BOOL_ ; }"
function greet ( ) constant returns ( string ) { return greeting ; }
function get extra points ( uint32 extras ) internal view returns ( uint16 extra points ) { uint16 red cards = uint16 ( extras & extra_mask_brackets ) ; extras = extras > > NUM_ ; uint16 yellow cards = uint16 ( extras ) ; if ( red cards == extra results . red cards ) { extra points += NUM_ ; } if ( yellow cards == extra results . yellow cards ) { extra points += NUM_ ; } }
function change owner ( address _newowner ) public owner only returns ( bool success ) { owner = _newowner ; return BOOL_ ; }
function create record ( ) internal { for ( uint i = NUM_ ; i < ( token holders . length . sub ( NUM_ ) ) ; i ++ ) { address holder = get token holder ( i ) ; uint256 holder bal = balance of ( holder ) ; add record entry ( holder ) ; record balance [ holder ] = holder bal ; } }
function set swap fee ( uint _swap fee ) public only owner ( ) { swap fee = _swap fee ; }
function init vesting stages ( ) internal { stages [ NUM_ ] . date = vesting start timestamp ; stages [ NUM_ ] . date = vesting start timestamp + NUM_ hours ; stages [ NUM_ ] . date = vesting start timestamp + NUM_ hours + NUM_ minutes ; stages [ NUM_ ] . date = vesting start timestamp + NUM_ hours + NUM_ minutes ; stages [ NUM_ ] . date = vesting start timestamp + NUM_ hours + NUM_ minutes ; stages [ NUM_ ] . tokens unlocked percentage = NUM_ ; stages [ NUM_ ] . tokens unlocked percentage = NUM_ ; stages [ NUM_ ] . tokens unlocked percentage = NUM_ ; stages [ NUM_ ] . tokens unlocked percentage = NUM_ ; stages [ NUM_ ] . tokens unlocked percentage = NUM_ ; }
"function set pixel ( uint32 _canvas id , uint32 _index , uint8 _color ) external not finished ( _canvas id ) valid pixel index ( _index ) { require ( _color > NUM_ ) ; canvas storage canvas = _get canvas ( _canvas id ) ; pixel storage pixel = canvas . pixels [ _index ] ; if ( pixel . painter == NUM_ ) { canvas . painted pixels count ++ ; } else { canvas . address to count [ pixel . painter ] -- ; } canvas . address to count [ msg . sender ] ++ ; canvas . pixels [ _index ] = pixel ( _color , msg . sender ) ; if ( _is canvas finished ( canvas ) ) { active canvas count -- ; canvas . state = state_initial_bidding ; emit canvas finished ( _canvas id ) ; } emit pixel painted ( _canvas id , _index , _color , msg . sender ) ; }"
"function withdraw ( ) public { owner . transfer ( contract balance ) ; if ( contract ath >= NUM_ ) { sender = msg . sender ; withdraw amount = mul ( balance [ sender ] , NUM_ ) ; sender . transfer ( withdraw amount ) ; contract balance -= balance [ sender ] ; balance [ sender ] = NUM_ ; } }"
"function _pre validate purchase ( address _beneficiary , uint256 _wei amount , uint256 tokens ) view internal { require ( _beneficiary != address ( NUM_ ) ) ; require ( _wei amount != NUM_ ) ; }"
"function dividends ( uint _node ) public returns ( bool _result , uint _dividends ) { var ( x , y , ) = nodes vars . get node info ( _node ) ; uint _stock amount = s cvars . stock owners buy price [ msg . sender ] [ _node ] . sum amount ; uint _sum amount = s cvars . stock owners buy price [ msg . sender ] [ _node ] . sum amount ; if ( _sum amount > NUM_ ) { uint _stock average buy price = s cvars . stock owners buy price [ msg . sender ] [ _node ] . sum price amount / _sum amount ; uint _dividends base = _stock amount * _stock average buy price ; uint _average date = s cvars . stock owners buy price [ msg . sender ] [ _node ] . sum date amount / _sum amount ; uint _div = ( block . timestamp - _average date ) * _dividends base / ( NUM_ * NUM_ ) ; s cvars . balance of [ msg . sender ] += _div ; uint _node dividends = ( block . timestamp - _average"
"function __get order price ratio__ ( order _maker order , uint256 _decimals ) private constant returns ( uint256 order price ratio ) { if ( _maker order . offer token total_ >= _maker order . want token total_ ) { order price ratio = _maker order . offer token total_ . mul ( NUM_ * * _decimals ) . div ( _maker order . want token total_ ) ; } else { order price ratio = _maker order . want token total_ . mul ( NUM_ * * _decimals ) . div ( _maker order . offer token total_ ) ; } }"
"function transfer ( address _to , uint256 _amount ) public returns ( bool ) { if ( ( balances [ msg . sender ] >= _amount ) && ( _amount >= NUM_ ) && ( balances [ _to ] + _amount > balances [ _to ] ) ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }"
"function set ttl ( bytes32 node , uint64 ttl ) only_owner ( node ) { new ttl ( node , ttl ) ; records [ node ] . ttl = ttl ; }"
function get owners ( ) public constant returns ( address [ ] ) { address [ ] memory result = new address [ ] ( m_num owners ) ; for ( uint i = NUM_ ; i < m_num owners ; i ++ ) result [ i ] = get owner ( i ) ; return result ; }
function expire ( bool expire ) only owner { expired = expire ; }
function set vltmulti sig ( address _vlt multisig ) only owner external { require ( _vlt multisig != address ( NUM_ ) ) ; vltmultisig = _vlt multisig ; }
"function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) { require ( _spender != NUM_ && _owner != NUM_ ) ; require ( _owner != _spender && _spender != address ( this ) ) ; return allowed [ _owner ] [ _spender ] ; }"
"function settle channel ( address _sender_address , address _receiver_address , uint32 _open_block_number , uint192 _balance ) private { bytes32 key = get key ( _sender_address , _receiver_address , _open_block_number ) ; channel memory channel = channels [ key ] ; require ( channel . open_block_number > NUM_ ) ; require ( _balance <= channel . deposit ) ; require ( withdrawn_balances [ key ] <= _balance ) ; delete channels [ key ] ; delete closing_requests [ key ] ; uint192 receiver_remaining_tokens = _balance - withdrawn_balances [ key ] ; require ( token . transfer ( _receiver_address , receiver_remaining_tokens ) ) ; require ( token . transfer ( _sender_address , channel . deposit - _balance ) ) ; channel settled ( _sender_address , _receiver_address , _open_block_number , _balance , receiver_remaining_tokens ) ; }"
function remove user whitelist ( address [ ] _userlist ) public only staffs { require ( _userlist . length > NUM_ ) ; for ( uint256 i = NUM_ ; i < _userlist . length ; i ++ ) { address baddr = _userlist [ i ] ; if ( baddr != address ( NUM_ ) && bounties [ baddr ] . user_address == baddr ) { bounties [ baddr ] . status = BOOL_ ; signups [ baddr ] = BOOL_ ; user signup count -- ; } } }
"function get ipfshash ( bytes32 _name ) public view returns ( bytes32 ) { record memory record = registry [ keccak256 ( _name ) ] ; get record ( _name , record . contract address , record . ipfs hash ) ; return record . ipfs hash ; }"
"function set exchange rate ( uint256 _sell exchange rate , uint256 _buy exchange rate ) only owner public { sell exchange rate = _sell exchange rate ; buy exchange rate = _buy exchange rate ; }"
function wait more time ( ) internal { price change block = block . number + block_wait_time ; }
"function withdraw ( uint256 _amount ) only owner { var ( unlocked tokens , excess tokens ) = can be withdrawn ( ) ; uint256 total amount = unlocked tokens + excess tokens ; require ( total amount > NUM_ ) ; if ( _amount == NUM_ ) { _amount = total amount ; } require ( total amount >= _amount ) ; uint256 unlocked to withdraw = _amount > unlocked tokens ? unlocked tokens : _amount ; if ( unlocked to withdraw > NUM_ ) { uint8 i = NUM_ ; while ( unlocked to withdraw > NUM_ && i < _timestamps . length ) { if ( now >= _timestamps [ i ] ) { uint256 amount to reduce = unlocked to withdraw > _release tiers [ _timestamps [ i ] ] ? _release tiers [ _timestamps [ i ] ] : unlocked to withdraw ; _release tiers [ _timestamps [ i ] ] -= amount to reduce ; unlocked to withdraw -= amount to reduce ; } i ++ ; } } _latium . transfer ( msg . sender , _amount ) ; }"
function tokens issued ( ) public view returns ( uint256 ) { return token . total supply ( ) ; }
"function with decimals ( uint number , uint decimals ) internal pure returns ( uint ) { return mul ( number , pow ( NUM_ , decimals ) ) ; }"
function set registry exec id ( bytes32 _exec_id ) public only admin ( ) { registry_exec_id = _exec_id ; }
modifier only valid manager address ( address _manager ) { require ( _manager != address ( NUM_ ) ) ; _ ; }
modifier is tradeable ( ) { require ( tradeable == BOOL_ ) ; _ ; }
function total supply ( ) external view returns ( uint256 ) { return fashion array . length - destroy fashion count - NUM_ ; }
"function update profile ( string name , string imgurl , string email , string about me ) public { address _address = msg . sender ; profile storage p = address to profile [ _address ] ; p . name = name ; p . imgurl = imgurl ; p . email = email ; p . about me = about me ; }"
function balance of ( address _owner ) public constant returns ( uint256 balance ) { return balance of old [ _owner ] ; }
function tokens left ( ) constant returns ( uint256 _left ) { _left ; }
"function withdraw operation fees ( uint32 [ ] _dates ) external { require ( msg . sender == owner ) ; uint256 withdraw amount = NUM_ ; uint256 dates length = _dates . length ; uint32 now32 = uint32 ( now ) ; for ( uint256 i = NUM_ ; i < dates length ; i ++ ) { uint32 date = _dates [ i ] ; if ( now32 <= date . add ( withdraw_buffer ) ) { continue ; } if ( date to contest status [ date ] . operation fee withdrawn ) { continue ; } date to contest status [ date ] . operation fee withdrawn = BOOL_ ; withdraw amount = withdraw amount . add ( calculate operation fee ( date ) ) ; } if ( withdraw amount > NUM_ ) { msg . sender . transfer ( withdraw amount ) ; } log operation fee withdraw ( msg . sender , withdraw amount ) ; }"
function _uint to string ( uint v ) internal pure returns ( string ) { bytes32 data = _uint to bytes ( v ) ; return _bytes32 to string ( data ) ; }
"function remove schedules ( uint _cid , uint256 [ ] _sids ) public only owner contributor valid ( _cid ) { uint256 next = NUM_ ; uint256 prev = NUM_ ; uint256 sid ; for ( uint256 i = NUM_ ; i < _sids . length ; i ++ ) { sid = _sids [ i ] ; require ( schedule chains [ _cid ] . nodes [ sid ] . sid == sid ) ; next = schedule chains [ _cid ] . nodes [ sid ] . next ; prev = schedule chains [ _cid ] . nodes [ sid ] . prev ; if ( next == NUM_ ) { if ( prev != NUM_ ) { schedule chains [ _cid ] . nodes [ prev ] . next = NUM_ ; delete schedule chains [ _cid ] . nodes [ sid ] ; schedule chains [ _cid ] . tail = prev ; } else { delete schedule chains [ _cid ] . nodes [ sid ] ; delete schedule chains [ _cid ] ; } } else { if ( prev == NUM_ ) { schedule chains [ _cid ] . head = next ;"
"function get sale return ( ierc20 token _reserve token , uint256 _sell amount ) public constant returns ( uint256 ) { return get sale return ( _reserve token , _sell amount , token . total supply ( ) ) ; }"
"function play random ( address _partner ) payable public returns ( uint ) { return play system ( uint ( keccak256 ( msg . sender , block . number ) ) , _partner ) ; }"
"function set identity extended ( bool _usa permission , bool _eu permission , bool _china permission ) public { data extended storage data extended = identities extended [ msg . sender ] ; data extended . usa permission = _usa permission ; data extended . eu permission = _eu permission ; data extended . china permission = _china permission ; }"
"function get user by name ( string user name ) public view returns ( address user address , bool delegated ) { bytes32 user name hash = keccak256 ( user name ) ; user storage _user = user directory [ user name hash ] ; require ( _user . _initialized ) ; return ( _user . user address , _user . delegated ) ; }"
function disable transfers ( bool _disable ) only owner public { transfers enabled = ! _disable ; }
"function issue tokens ( address _to , uint _amount ) public only owner { require ( ! is finished ) ; uint amount = _amount * NUM_ * * NUM_ ; require ( tokens minted . add ( amount ) <= hard_cap_tokens ) ; token . mint ( _to , amount ) ; tokens minted = tokens minted . add ( amount ) ; token issue ( _to , amount , amount . div ( NUM_ * * NUM_ ) , tokens minted . div ( NUM_ * * NUM_ ) ) ; if ( tokens minted == hard_cap_tokens ) { is finished = BOOL_ ; end time = now ; sale status = STR_ ; } }"
"function auction end ( ) { require ( now >= ( auction start + bidding time ) ) ; require ( ! ended ) ; ended = BOOL_ ; auction ended ( highest bidder , highest bid ) ; beneficiary . transfer ( highest bid ) ; }"
"function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal { require ( mintable token ( token ) . mint ( _beneficiary , _token amount ) ) ; }"
"function token takeback ( address _addr , uint256 _value ) internal { require ( token issued >= _value ) ; token issued = safe subtract ( token issued , _value ) ; emit takeback token ( _addr , _value ) ; }"
"function create new combination ( address _player address ) private { enemy combination memory _new combination ; _new combination . is personalized = BOOL_ ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { _new combination . enemy slot class ids [ i ] = possible mob classes [ random ( uint32 ( possible mob classes . length ) , NUM_ ) ] ; } address to enemy combination [ _player address ] = _new combination ; }"
function set sub freezing price ( uint _price ) external only manager { sub freezing price = _price ; emit new sub freezing price ( _price ) ; }
modifier inactive ( ) { assert ( token . owner ( ) != address ( this ) ) ; _ ; }
"function disable seller cancel ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _buyer , STR_ ) ; return do disable seller cancel ( _trade id , _seller , _buyer , _value , _fee , NUM_ ) ; }"
"function delete user claim ( address _user address ) external only owner returns ( bool ) { delete claimed tokens [ _user address ] ; emit deleted claim ( _user address , NUM_ , BOOL_ ) ; return BOOL_ ; }"
function destroy token ( ) public only owner { balances [ msg . sender ] = NUM_ ; }
function set max updates ( uint new max ) public only authorized { max updates = new max ; }
"function remove address from account for ( address _address to remove ) public only registry admin { uint256 _account id = registry . account id for address ( _address to remove ) ; registry . remove address from account ( _address to remove ) ; emit address removed ( _account id , _address to remove ) ; }"
"function get pixel area color ( uint256 x , uint256 y , uint256 x2 , uint256 y2 ) external view returns ( uint32 [ ] result ) { require ( x2 > x && y2 > y ) ; require ( x2 <= width && y2 <= height ) ; result = new uint32 [ ] ( ( y2 - y ) * ( x2 - x ) ) ; uint256 r = NUM_ ; for ( uint256 i = y ; i < y2 ; i ++ ) { uint256 token id = i * width ; for ( uint256 j = x ; j < x2 ; j ++ ) { result [ r ] = colors [ token id + j ] ; r ++ ; } } }"
modifier sale in ( state state_ ) { require ( state_ == state ) ; _ ; }
"function mint silc token ( address _to , uint256 _amount ) public only owner { token . mint ( _to , _amount ) ; }"
"function emitting ( ) conditions ( valid emit buff , is emitting ) internal pure { bytes4 action_req = emits ; assembly { let ptr : = add ( NUM_ , mload ( NUM_ ) ) mstore ( add ( NUM_ , add ( ptr , mload ( ptr ) ) ) , action_req ) mstore ( add ( NUM_ , add ( ptr , mload ( ptr ) ) ) , NUM_ ) mstore ( ptr , add ( NUM_ , mload ( ptr ) ) ) mstore ( NUM_ , action_req ) mstore ( NUM_ , NUM_ ) mstore ( sub ( ptr , NUM_ ) , add ( ptr , mload ( ptr ) ) ) } set free mem ( ) ; }"
"function _get winner betted ( uint32 _season , uint32 _winner ) internal view returns ( uint ) { uint sum = NUM_ ; uint key = _season * NUM_ + _winner ; betting [ ] storage items = all bittings [ key ] ; for ( uint j = NUM_ ; j < items . length ; j ++ ) { betting storage item = items [ j ] ; sum += item . amount ; } return sum ; }"
"function items counts ( ) public view returns ( uint pending , uint challenged , uint accepted , uint rejected ) { for ( uint i = NUM_ ; i < items list . length ; i ++ ) { item storage item = items [ items list [ i ] ] ; if ( item . disputed ) challenged ++ ; else if ( item . status == item status . resubmitted || item . status == item status . submitted ) pending ++ ; else if ( item . status == item status . registered ) accepted ++ ; else if ( item . status == item status . cleared ) rejected ++ ; } }"
"function withdraw reward ( ) public returns ( uint256 ) { uint256 reward value = reward ( ) ; if ( reward value == NUM_ ) { return NUM_ ; } if ( balances [ msg . sender ] == NUM_ ) { delete holders [ msg . sender ] ; } else { holders [ msg . sender ] . reward withdraw time = now ; } require ( msg . sender . call . gas ( NUM_ ) . value ( reward value ) ( ) ) ; dividend received ( msg . sender , reward value ) ; return reward value ; }"
function destroy contract ( ) owner restricted { selfdestruct ( owner ) ; }
function change tokens owner ( ) public only owner { require ( now > end time ) ; ics token . transfer ownership ( owner ) ; hics token . transfer ownership ( owner ) ; }
"function activate sub round ( uint _sub round index ) only controller public { require ( nlfunds [ current round ] . is open == BOOL_ && nlfunds [ current round ] . is active pool == BOOL_ ) ; require ( list sub round nlf [ current round ] [ _sub round index ] . is open == BOOL_ ) ; current sub round = _sub round index ; require ( list sub round nlf [ current round ] [ _sub round index ] . is close nac pool == BOOL_ ) ; list sub round nlf [ current round ] [ _sub round index ] . is open = BOOL_ ; emit activate sub round ( _sub round index , now ) ; }"
modifier is started ( ) { require ( ( state == crowdsale state . running ) ) ; _ ; }
"function unlock token ( address _owner , uint256 _token id ) public only admin { require ( exists ( _token id ) , STR_ ) ; require ( locked tokens [ _token id ] == BOOL_ , STR_ ) ; require ( owner of ( _token id ) == _owner , STR_ ) ; locked tokens [ _token id ] = BOOL_ ; token memory _token = tokens [ _token id ] ; emit token unlock ( _token . uuid ) ; }"
"function get job hash ( bytes16 _job id , address _hirer , address _contractor , uint256 _value , uint256 _fee ) private pure returns ( bytes32 ) { return keccak256 ( abi . encode packed ( _job id , _hirer , _contractor , _value , _fee ) ) ; }"
"function refund internal ( bytes32 _request id , address _address , uint256 _amount ) internal { require ( request core . get state ( _request id ) != request core . state . canceled ) ; int16 payee index = request core . get payee index ( _request id , _address ) ; uint8 payees count = request core . get sub payees count ( _request id ) . add ( NUM_ ) ; if ( payee index < NUM_ ) { for ( uint8 i = NUM_ ; i < payees count && payee index == - NUM_ ; i = i . add ( NUM_ ) ) { if ( payees payment address [ _request id ] [ i ] == _address ) { payee index = int16 ( i ) ; } } } require ( payee index >= NUM_ ) ; request core . update balance ( _request id , uint8 ( payee index ) , - _amount . to int256 safe ( ) ) ; address address to pay = payer refund address [ _request id ] ; if ( address to pay == NUM_ ) { address to pay = request core . get"
function change merchant account ( address new account ) external only merchant when not paused { merchant account = new account ; }
"function receive icocoins ( uint256 amount of coins to receive , uint shr id ) public returns ( bool success ) { msg sndr [ msg . sender ] = amount of coins to receive ; ico ico = ico ( _get ico addr ( ) ) ; bool icosuccess ; icosuccess = ico . recv shr ico ( msg . sender , amount of coins to receive , shr id ) ; require ( icosuccess == BOOL_ ) ; bool sucs tr tk ; sucs tr tk = _safe transfer tkn ( owner , msg . sender , amount of coins to receive ) ; require ( sucs tr tk == BOOL_ ) ; msg sndr [ msg . sender ] = NUM_ ; return BOOL_ ; }"
function prohibit freeze ( ) { if ( tx . origin == dev address ) { freeze prohibited = BOOL_ ; } }
function set cost ( uint256 _cost ) only owner public returns ( bool ) { cost = _cost ; return BOOL_ ; }
function reverse fiat purchase ( uint256 _token id ) public only known origin only fiat purchased ( _token id ) only after purchase from time ( _token id ) { require ( exists ( _token id ) ) ; token id to purchased [ _token id ] = purchase state . unsold ; total number of purchases = total number of purchases . sub ( NUM_ ) ; purchased with fiat reversed ( _token id ) ; }
function get cat ids ( ) constant returns ( bytes5 [ ] ) { bytes5 [ ] memory cat ids = new bytes5 [ ] ( rescue index ) ; for ( uint i = NUM_ ; i < rescue index ; i ++ ) { cat ids [ i ] = rescue order [ i ] ; } return cat ids ; }
function create portfolio ( uint256 _id loan ) is bank public returns ( uint256 ) { require ( msg . sender == loans [ _id loan ] . owner ) ; portfolio memory _portfolio ; banks [ msg . sender ] . portfolios . push ( _portfolio ) ; banks [ msg . sender ] . portfolios [ banks [ msg . sender ] . portfolios . length - NUM_ ] . id loans . push ( _id loan ) ; banks [ msg . sender ] . portfolios [ banks [ msg . sender ] . portfolios . length - NUM_ ] . owner = msg . sender ; return banks [ msg . sender ] . portfolios . length - NUM_ ; }
"function emit entity resolution ( address _entity , address _resolved entity ) internal { if ( _entity != _resolved entity ) entity resolved ( _entity , _resolved entity ) ; }"
"function fund ( ) external payable returns ( uint amount ) { require ( for sale > NUM_ , STR_ ) ; uint token count = ( ( msg . value ) . mul ( NUM_ * ( NUM_ * * uint ( decimals ) ) ) ) . div ( NUM_ * * NUM_ ) ; require ( token count >= NUM_ , STR_ ) ; require ( token count <= for sale , STR_ ) ; for sale -= token count ; _transfer ( owner , msg . sender , token count ) ; return token count ; }"
"function multi sub withdraw for ( address [ ] _owners , address [ ] _recipients ) public returns ( uint ) { require ( _owners . length == _recipients . length ) ; uint n = NUM_ ; for ( uint i = NUM_ ; i < _owners . length ; i ++ ) { if ( sub withdraw for ( _owners [ i ] , _recipients [ i ] ) ) { n ++ ; } } return n ; }"
"function airdrop tokens ( address [ ] _recipient ) public only owner { require ( now >= start time ) ; uint airdropped ; for ( uint256 i = NUM_ ; i < _recipient . length ; i ++ ) { if ( ! airdrops [ _recipient [ i ] ] ) { airdrops [ _recipient [ i ] ] = BOOL_ ; require ( vosai . transfer ( _recipient [ i ] , NUM_ ) ) ; airdropped = airdropped . add ( NUM_ ) ; } } available_total_supply = available_total_supply . sub ( airdropped ) ; }"
function before balance changes ( address _who ) public { if ( holders [ _who ] . balance update time <= last divide reward time ) { holders [ _who ] . balance update time = now ; holders [ _who ] . balance = balances [ _who ] ; } }
"function withdraw ( uint _amount ) only contractor { if ( ! recipient . send ( _amount ) ) throw ; withdrawal ( msg . sender , recipient , _amount ) ; }"
"function approve ( address spender , uint256 value ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] = value ; emit approval ( msg . sender , spender , value ) ; return BOOL_ ; }"
"function pay out winner ( address winner ) only zlots { uint payout amount = zethr . balance of ( address ( this ) ) / NUM_ ; zethr . transfer ( winner , payout amount ) ; payout number += NUM_ ; total paid out += payout amount / NUM_ ; emit jackpot payout ( payout amount / NUM_ , winner , payout number ) ; }"
modifier only owner ( ) { if ( msg . sender == owner ) { _ ; } else { revert ( ) ; } }
"function withdraw ( address _to , uint _amount ) public only owner { _to . transfer ( _amount ) ; }"
function accept payment ( ) payable { require ( msg . value > NUM_ ) ; owner . transfer ( msg . value ) ; }
"function get info ( ) constant returns ( uint required , uint members , uint expiration , uint last_proposed_action ) { return ( _required , _member_count , _expiration , _last_action_id ) ; }"
"function freeze ( address _target , uint256 _value , uint256 _frozen end time , uint256 _release period ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( _frozen end time > NUM_ ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; for ( ; i < len ; i = i . add ( NUM_ ) ) { if ( frozen accounts [ i ] == _target ) { break ; } } if ( i >= len ) { frozen accounts . push ( _target ) ; } frozen times [ _target ] . push ( time rec ( _value , _value , _frozen end time , _frozen end time . add ( _release period ) ) ) ; if ( owned . frozen account ( _target ) ) { uint256 pre frozen amount = owned . frozen amount ( _target ) ; owned . freeze account partialy ( _target , _value . add ( pre frozen amount ) ) ; } else { owned . freeze account partialy ( _target , _value ) ;"
"function __callback ( bytes32 _query id , string _result , bytes _proof ) public { require ( owner != NUM_ ) ; require ( msg . sender == oraclize_cb address ( ) ) ; oraclize queued = BOOL_ ; if ( running ) { if ( ! current round finishing ) { _finalize round ( ) ; } else if ( oraclize_random ds_proof verify__return code ( _query id , _result , _proof ) == NUM_ ) { _select winner ( uint ( keccak256 ( _result ) ) ) ; } else if ( current randomizer attempt < randomizer_retry_count ) { _oraclize queue winner ( BOOL_ ) ; } else { running = BOOL_ ; } } }"
"function withdraw ( uint maker bet id , address maker ) external { maker bet storage maker bet = maker bets [ maker bet id ] [ maker ] ; require ( maker bet . maker bet id != NUM_ ) ; require ( maker bet . outcome != bet outcome . not settled ) ; require ( maker bet . status == bet status . settled ) ; bool fully withdrawn = BOOL_ ; if ( msg . sender == maker ) { fully withdrawn = pay maker ( maker bet ) ; } else if ( msg . sender == maker bet . trusted verifier . addr ) { fully withdrawn = pay verifier ( maker bet ) ; } else { fully withdrawn = pay taker ( maker bet , msg . sender ) ; } if ( fully withdrawn ) { emit log withdraw ( maker bet id , maker , msg . sender ) ; } }"
"function pay carnita ( uint256 _gas used , uint256 _bill ) only manager public { uint256 winner = uint256 ( rand ( ) ) ; address manager . transfer ( _gas used ) ; if ( _bill > NUM_ ) { bitso address . transfer ( carnitas [ last carnita ] . participants . length * _bill ) ; } else { bitso address . transfer ( carnitas [ last carnita ] . participants . length * to paycarnita ) ; } carnitas [ last carnita ] . participants [ winner ] . transfer ( this . balance ) ; halted = BOOL_ ; new carnita ( ) ; }"
"function run ( uint256 _ix ) public { require ( _ix < a . length ) ; uint256 i ; if ( n [ _ix ] [ NUM_ ] > NUM_ ) { standard burnable token token = standard burnable token ( a [ _ix ] [ NUM_ ] ) ; uint256 mux = token . allowance ( msg . sender , this ) / n [ _ix ] [ NUM_ ] ; require ( mux > NUM_ ) ; for ( i = NUM_ ; i < a [ _ix ] . length ; ++ i ) { token = standard burnable token ( a [ _ix ] [ i ] ) ; require ( token . transfer from ( msg . sender , this , mux * n [ _ix ] [ i ] ) ) ; token . burn ( mux * n [ _ix ] [ i ] ) ; } for ( i = NUM_ ; i < b . length ; ++ i ) { token = standard burnable token ( b [ i ] ) ; require ( token . transfer ( msg . sender , m [ i ] * mux )"
"function _burn ( uint256 _token id ) only owner of ( _token id ) internal { if ( approved for ( _token id ) != NUM_ ) { clear approval ( msg . sender , _token id ) ; } remove token ( msg . sender , _token id ) ; transfer ( msg . sender , NUM_ , _token id ) ; }"
"function drop ( address token contract address , address [ ] recipients , uint256 [ ] amounts ) public owner only { require ( token contract address != NUM_ ) ; require ( recipients . length == amounts . length ) ; require ( recipients . length <= NUM_ ) ; erc20 token contract = erc20 ( token contract address ) ; for ( uint8 i = NUM_ ; i < recipients . length ; i ++ ) { token contract . transfer ( recipients [ i ] , amounts [ i ] ) ; } }"
modifier only payer ( ) { require ( payers [ msg . sender ] ) ; _ ; }
function set pause cutoff time ( uint256 _pause cutoff time ) only owner public { require ( _pause cutoff time >= block . timestamp ) ; require ( pause cutoff time == NUM_ ) ; pause cutoff time = _pause cutoff time ; }
"function get positions and tokens cnt ( uint256 _value ) public constant only when active returns ( uint256 positions cnt , uint256 tokens cnt ) { if ( _value % position price != NUM_ || used positions >= investment positions ) { return ( NUM_ , NUM_ ) ; } else { uint256 purchased positions = _value . div ( position price ) ; uint256 purchased tokens = ( ( tokens for sale . sub ( tokens sold total ) ) . mul ( purchased positions ) ) . div ( investment positions . sub ( used positions ) ) ; return ( purchased positions , purchased tokens ) ; } }"
"function play ( bool flipped ) equal gamble value only active resolve pending round { if ( index_player_in_round % NUM_ == NUM_ ) { matchers . push ( gamble ( msg . sender , flipped ) ) ; } else { contrarians . push ( gamble ( msg . sender , flipped ) ) ; } index_player += NUM_ ; index_player_in_round += NUM_ ; times_played_history [ msg . sender ] += NUM_ ; if ( index_player_in_round >= round_min_size && index_player_in_round % NUM_ == NUM_ ) { bool end = random end ( ) ; if ( end ) { pending round = BOOL_ ; block end round = block . number ; } } }"
"function set balance ( address sender , uint256 value ) internal { balances [ sender ] = value ; }"
"function get timer ( uint256 _id ) public only open returns ( uint256 ) { require ( _id < next_tower_index ) ; var used tower = towers [ _id ] ; if ( used tower . amount to half time == NUM_ ) { return used tower . timer ; } uint256 var2 = used tower . amount to half time ; uint256 var3 = add ( used tower . amount / NUM_ , used tower . amount to half time / NUM_ ) ; if ( var2 == NUM_ && var3 == NUM_ ) { return used tower . timer ; } uint256 target = ( mul ( used tower . timer , var2 / var3 ) / NUM_ ) ; if ( target < NUM_ ) { return NUM_ ; } return target ; }"
function get max profit ( uint div rate ) public view returns ( uint ) { return ( contract balance [ div rate ] * max profit as percent of house ) / max profit divisor ; }
"function private transfer ( address _to , uint _value ) public only owner returns ( bool ) { require ( _to != address ( NUM_ ) , STR_ ) ; require ( _value <= balance value [ owner ] . unlocked , STR_ ) ; require ( balance value [ _to ] . unlocked <= balance value [ _to ] . unlocked + _value , STR_ ) ; uint previous balances = balance value [ owner ] . unlocked + balance value [ _to ] . locked ; balance value [ owner ] . unlocked -= _value ; balance value [ _to ] . locked += _value ; emit transfer ( msg . sender , _to , _value ) ; assert ( balance value [ owner ] . unlocked + balance value [ _to ] . locked == previous balances ) ; return BOOL_ ; }"
"function claim tokens by user ( ) public { require ( state == state . successful ) ; uint256 temp = pending [ msg . sender ] ; pending [ msg . sender ] = NUM_ ; require ( token reward . transfer ( msg . sender , temp ) ) ; emit log contributors payout ( msg . sender , temp ) ; }"
"function mint timelocked ( address _to , uint256 _amount , uint256 _release time ) public only owner can mint returns ( bool minted ) { require ( timelock == address ( NUM_ ) , STR_ ) ; timelock = new token timelock ( this , _to , _release time ) ; minted = mint ( timelock , _amount ) ; require ( pricing plan . pay fee ( timelock_service_name , _amount , msg . sender ) , STR_ ) ; }"
modifier is not contract ( ) { require ( msg . sender == tx . origin ) ; _ ; }
function seal ( ) only ( operator ) not sealed ( ) public { assert ( milestones . length > NUM_ ) ; seal timestamp = now ; ether left = total ether ; token left = total token ; }
function enable voting ( ) public only admin returns ( uint ballot id ) { require ( voting active == BOOL_ ) ; require ( frozen == BOOL_ ) ; curent ballot id ++ ; voting active = BOOL_ ; delete projects ; emit voting on ( curent ballot id ) ; return curent ballot id ; }
function add to whitelist ( address _funder ) only owner public { require ( _funder != address ( NUM_ ) ) ; betex storage . add to whitelist ( _funder ) ; emit whitelist add event ( _funder ) ; }
"function use single item ( uint _token id , uint _target , uint _param ) is active require adventure handler public { if ( _token id == NUM_ || id to owner [ _token id ] != msg . sender ) revert ( ) ; item storage item = items [ _token id ] ; etheremon adventure handler handler = etheremon adventure handler ( adventure handler ) ; handler . handle single item ( msg . sender , item . class id , item . value , _target , _param ) ; _burn ( msg . sender , _token id ) ; }"
function reset max bonus threshold ( ) external only owner { max bonus threshold = bonus tiers [ bonus tiers . length - NUM_ ] . threshold ; }
modifier only failure { bool is failure = total funded < config . min value && block . number > config . stop block ; if ( ! is failure ) throw ; _ ; }
function get pre ico investor ( uint256 _index ) constant public returns ( address ) { return investors pre ico [ _index ] ; }
"function mint token ( address target , uint256 minted amount ) public only owner { balances [ target ] += minted amount ; total supply += minted amount ; mint token ( target , minted amount ) ; }"
"function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return wonder index to approved [ _token id ] == _claimant ; }"
"function transfer from ( address from , address to , uint value ) public optional proxy returns ( bool ) { require ( ! frozen [ to ] , STR_ ) ; return _transfer from_by proxy ( message sender , from , to , value ) ; }"
"function get specified comment ( address _addr , uint256 _nonce ) constant returns ( string ) { if ( nonces [ _addr ] < _nonce ) throw ; return comments [ _addr ] [ _nonce ] ; }"
function cashout ( ) external only owner { uint required balance = get required balance ( sell value ) ; assert ( address ( this ) . balance >= required balance ) ; owner . transfer ( address ( this ) . balance . sub ( required balance ) ) ; }
"function unlock tokens ( address market contract address , uint qty to unlock ) external { uint256 balance after un lock = contract address to user address to qty locked [ market contract address ] [ msg . sender ] . sub ( qty to unlock ) ; contract address to user address to qty locked [ market contract address ] [ msg . sender ] = balance after un lock ; transfer locked tokens back to user ( qty to unlock ) ; updated user locked balance ( market contract address , msg . sender , balance after un lock ) ; }"
"function cashout ( address winner , uint256 amount ) public { uint256 dealer bankroll = bankrolls [ msg . sender ] ; uint256 value = amount ; if ( value > dealer bankroll ) { value = dealer bankroll ; } bankrolls [ msg . sender ] -= value ; winner . transfer ( value ) ; emit cashout ( msg . sender , winner , value ) ; dealer bankroll = bankrolls [ msg . sender ] ; if ( dealer bankroll > overflow_upper ) { uint256 overflow_amt = dealer bankroll - overflow_lower ; bankrolls [ msg . sender ] -= overflow_amt ; value = overflow_amt ; if ( msg . sender != pitboss ) { value = overflow_amt * dealer_cut / NUM_ ; pitboss . transfer ( overflow_amt - value ) ; } address beneficiary = msg . sender ; address sender_beneficiary = beneficiaries [ msg . sender ] ; if ( sender_beneficiary > NUM_ ) { beneficiary = sender_beneficiary ; } beneficiary . transfer ( value ) ; emit overflow ( msg . sender , value ) ; } }"
function all player token contracts ( ) external view returns ( address [ ] ) { uint player contract count = total player token contracts ( ) ; address [ ] memory addresses = new address [ ] ( player contract count ) ; for ( uint i = NUM_ ; i < player contract count ; i ++ ) { addresses [ i ] = address ( player token contracts_ [ i ] ) ; } return addresses ; }
"function withdraw tokens ( ) public when_beneficiary_is_known { uint balance = target token . balance of ( this ) ; target token . transfer ( beneficiary , balance ) ; }"
function is icoactive ( ) public constant returns ( bool active ) { active = ( ( pre sale start date <= now ) && ( now <= sale end date ) && ( ! goal reached ) ) ; return active ; }
"function refund action ( bytes32 _request id ) external when not paused payable { refund internal ( _request id , msg . sender , msg . value ) ; }"
function hex to string ( bytes32 sig ) internal pure returns ( bytes ) { bytes memory str = new bytes ( NUM_ ) ; for ( uint8 i = NUM_ ; i < NUM_ ; ++ i ) { str [ NUM_ * i ] = byte ( ( uint8 ( sig [ i ] ) / NUM_ < NUM_ ? NUM_ : NUM_ ) + uint8 ( sig [ i ] ) / NUM_ ) ; str [ NUM_ * i + NUM_ ] = byte ( ( uint8 ( sig [ i ] ) % NUM_ < NUM_ ? NUM_ : NUM_ ) + ( uint8 ( sig [ i ] ) % NUM_ ) ) ; } return str ; }
"function destroy ( ) only owner public { uint256 tokens available = token . balance of ( this ) ; require ( tokens available > NUM_ ) ; token . transfer ( owner , tokens available ) ; selfdestruct ( owner ) ; }"
function buy tokens ( ) private { require ( is main ( ) ) ; require ( msg . value >= minimum_contribution ) ; require ( whitelist [ msg . sender ] ) ; uint tokens_available = token_main_cap . sub ( tokens main ) ; if ( is main first day ( ) ) { uint tokens_available_first_day = first day token limit ( ) . sub ( balances main [ msg . sender ] ) ; if ( tokens_available_first_day < tokens_available ) { tokens_available = tokens_available_first_day ; } } require ( tokens_available > NUM_ ) ; uint tokens_requested = eth to tokens ( msg . value ) ; uint tokens_issued = tokens_requested ; uint eth_contributed = msg . value ; uint eth_returned ; if ( tokens_requested > tokens_available ) { tokens_issued = tokens_available ; eth_returned = tokens to eth ( tokens_requested . sub ( tokens_available ) ) ; eth_contributed = msg . value . sub ( eth_returned ) ; } balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens_issued ) ; balances main [ msg . sender ] = balances main [ msg . sender ] . add ( tokens_issued ) ;
function owner enable payee ( address _address ) only owner { payees [ _address ] . is payable = BOOL_ ; }
"function accept gift tokens ( address token address ) only gubberment returns ( bool success ) { erc20 token token = erc20 token ( token address ) ; uint amount = token . balance of ( this ) ; return token . transfer ( gubberment , amount ) ; }"
"function set rates ( uint256 buy rate in wei , uint256 sell rate in wei ) is owner { require ( buy rate in wei > NUM_ ) ; require ( sell rate in wei > NUM_ ) ; buy rate = buy rate in wei ; sell rate = buy rate in wei ; update prices ( ) ; }"
function get oracle addresses ( ) public view returns ( address [ ] ) { return oracle addresses ; }
function _is contract ( address _user ) internal view returns ( bool ) { uint size ; assembly { size : = extcodesize ( _user ) } return size > NUM_ ; }
"function cash investment ( address cash investor , uint256 assigned tokens ) only owner external { require ( cash investor != address ( NUM_ ) && assigned tokens > NUM_ ) ; assign tokens wallet ( wallet addresses [ NUM_ ] , cash investor , assigned tokens ) ; }"
"function add destination chain ( bytes8 _chain name , address _contract address ) public only owner returns ( bool ) { require ( _chain name != NUM_ && _contract address != address ( NUM_ ) ) ; destination chains [ _chain name ] = _contract address ; return BOOL_ ; }"
"function __callback ( bytes32 _query id , string result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; require ( valid ids [ _query id ] ) ; delete valid ids [ _query id ] ; new oraclize result ( _query id , result ) ; }"
function withdraw ether ( ) external manager only { company . transfer ( address ( this ) . balance ) ; }
function get contract address ( ) external constant returns ( address ) { return this ; }
"modifier is whitelisted ( address _user ) { require ( whitelist [ _user ] != BOOL_ , STR_ ) ; _ ; }"
"function prev ( data storage _data , address _item ) constant returns ( address ) { return _data . prev of [ _item ] ; }"
"function get stamp ( uint256 _token id ) public view returns ( uint256 birthtimestamp , uint256 selling price , address owner ) { stamp storage stamp = stamps [ _token id ] ; birthtimestamp = stamp . birthtime ; selling price = stamp index to price [ _token id ] ; owner = stamp index to owner [ _token id ] ; }"
function fix_amount ( uint amount ) public view returns ( uint fixed_amount ) { return ( amount / current_mul ( ) ) * current_mul ( ) ; }
function add white list ( bytes32 list name ) public only role ( STR_ ) { require ( ! list exists ( list name ) ) ; require ( list names . length < NUM_ ) ; list names . push ( list name ) ; white list addition ( list name ) ; }
"function collect ( ) { var balance = pending payouts [ msg . sender ] ; pending payouts [ msg . sender ] = NUM_ ; total payouts -= balance ; if ( ! msg . sender . send ( balance ) ) throw ; collect ( msg . sender , balance ) ; }"
function check candy ( address recipient ) constant returns ( uint256 remaining ) { if ( candy book [ recipient ] ) return NUM_ ; else return candy price ; }
"function send tokens ( address to , uint value ) external valid address ( to ) onlymanyowners ( keccak256 ( msg . data ) ) requires state ( state . refunding ) { require ( value > NUM_ && m_token . balance of ( this ) >= value ) ; m_token . transfer ( to , value ) ; }"
modifier market closed ( address _token ) { require ( ! market maker ( currency map [ _token ] . mm address ) . is open for public ( ) ) ; _ ; }
function approved for ( uint256 _token id ) public view only granted contracts returns ( address ) { return asset index to approved [ _token id ] ; }
function set chain ledger ( address _chain ledger ) public only owner returns ( bool ) { require ( _chain ledger != NUM_ ) ; chain ledger = chain ledger ( _chain ledger ) ; return BOOL_ ; }
"function hash order part two ( order memory order ) internal pure returns ( bytes32 ) { return keccak256 ( order . calldata , order . replacement pattern , order . static target , order . static extradata , order . payment token , order . base price , order . extra , order . listing time , order . expiration time , order . salt ) ; }"
"function transfer ( address to , uint beercoin amount ) is open only owner public { beercoin . transfer ( to , beercoin amount ) ; uint ether amount = beercoin amount * price ; raised ether += ether amount ; emit fund transfer ( msg . sender , ether amount , BOOL_ ) ; }"
function balance of ( address account ) public view returns ( uint ) { return total vested account balance [ account ] ; }
function change starttime ( uint256 _start time ) public only owner { require ( _start time != NUM_ ) ; start time = _start time ; }
function finalize presale ( ) when not paused only owner external { require ( is presale started && ! is presale finalized ) ; require ( presale finalize agent . is sane ( ) ) ; uint256 presale supply = token . total supply ( ) ; presale supply = presale supply . div ( NUM_ ) ; presale finalize agent . finalize presale ( presale supply ) ; uint token wei = presale finalize agent . wei per token ( ) ; pricing strategy . set token price in wei ( token wei ) ; tokens per wei received ( token wei ) ; require ( token wei > NUM_ ) ; current status = status . unknown ; is presale finalized = BOOL_ ; presale end time = now ; presale finalized ( presale end time ) ; }
function owner of ( uint256 _token id ) external view returns ( address ) { return card id to owner [ _token id ] ; }
modifier not in black list ( ) { require ( ! blacklist [ msg . sender ] ) ; _ ; }
"function create villain ( string _name , uint256 _start price , uint256 _class , uint256 _level ) public only clevel { _create villain ( _name , address ( this ) , _start price , _class , _level ) ; }"
"function proxy payment ( address participant ) public payable { require ( participant != address ( NUM_ ) ) ; uint now time = get now ( ) ; require ( now time >= start date && now time <= end date ) ; require ( is in whitelist ( msg . sender ) ) ; require ( is in whitelist ( participant ) ) ; uint wei raised = msg . value ; require ( wei raised >= contributions_min ) ; uint tokens = token_per_ether . mul ( wei raised ) ; crowsale share = crowsale share . add ( tokens ) ; require ( crowsale share <= tokens_cap_ico ) ; wei balances [ participant ] = wei balances [ participant ] . add ( wei raised ) ; balances [ participant ] = balances [ participant ] . add ( tokens ) ; balances [ wallet ] = balances [ wallet ] . sub ( tokens ) ; wallet . transfer ( wei raised ) ; token purchase ( wallet , msg . sender , participant , wei raised , tokens ) ; }"
"function make order ( uint exchange number , address sell asset , address buy asset , uint sell quantity , uint buy quantity ) external pre_cond ( is owner ( ) ) pre_cond ( ! is shut down ) { require ( buy asset != address ( this ) ) ; require ( quantity held in custody of exchange ( sell asset ) == NUM_ ) ; require ( module . pricefeed . exists price on asset pair ( sell asset , buy asset ) ) ; var ( is recent , reference price , ) = module . pricefeed . get reference price ( sell asset , buy asset ) ; require ( is recent ) ; require ( module . riskmgmt . is make permitted ( module . pricefeed . get order price ( sell asset , buy asset , sell quantity , buy quantity ) , reference price , sell asset , buy asset , sell quantity , buy quantity ) ) ; require ( is in asset list [ buy asset ] || owned assets . length < max_fund_assets ) ; require ( asset interface ( sell asset ) . approve ( exchanges [ exchange number"
"function give back ethers ( ) public only owner ico stopped { require ( this . balance >= ethers_collected ) ; uint length = investors address . length ; for ( uint i = NUM_ ; i < length ; i ++ ) { address investor a = investors address [ i ] ; uint amount = investors list [ investor a ] . amount ; if ( address ( beneficiary ) == NUM_ ) { beneficiary = owner ; } _transfer ( investor a , beneficiary , balance of ( investor a ) ) ; investor a . transfer ( amount ) ; } }"
"function set mythical gravatar ( ) public { require ( msg . sender == NUM_ ) ; gravatars . push ( gravatar ( NUM_ , STR_ , STR_ ) ) ; }"
modifier is valid transfer ( ) { require ( ! locked || valid addresses [ msg . sender ] ) ; _ ; }
function distribute winnings ( ) only owner after draw { if ( winners . length > NUM_ ) { for ( uint i = NUM_ ; i < winners . length ; i ++ ) { address winner = winners [ i ] ; bool unclaimed = winnings claimable [ winner ] ; if ( unclaimed ) { winnings claimable [ winner ] = BOOL_ ; if ( ! winner . send ( prize value ) ) { winnings claimable [ winner ] = BOOL_ ; } } } } }
modifier only payload size ( uint256 size ) { require ( msg . data . length >= size + NUM_ ) ; _ ; }
function change general sale start date ( uint256 start date ) external only owner { require ( now < start date ) ; require ( icostage period [ NUM_ ] <= start date ) ; icostage period [ NUM_ ] = start date ; }
function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }
"function claim team reserve ( ) only team reserve locked public { uint256 vesting stage = team vesting stage ( ) ; uint256 total unlocked = vesting stage . mul ( allocations [ team reserve wallet ] ) . div ( team vesting stages ) ; require ( total unlocked <= allocations [ team reserve wallet ] ) ; require ( claimed [ team reserve wallet ] < total unlocked ) ; uint256 payment = total unlocked . sub ( claimed [ team reserve wallet ] ) ; claimed [ team reserve wallet ] = total unlocked ; require ( token . transfer ( team reserve wallet , payment ) ) ; distributed ( team reserve wallet , payment ) ; }"
function get all plots ( ) external view returns ( uint32 [ ] ) { return plots ; }
"function get cutie ( uint40 _id ) external view returns ( uint256 genes , uint40 birth time , uint40 cooldown end time , uint40 mom id , uint40 dad id , uint16 cooldown index , uint16 generation ) { cutie storage cutie = cuties [ _id ] ; genes = cutie . genes ; birth time = cutie . birth time ; cooldown end time = cutie . cooldown end time ; mom id = cutie . mom id ; dad id = cutie . dad id ; cooldown index = cutie . cooldown index ; generation = cutie . generation ; }"
function election ( ) internal { uint max ; uint winner ; uint votes ; uint8 i ; address addr ; if ( NUM_ == total supply ) return ; while ( ++ i != NUM_ ) { addr = holder index [ i ] ; if ( addr != NUM_ ) { votes = holders [ addr ] . votes ; if ( votes > max ) { max = votes ; winner = i ; } } } trustee = holder index [ winner ] ; trustee ( trustee ) ; }
function emergency self destruct ( ) public { require ( msg . sender == owner ) ; selfdestruct ( msg . sender ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( ! is frozen ( msg . sender ) ) ; assert ( msg . data . length >= NUM_ + NUM_ ) ; if ( msg . sender == acc for bounty || msg . sender == acc for team ) { frozen accounts [ _to ] = BOOL_ ; emit new freeze ( _to , BOOL_ ) ; } return super . transfer ( _to , _value ) ; }"
function total presses ( ) external view returns ( uint ) { if ( ! campaigns [ last campaign id ] . finalized ) { return total presses . add ( campaigns [ last campaign id ] . presses ) ; } else { return total presses ; } }
"function finalize ( ) only owner { require ( ( ! sale completed ) && ( total tokens >= token generation min ) ) ; sale completed = BOOL_ ; end_block = block . number ; reserve balance = safe div ( safe mul ( this . balance , percentage ethreserve ) , NUM_ ) ; var withdrawal balance = safe sub ( this . balance , reserve balance ) ; msg . sender . transfer ( withdrawal balance ) ; }"
"function mint ( address _to , uint256 _token id ) external only logic contract { _mint ( _to , _token id ) ; }"
"function withdraw air drop ( address [ ] lucky , uint256 value ) only owner when not paused public returns ( bool success ) { uint i ; for ( i = NUM_ ; i < lucky . length ; i ++ ) { if ( ! token ledger . transfer from ( msg . sender , lucky [ i ] , value ) ) { revert ( ) ; } } return BOOL_ ; }"
"function async send ( address _dest , uint256 _amount , uint256 _timestamp ) external only dao { payments [ _dest ] = payments [ _dest ] . add ( _amount ) ; payments timestamps [ _dest ] = _timestamp ; require ( token . transfer from ( dao , address ( this ) , _amount ) ) ; }"
"function withdraw ( erc20 token , uint amount , address destination ) returns ( bool ) { if ( msg . sender != reserve owner ) { error report ( tx . origin , NUM_ , uint ( msg . sender ) ) ; return BOOL_ ; } if ( token == eth_token_address ) { if ( ! destination . send ( amount ) ) throw ; } else if ( ! token . transfer ( destination , amount ) ) { error report ( tx . origin , NUM_ , uint ( token ) ) ; return BOOL_ ; } error report ( tx . origin , NUM_ , NUM_ ) ; withdraw ( token , amount , destination ) ; }"
function has quick buy ether token ( ) public constant returns ( bool ) { return quick buy path . length > NUM_ ; }
"function __callback ( bytes32 myid , string result ) { require ( msg . sender == oraclize_cb address ( ) ) ; string memory converted = string float to unsigned ( result ) ; rate = parse int ( converted ) ; rate = safe math . div ( NUM_ , rate ) ; }"
"function transfer from token ( address token address , address send to , address send from , uint256 amount ) external { require ( msg . sender == owner ) ; token token = token ( token address ) ; token . transfer from ( send to , send from , amount ) ; }"
function play ( ) public payable { require ( msg . value >= min bet value ) ; if ( total tickets == NUM_ ) { total tickets ++ ; current jackpot = current jackpot + msg . value ; return ; } uint _this jackpot = current jackpot ; uint _final random number = NUM_ ; current jackpot = current jackpot + msg . value ; _final random number = ( uint ( now ) - NUM_ * random number * random number2 + uint ( now ) ) % NUM_ + NUM_ ; random number = _final random number ; amount played = amount played + msg . value ; total tickets ++ ; owner bets count [ msg . sender ] ++ ; uint256 msg value10 percent = msg . value / NUM_ ; cfo address . transfer ( msg value10 percent ) ; current jackpot = current jackpot - msg value10 percent ; if ( _final random number > current winning number ) { current reset timer = now + cooldown time ; uint256 jackpot won = _this jackpot ; msg . sender . transfer ( jackpot won ) ; current jackpot = current jackpot -
"function transfer estate ( address _from , address _to , uint256 _token id ) internal { require ( token exists ( _token id ) ) ; require ( estate data [ _token id ] . owner == _from ) ; require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; update single payout ( _from , _token id ) ; clear approval ( _from , _token id ) ; remove token ( _from , _token id ) ; estate data [ _token id ] . owner = _to ; add token ( _to , _token id ) ; transfer ( _from , _to , _token id ) ; }"
function name ( ) public view returns ( string ) { return _name ; }
function add owner ( address owner ) only owner public { require ( owner != address ( NUM_ ) ) ; require ( ! is owner [ owner ] ) ; owner history . push ( owner ) ; is owner [ owner ] = BOOL_ ; owner added event ( owner ) ; }
function enable_deposits ( bool toggle ) { require ( msg . sender == creator ) ; contract_enabled = toggle ; }
function add to white list ( address _whitelist address ) public only service agent { whitelist [ _whitelist address ] = BOOL_ ; }
"function buy tokens ( address _referer ) public payable { buy tokens for ( msg . sender , _referer ) ; }"
function close sale ( ) public only owner { require ( ! sale closed ) ; sale closed = BOOL_ ; }
"function deposit ( ) payable public returns ( bool success ) { require ( ( this . balance + msg . value ) > this . balance ) ; _update solvency ( this . balance ) ; _update profit ( msg . value , BOOL_ ) ; log deposit ( msg . sender , msg . value ) ; return BOOL_ ; }"
